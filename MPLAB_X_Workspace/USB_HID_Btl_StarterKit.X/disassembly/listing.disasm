Disassembly Listing for USB_HID_Btl_StarterKit
Generated From:
/home/bekeband/MPLABXProjects/AN1388_Source_Code_2014_02_14/PIC32_Bootloaders/Firmware/Bootloader/MPLAB_X_Workspace/USB_HID_Btl_StarterKit.X/dist/default/production/USB_HID_Btl_StarterKit.X.production.elf
2014.05.05. 14:33:38

---  /opt/microchip/xc32/v1.21/pic32mx/include/peripheral/system.h  -------------------------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the Company) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Companys customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
9D0046F4  8FC2002C   LW V0, 44(S8)
9D0046F8  AFC20030   SW V0, 48(S8)
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D0046FC  8FC3002C   LW V1, 44(S8)
9D004700  3C0204C4   LUI V0, 1220
9D004704  3442B401   ORI V0, V0, -19455
9D004708  0062102B   SLTU V0, V1, V0
9D00470C  14400008   BNE V0, ZERO, 0x9D004730
9D004710  00000000   NOP
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
9D004714  3C020008   LUI V0, 8
9D004718  AFC20034   SW V0, 52(S8)
118:                         pb_clock >>= 1;
9D00471C  8FC20030   LW V0, 48(S8)
9D004720  00021042   SRL V0, V0, 1
9D004724  AFC20030   SW V0, 48(S8)
9D004728  0B4011CD   J 0x9D004734
9D00472C  00000000   NOP
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
9D004730  AFC00034   SW ZERO, 52(S8)
9D004734  8FC20034   LW V0, 52(S8)
9D004738  AFC20038   SW V0, 56(S8)
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
9D004674  AFC00024   SW ZERO, 36(S8)
9D004678  0B4011A8   J 0x9D0046A0
9D00467C  00000000   NOP
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
9D0046A0  8FC30020   LW V1, 32(S8)
9D0046A4  3C0201C9   LUI V0, 457
9D0046A8  3442C381   ORI V0, V0, -15487
9D0046AC  0062102B   SLTU V0, V1, V0
9D0046B0  1040FFF3   BEQ V0, ZERO, 0x9D004680
9D0046B4  00000000   NOP
170:                     {
171:                         wait_states++;
9D004680  8FC20024   LW V0, 36(S8)
9D004684  24420001   ADDIU V0, V0, 1
9D004688  AFC20024   SW V0, 36(S8)
172:                         sys_clock -= FLASH_SPEED_HZ;
9D00468C  8FC30020   LW V1, 32(S8)
9D004690  3C02FE36   LUI V0, -458
9D004694  34423C80   ORI V0, V0, 15488
9D004698  00621021   ADDU V0, V1, V0
9D00469C  AFC20020   SW V0, 32(S8)
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
9D0046B8  0F40162D   JAL INTDisableInterrupts
9D0046BC  00000000   NOP
9D0046C0  AFC20028   SW V0, 40(S8)
176:                     mCheConfigure(wait_states);
9D0046C4  3C02BF88   LUI V0, -16504
9D0046C8  8FC30024   LW V1, 36(S8)
9D0046CC  AC434000   SW V1, 16384(V0)
177:                     INTRestoreInterrupts(int_status);
9D0046D0  8FC40028   LW A0, 40(S8)
9D0046D4  0F4015F9   JAL INTRestoreInterrupts
9D0046D8  00000000   NOP
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
227:                     {
228:                         wait_states++;
229:                         sys_clock -= FLASH_SPEED_HZ;
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
233:                     mCheConfigure(wait_states);
234:                     INTRestoreInterrupts(int_status);
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
279:                 
280:                     int_status=INTDisableInterrupts();
281:                 
282:                     mBMXDisableDRMWaitState();
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
286:                     cache_status |= CHE_CONF_PF_ALL;
287:                     mCheConfigure(cache_status);
288:                     CheKseg0CacheOn();
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
9D004640  0F40162D   JAL INTDisableInterrupts
9D004644  00000000   NOP
9D004648  AFC2001C   SW V0, 28(S8)
342:                 
343:                     mBMXDisableDRMWaitState();
9D00464C  3C02BF88   LUI V0, -16504
9D004650  24030040   ADDIU V1, ZERO, 64
9D004654  AC432004   SW V1, 8196(V0)
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
9D004658  8FC20018   LW V0, 24(S8)
9D00465C  30420001   ANDI V0, V0, 1
9D004660  304200FF   ANDI V0, V0, 255
9D004664  1040001D   BEQ V0, ZERO, 0x9D0046DC
9D004668  00000000   NOP
9D00466C  8FC20014   LW V0, 20(S8)
9D004670  AFC20020   SW V0, 32(S8)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
9D0046DC  8FC20018   LW V0, 24(S8)
9D0046E0  30420002   ANDI V0, V0, 2
9D0046E4  10400068   BEQ V0, ZERO, 0x9D004888
9D0046E8  00000000   NOP
9D0046EC  8FC20014   LW V0, 20(S8)
9D0046F0  AFC2002C   SW V0, 44(S8)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
9D004888  8FC20018   LW V0, 24(S8)
9D00488C  30420004   ANDI V0, V0, 4
9D004890  1040000C   BEQ V0, ZERO, 0x9D0048C4
9D004894  00000000   NOP
358:                     {
359:                         cache_status = mCheGetCon();
9D004898  3C02BF88   LUI V0, -16504
9D00489C  8C424000   LW V0, 16384(V0)
9D0048A0  AFC20050   SW V0, 80(S8)
360:                         cache_status |= CHE_CONF_PF_ALL;
9D0048A4  8FC20050   LW V0, 80(S8)
9D0048A8  34420030   ORI V0, V0, 48
9D0048AC  AFC20050   SW V0, 80(S8)
361:                         mCheConfigure(cache_status);
9D0048B0  3C02BF88   LUI V0, -16504
9D0048B4  8FC30050   LW V1, 80(S8)
9D0048B8  AC434000   SW V1, 16384(V0)
362:                         CheKseg0CacheOn();
9D0048BC  0F401600   JAL CheKseg0CacheOn
9D0048C0  00000000   NOP
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
9D0048C4  8FC20014   LW V0, 20(S8)
9D0048C8  AFC20054   SW V0, 84(S8)
367:                     pb_clk >>= OSCCONbits.PBDIV;
9D0048CC  3C02BF81   LUI V0, -16511
9D0048D0  8C42F000   LW V0, -4096(V0)
9D0048D4  7C420CC0   EXT V0, V0, 19, 2
9D0048D8  304200FF   ANDI V0, V0, 255
9D0048DC  8FC30054   LW V1, 84(S8)
9D0048E0  00431006   SRLV V0, V1, V0
9D0048E4  AFC20054   SW V0, 84(S8)
368:                 
369:                     INTRestoreInterrupts(int_status);
9D0048E8  8FC4001C   LW A0, 28(S8)
9D0048EC  0F4015F9   JAL INTRestoreInterrupts
9D0048F0  00000000   NOP
370:                 
371:                     return pb_clk;
9D0048F4  8FC20054   LW V0, 84(S8)
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  /opt/microchip/xc32/v1.21/pic32mx/include/peripheral/osc.h  ----------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the Company) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Companys customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  #define _OSC_
47:                  
48:                  /*********************************************************************
49:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
50:                   *
51:                   * Description:	    Sets Osc options and clock source
52:                   *
53:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
54:                   *
55:                   * Inputs:	    	Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
56:                   *
57:                   * Output:          None
58:                   *
59:                   * Example:	    	OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
60:                   *
61:                   * Note:	    	Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
62:                   * 		     		source and then switches to the new clock source
63:                   *
64:                   *		    		Unused parameters are set to zero/default values.
65:                   ********************************************************************/
66:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
67:                  
68:                  	/******************************************************************************
69:                  	 * Available options for source parameter
70:                  	 *****************************************************************************/
71:                  		// CPU Oscillator modes - values are mutually exclusive
72:                  		#define OSC_FRC_DIV 	(7 << _OSCCON_NOSC_POSITION)
73:                  		#define OSC_FRC_DIV16 	(6 << _OSCCON_NOSC_POSITION)
74:                  		#define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
75:                  		#define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
76:                  		#define OSC_POSC_PLL 	(3 << _OSCCON_NOSC_POSITION)
77:                  		#define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
78:                  		#define OSC_FRC_PLL 	(1 << _OSCCON_NOSC_POSITION)
79:                  		#define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
80:                  
81:                  	/******************************************************************************
82:                  	 * Available options for mult parameter
83:                  	 *****************************************************************************/
84:                  		// CPU PLL multiplier values - values are mutually exclusive
85:                  		#define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
86:                  		#define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
87:                  		#define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
88:                  		#define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
89:                  		#define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
90:                  		#define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
91:                  		#define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
92:                  		#define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
93:                  
94:                  	/******************************************************************************
95:                  	 * Available options for post parameter
96:                  	 *****************************************************************************/
97:                  		// CPU PLL output divisor values - values are mutuallye exclusive
98:                  		#define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
99:                  		#define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
100:                 		#define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
101:                 		#define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
102:                 		#define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
103:                 		#define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
104:                 		#define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
105:                 		#define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
106:                 
107:                 	/******************************************************************************
108:                 	 * Available options for div parameter
109:                 	 *****************************************************************************/
110:                 		// CPU FRC output divisor values - values are mutually exclusive
111:                 		#define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
112:                 		#define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
113:                 		#define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
114:                 		#define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
115:                 		#define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
116:                 		#define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
117:                 		#define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
118:                 		#define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
119:                 	/***********************************
120:                 	 * End parameter values
121:                 	 ************************************/
122:                 
123:                 #if (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || \
124:                     (__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 370) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450) || (__PIC32_FEATURE_SET__ == 470))
125:                 	
126:                 		// Reference Oscillator Source Select bits - values are mutually exclusive
127:                 	#define OSC_REFOCON_REFCLKI	 	(7 << _REFOCON_ROSEL_POSITION )
128:                 	#define OSC_REFOCON_SYSPLL 		(7 << _REFOCON_ROSEL_POSITION )
129:                 	#define OSC_REFOCON_USBPLL 		(6 << _REFOCON_ROSEL_POSITION )
130:                 	#define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
131:                 	#define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
132:                 	#define OSC_REFOCON_FRC 		(3 << _REFOCON_ROSEL_POSITION )
133:                 	#define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
134:                 	#define OSC_REFOCON_PBCLK 		(1 << _REFOCON_ROSEL_POSITION )
135:                 	#define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
136:                 		
137:                 	typedef enum
138:                 	{		
139:                 		OSC_REFOCON_RLSPEN		=(1 << _REFOCON_RSLP_POSITION )	,
140:                 		OSC_REFOCON_OE			=(1 << _REFOCON_OE_POSITION ),
141:                 		OSC_REFOCON_SIDLEN		=(1 << _REFOCON_SIDL_POSITION ),
142:                 		OSC_REFOCON_ON			=(1 << _REFOCON_ON_POSITION )
143:                 	} OSCREFConfigFlags;
144:                 	
145:                 	void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
146:                 	 
147:                 
148:                 	#define mOSCREFOTRIMSet(trim) 		(REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
149:                 
150:                 #endif
151:                 
152:                 	 
153:                 	 
154:                 	 
155:                 /*********************************************************************
156:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
157:                  *
158:                  * Description:	Configures peripheral bus divisor
159:                  *
160:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
161:                  *
162:                  * Inputs:    oscPbDiv - desired PB divider
163:                  *
164:                  * Output:      None
165:                  *
166:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
167:                  *
168:                  ********************************************************************/
169:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
170:                 {
171:                 	unsigned int dma_status;
172:                 	unsigned int int_status;
173:                 	__OSCCONbits_t oscBits;
174:                 
175:                 	mSYSTEMUnlock(int_status, dma_status);
9D00473C  0F40162D   JAL INTDisableInterrupts
9D004740  00000000   NOP
9D004744  AFC2003C   SW V0, 60(S8)
9D00478C  AFC20044   SW V0, 68(S8)
9D004790  3C02BF81   LUI V0, -16511
9D004794  AC40F230   SW ZERO, -3536(V0)
9D004798  3C02BF81   LUI V0, -16511
9D00479C  3C03AA99   LUI V1, -21863
9D0047A0  34636655   ORI V1, V1, 26197
9D0047A4  AC43F230   SW V1, -3536(V0)
9D0047A8  3C02BF81   LUI V0, -16511
9D0047AC  3C035566   LUI V1, 21862
9D0047B0  346399AA   ORI V1, V1, -26198
9D0047B4  AC43F230   SW V1, -3536(V0)
176:                 	
177:                 	oscBits.w=OSCCON;		// read to be in sync. flush any pending write
9D0047B8  3C02BF81   LUI V0, -16511
9D0047BC  8C42F000   LW V0, -4096(V0)
9D0047C0  AFC20058   SW V0, 88(S8)
178:                 	oscBits.PBDIV=0;
9D0047C4  8FC20058   LW V0, 88(S8)
9D0047C8  7C02A4C4   INS V0, ZERO, 19, 2
9D0047CC  AFC20058   SW V0, 88(S8)
179:                 	oscBits.w|=oscPbDiv;	
9D0047D0  8FC30058   LW V1, 88(S8)
9D0047D4  8FC20038   LW V0, 56(S8)
9D0047D8  00621025   OR V0, V1, V0
9D0047DC  AFC20058   SW V0, 88(S8)
180:                 	OSCCON=oscBits.w;		// write back
9D0047E0  8FC30058   LW V1, 88(S8)
9D0047E4  3C02BF81   LUI V0, -16511
9D0047E8  AC43F000   SW V1, -4096(V0)
181:                 	oscBits.w=OSCCON;		// make sure the write occurred before returning from this function
9D0047EC  3C02BF81   LUI V0, -16511
9D0047F0  8C42F000   LW V0, -4096(V0)
9D0047F4  AFC20058   SW V0, 88(S8)
182:                 	
183:                 	mSYSTEMLock(int_status, dma_status);
9D0047F8  3C02BF81   LUI V0, -16511
9D0047FC  3C033333   LUI V1, 13107
9D004800  34633333   ORI V1, V1, 13107
9D004804  AC43F230   SW V1, -3536(V0)
9D004808  8FC20044   LW V0, 68(S8)
9D00480C  AFC20048   SW V0, 72(S8)
9D00487C  8FC4003C   LW A0, 60(S8)
9D004880  0F4015F9   JAL INTRestoreInterrupts
9D004884  00000000   NOP
184:                 }
185:                 
186:                 #define		mOSCSetPBDIV		OSCSetPBDIV		// backward compatibility
187:                 
188:                 
189:                 
190:                 	/******************************************************************************
191:                 	 * Available options for config parameter
192:                 	 *****************************************************************************/
193:                 		// CPU Peripheral Bus divisor values - values are mutually exclusive
194:                 		#define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
195:                 		#define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
196:                 		#define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
197:                 		#define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
198:                 	/***********************************
199:                 	 * End config parameter values
200:                 	 ************************************/
201:                 
202:                 
203:                 /*********************************************************************
204:                  * Function:    mOSCGetPBDIV()
205:                  *
206:                  * Description:	Reads peripheral bus divisor
207:                  *
208:                  * PreCondition:None
209:                  *
210:                  * Inputs:	  	None
211:                  *
212:                  * Output:      None
213:                  *
214:                  * Example:	  	mOSCGetPBDIV()
215:                  *
216:                  ********************************************************************/
217:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
218:                 
219:                 
220:                 /*********************************************************************
221:                  * Function:    mOSCClockFailStatus()
222:                  *
223:                  * Description:	Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
224:                  *
225:                  * PreCondition: None
226:                  *
227:                  * Inputs:	  	None
228:                  *
229:                  * Output:      None
230:                  *
231:                  * Example:	  	mOSCClockFailStatus()
232:                  *
233:                  ********************************************************************/
234:                 #define mOSCClockFailStatus (OSCCONbits.CF)
235:                 
236:                 
237:                 /*********************************************************************
238:                  * Function:      	mOSCEnableSOSC()
239:                  *
240:                  * Description:	  	Enables the LPRC
241:                  *
242:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
243:                  *
244:                  * Inputs:	  		None
245:                  *
246:                  * Output:        	None
247:                  *
248:                  * Example:	  		mOSCEnableSOSC()
249:                  *
250:                  ********************************************************************/
251:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
252:                 
253:                 
254:                 /*********************************************************************
255:                  * Function:      	mOSCDisableSOSC(config)
256:                  *
257:                  * Description:	  	Disables SOSC
258:                  *
259:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
260:                  *
261:                  * Inputs:	  		None
262:                  *
263:                  * Output:        	None
264:                  *
265:                  * Example:	  		mOSCDisableSOSC()
266:                  *
267:                  ********************************************************************/
268:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
269:                 
270:                 
271:                 
272:                 #endif
---  /opt/microchip/xc32/v1.21/pic32mx/include/peripheral/dma_3xx_4xx.h  --------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:	xc.h
8:                    * 					int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Compiler:        MPLAB XC32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the Company) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Companys customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_H_
43:                  #define _DMA_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  
48:                  // DMA definitions
49:                  
50:                  #ifdef _DMAC0
51:                  	#define _DMA_CHANNELS		// DMA channels exist
52:                  
53:                  
54:                  // existent DMA channels
55:                  	typedef enum
56:                  	{
57:                  		DMA_CHANNEL0,
58:                  	#ifdef _DMAC1
59:                  		DMA_CHANNEL1,
60:                  	#ifdef _DMAC2
61:                  		DMA_CHANNEL2,
62:                  	#ifdef _DMAC3
63:                  		DMA_CHANNEL3,
64:                  	#ifdef _DMAC4
65:                  		DMA_CHANNEL4,
66:                  	#ifdef _DMAC5
67:                  		DMA_CHANNEL5,
68:                  	#ifdef _DMAC6
69:                  		DMA_CHANNEL6,
70:                  	#ifdef _DMAC7
71:                  		DMA_CHANNEL7,
72:                  	#endif	// _DMAC7
73:                  	#endif	// _DMAC6
74:                  	#endif	// _DMAC5
75:                  	#endif	// _DMAC4
76:                  	#endif	// _DMAC3
77:                  	#endif	// _DMAC2
78:                  	#endif	// _DMAC1
79:                  		//	add/remove DMA channel as needed here
80:                  
81:                  		DMA_CHANNELS	// number of current available channels
82:                  	}DmaChannel;
83:                  
84:                  
85:                  	// Relative Dma channels priority, between each other
86:                  	typedef enum
87:                  	{
88:                  		DMA_CHN_PRI0,
89:                  		DMA_CHN_PRI1,
90:                  		DMA_CHN_PRI2,
91:                  		DMA_CHN_PRI3
92:                  	}DmaChannelPri;
93:                  
94:                  
95:                  
96:                  	// high level definitions for the API functions
97:                  
98:                  	typedef enum
99:                  	{
100:                 		DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
101:                 		DMA_OPEN_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
102:                 		DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
103:                 		DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),				// DMA channel is chained to higher channel
104:                 		DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,					// events detection enabled while channel off
105:                 		DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
106:                 		DMA_OPEN_MATCH	= 0x80000000,                           // DMA channel stops on match
107:                 	}DmaOpenFlags;	// flags for the channel open
108:                 
109:                 
110:                 	typedef enum
111:                 	{
112:                 		DMA_EV_ERR =			0x1,		// address error event
113:                 		DMA_EV_ABORT = 			0x2,		// transfer abort event
114:                 		DMA_EV_CELL_DONE =		0x4,		// cell transfer complete event
115:                 		DMA_EV_BLOCK_DONE =		0x8,		// block transfer complete event
116:                 		DMA_EV_DST_HALF =		0x10,		// destination half event
117:                 		DMA_EV_DST_FULL =		0x20,		// destination full event
118:                 		DMA_EV_SRC_HALF =		0x40,		// source half event
119:                 		DMA_EV_SRC_FULL =		0x80,		// source full event
120:                 
121:                 		DMA_EV_ALL_EVNTS=		(DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
122:                 									DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)				// all available events
123:                 	}DmaEvFlags;	// flags for controlling the DMA channel events; Bit fields from the processor header file.
124:                 
125:                 
126:                 	typedef enum
127:                 	{
128:                 		DMA_TXFER_OK,			// the transfer was performed successfully
129:                 		DMA_TXFER_ADD_ERR,		// address error while performing the transfer
130:                 		DMA_TXFER_ABORT,		// the DMA transfer was aborted
131:                 		DMA_TXFER_BC_ERR,		// block complete not set after the DMA transfer performed
132:                 		DMA_TXFER_CC_ERR,		// cell complete not set after the DMA transfer performed
133:                 		DMA_TXFER_TMO			// DMA transfer timeout
134:                 	}DmaTxferRes;		// DMA transfer result
135:                 
136:                 	typedef enum
137:                 	{
138:                 		DMA_WAIT_NOT,		// don't wait for the transfer to complete, return immediately
139:                 		DMA_WAIT_CELL,		// wait for the cell transfer to complete, than return
140:                 		DMA_WAIT_BLOCK		// wait for the block transfer to complete, than return
141:                 	}DmaWaitMode;		// DMA transfer wait mode
142:                 
143:                 
144:                 	/*********************************************************************
145:                 	 * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
146:                 	 *
147:                 	 * PreCondition:    chPri  - valid channel priority, 0-3
148:                 	 *
149:                 	 * Input:           chn    - channel to be configured in the DMA controller
150:                 	 *                  chPri  - the priority given to the channel, 0-3
151:                 	 *                  oFlags - orred flags specifying the open mode:
152:                 	 *                           DMA_OPEN_DEFAULT: DMA default operation mode
153:                 	 *                           DMA_OPEN_AUTO:	DMA channel is auto enabled
154:                 	 *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
155:                 	 *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
156:                 	 *                           DMA_OPEN_DET_EN: events detection enabled while channel off
157:                 	 *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
158:                 	 *                           DMA_OPEN_MATCH:	DMA channel stops on match
159:                 	 *
160:                 	 *
161:                 	 *
162:                 	 * Output:          None
163:                 	 *
164:                 	 * Side Effects:    None
165:                 	 *
166:                 	 * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
167:                 	 *
168:                 	 * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
169:                 	 *                  Use the low level functions to address special settings.
170:                 	 *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
171:                 	 *                  After that the channel is configured.
172:                 	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
173:                 	 *                  if DMA_OPEN_ENABLE flag was not specified.
174:                 	 *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
175:                 	 *                  This way, the transfer will occur correctly together with CRC calculation.
176:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
177:                 	 *                  User has to call event channel functions to enable the event flags if needed.
178:                 	 *
179:                 	 * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
180:                 	 ********************************************************************/
181:                 	 void			DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
182:                 
183:                 	/*********************************************************************
184:                 	 * Function:        void DmaChnEnable(DmaChannel chn)
185:                 	 *
186:                 	 * PreCondition:    None
187:                 	 *
188:                 	 * Input:			chn		- channel to be enabled
189:                 	 *
190:                 	 * Output:          None
191:                 	 *
192:                 	 * Side Effects:    None
193:                 	 *
194:                 	 * Overview:		The function enables a previously configured DMA channel.
195:                 	 *
196:                 	 * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
197:                 	 *
198:                 	 * Example:			DmaChnEnable(DMA_CHANNEL2);
199:                 	 ********************************************************************/
200:                 	 void			DmaChnEnable(DmaChannel chn);
201:                 
202:                 	/*********************************************************************
203:                 	 * Function:        void DmaChnDisable(DmaChannel chn)
204:                 	 *
205:                 	 * PreCondition:    None
206:                 	 *
207:                 	 * Input:			chn		- selected channel in the DMA controller
208:                 	 *
209:                 	 * Output:          None
210:                 	 *
211:                 	 * Side Effects:    None
212:                 	 *
213:                 	 * Overview:		The function disables a DMA channel. The channel operation stops.
214:                 	 *
215:                 	 * Note:            None.
216:                 	 *
217:                 	 * Example:			DmaChnDisable(DMA_CHANNEL2);
218:                 	 ********************************************************************/
219:                 	 void			DmaChnDisable(DmaChannel chn);
220:                 
221:                 	/*********************************************************************
222:                 	 * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
223:                 	 *
224:                 	 * PreCondition:    chn		- valid DMA channel
225:                 	 * 				- vSrcAdd, vDstAdd	- valid pointers
226:                 	 *                              - 0 < srcSize <= DmaGetMaxTxferSize()
227:                 	 *                              - 0 < dstSize <= DmaGetMaxTxferSize()
228:                 	 *                              - 0 < cellSize <= DmaGetMaxTxferSize()
229:                 	 *
230:                 	 * Input:			chn			- DMA channel number
231:                 	 * 								- vSrcAdd: source of the DMA transfer
232:                 	 * 								- vDstAdd: destination of the DMA transfer
233:                 	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
234:                 	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
235:                 	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
236:                 	 *
237:                 	 * Output:          None
238:                 	 *
239:                 	 * Side Effects:    None
240:                 	 *
241:                 	 * Overview:		The function sets the transfer characteristics for a DMA channel transfer:
242:                 	 * 					the source and the destination addresses.
243:                 	 * 					the source and destination lengths
244:                 	 * 					and the number of bytes	transferred per event.
245:                 	 *
246:                 	 * Note:			The function clears the existing DMA channel event flags.
247:                 	 *
248:                 	 * Example:			DmaChnSetTxfer(DMA_CHANNEL2, &U2RXREG, dstBuff, 1, 200, 1);
249:                 	 ********************************************************************/
250:                 	 void			DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
251:                 
252:                 
253:                 	/*********************************************************************
254:                 	 * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
255:                 	 *
256:                 	 * PreCondition:    chn		- valid DMA channel
257:                 	 *
258:                 	 * Input:           chn		- DMA channel number
259:                 	 * 				- vSrcAdd: source (virtual) of the DMA transfer
260:                 	 * Output:          None
261:                 	 *
262:                 	 * Side Effects:    None
263:                 	 *
264:                 	 * Overview:        The function is a helper to set directly the transfer source address.
265:                 	 *
266:                 	 * Note:            None.
267:                 	 *
268:                 	 * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
269:                 	 ********************************************************************/
270:                 	 void			DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
271:                 
272:                 	/*********************************************************************
273:                 	 * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
274:                 	 *
275:                 	 * PreCondition:    chn		- valid DMA channel
276:                 	 *
277:                 	 * Input:			chn			- DMA channel number
278:                 	 * 								- vDstAdd: destination (virtual) of the DMA transfer
279:                 	 * Output:          None
280:                 	 *
281:                 	 * Side Effects:    None
282:                 	 *
283:                 	 * Overview:		The function is a helper to set directly the transfer destination address.
284:                 	 *
285:                 	 * Note:            None
286:                 	 *
287:                 	 * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
288:                 	 ********************************************************************/
289:                 	 void			DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
290:                 
291:                 	/*********************************************************************
292:                 	 * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
293:                 	 *
294:                 	 * PreCondition:    chn	- valid DMA channel
295:                 	 *
296:                 	 * Input:			chn		- DMA channel number
297:                 	 * 					pattern	-  the match pattern
298:                 	 *
299:                 	 * Output:          None
300:                 	 *
301:                 	 * Side Effects:    None
302:                 	 *
303:                 	 * Overview:		The function sets the curent match pattern for the selected DMA channel.
304:                 	 *
305:                 	 * Note:            None.
306:                 	 *
307:                 	 * Example:			DmaChnSetMatchPattern(DMA_CHANNEL2, '\r');
308:                 	 ********************************************************************/
309:                 	 void			DmaChnSetMatchPattern(DmaChannel chn, int pattern);
310:                 
311:                 	/*********************************************************************
312:                 	 * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
313:                 	 *
314:                 	 * PreCondition:    chn	- valid DMA channel
315:                 	 *
316:                 	 * Input:			chn		- DMA channel number
317:                 	 *
318:                 	 * Output:          The channel match pattern.
319:                 	 *
320:                 	 * Side Effects:    None
321:                 	 *
322:                 	 * Overview:		The function retrieves the curent match pattern for the selected DMA channel.
323:                 	 *
324:                 	 * Note:            None.
325:                 	 *
326:                 	 * Example:			int pattern=DmaChnGetMatchPattern(DMA_CHANNEL2);
327:                 	 ********************************************************************/
328:                 	 int			DmaChnGetMatchPattern(DmaChannel chn);
329:                 
330:                 	/*********************************************************************
331:                 	 * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
332:                 	 *
333:                 	 * PreCondition:    chn	- valid DMA channel
334:                 	 *
335:                 	 * Input:			chn		- DMA channel number
336:                 	 * 					wMode	- if DMA_WAIT_NOT, return immediately
337:                 	 * 							- if DMA_WAIT_CELL, return after the cell transfer complete
338:                 	 * 							- if DMA_WAIT_BLOCK, return after the whole transfer is done
339:                 	 * 					retries	- retry counter: if transfer not complete after so many retries, return with tmo.
340:                 	 * 								If 0, wait forever.
341:                 	 *
342:                 	 * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
343:                 	 * 					an DmaTxferRes error code  otherwise
344:                 	 *
345:                 	 * Side Effects:    None
346:                 	 *
347:                 	 * Overview:		The function initiates (forces) a DMA transfer for the selected DMA channel.
348:                 	 * 					The DMA channel is enabled.
349:                 	 * 					If waiting for the transfer completion needed (user doesn't use an ISR to catch
350:                 	 * 					this event) the function will periodically query the DMA controller for the
351:                 	 * 					transfer completion status.
352:                      * 					If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
353:                      * 					the block transfer than the function will re-force the transfer for each cell.
354:                 	 *
355:                 	 * Note:            This function can not ne used when the DMA channel is triggerred
356:                      *                  by hardware interrupt requests.
357:                      *                  This is because the transfers are software forced, theere is no
358:                      *                  wait for the occurrence of the hardware trigger. 
359:                 	 *
360:                 	 * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
361:                 	 ********************************************************************/
362:                 	 DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
363:                 
364:                 	/*********************************************************************
365:                 	 * Function:        void DmaChnForceTxfer(DmaChannel chn)
366:                 	 *
367:                 	 * PreCondition:    chn	- valid DMA channel
368:                 	 *
369:                 	 * Input:			chn		- DMA channel number
370:                 	 *
371:                 	 * Output:          None
372:                 	 *
373:                 	 * Side Effects:    None
374:                 	 *
375:                 	 * Overview:		The function forces a DMA transfer to occur for the selected DMA channel.
376:                 	 *
377:                 	 * Note:            None.
378:                 	 *
379:                 	 * Example:			DmaChnForceTxfer(DMA_CHANNEL2);
380:                 	 ********************************************************************/
381:                 	 void			DmaChnForceTxfer(DmaChannel chn);
382:                 
383:                 	/*********************************************************************
384:                 	 * Function:        void DmaChnAbortTxfer(DmaChannel chn)
385:                 	 *
386:                 	 * PreCondition:    chn	- valid DMA channel
387:                 	 *
388:                 	 * Input:			chn		- DMA channel number
389:                 	 *
390:                 	 * Output:          None
391:                 	 *
392:                 	 * Side Effects:    None
393:                 	 *
394:                 	 * Overview:		The function aborts a current undergoing DMA transfer for the selected DMA channel.
395:                 	 *
396:                 	 * Note:            None.
397:                 	 *
398:                 	 * Example:			DmaChnAbortTxfer(DMA_CHANNEL2);
399:                 	 ********************************************************************/
400:                 	 void			DmaChnAbortTxfer(DmaChannel chn);
401:                 
402:                 	// High level channel event and interrupt control functions
403:                 
404:                 	/*********************************************************************
405:                 	 * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
406:                 	 *
407:                 	 * PreCondition:    chn	- valid DMA channel
408:                 	 *
409:                 	 * Input:			chn		- DMA channel number
410:                 	 * 					eFlags	- event flags with the following significance:
411:                 	 * 								- DMA_EV_ERR: address error event
412:                 	 * 								- DMA_EV_ABORT: transfer abort event
413:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
414:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
415:                 	 * 								- DMA_EV_DST_HALF: destination half event
416:                 	 * 								- DMA_EV_DST_FULL: destination full event
417:                 	 * 								- DMA_EV_SRC_HALF: source half event
418:                 	 * 								- DMA_EV_SRC_FULL: source full event
419:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
420:                 	 *
421:                 	 * Output:          None
422:                 	 *
423:                 	 * Side Effects:    None
424:                 	 *
425:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
426:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
427:                 	 * 					enabled for the selected channel, the other channel event flags won't be touched.
428:                 	 *
429:                 	 * Note:            None.
430:                 	 *
431:                 	 * Example:			DmaChnSetEvEnableFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
432:                 	 ********************************************************************/
433:                 	 void			DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
434:                 
435:                 	/*********************************************************************
436:                 	 * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
437:                 	 *
438:                 	 * PreCondition:    chn	- valid DMA channel
439:                 	 *
440:                 	 * Input:			chn		- DMA channel number
441:                 	 * 					eFlags	- event flags with the following significance:
442:                 	 * 								- DMA_EV_ERR: address error event
443:                 	 * 								- DMA_EV_ABORT: transfer abort event
444:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
445:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
446:                 	 * 								- DMA_EV_DST_HALF: destination half event
447:                 	 * 								- DMA_EV_DST_FULL: destination full event
448:                 	 * 								- DMA_EV_SRC_HALF: source half event
449:                 	 * 								- DMA_EV_SRC_FULL: source full event
450:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
451:                 	 *
452:                 	 * Output:          None
453:                 	 *
454:                 	 * Side Effects:    None
455:                 	 *
456:                 	 * Overview:		The function clears the event enable flags for the selected DMA channel.
457:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
458:                 	 * 					disabled for the selected channel, the other channel event flags won't be touched.
459:                 	 *
460:                 	 * Note:            None.
461:                 	 *
462:                 	 * Example:			DmaChnClrEvEnableFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
463:                 	 ********************************************************************/
464:                 	 void			DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
465:                 
466:                 	/*********************************************************************
467:                 	 * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
468:                 	 *
469:                 	 * PreCondition:    chn	- valid DMA channel
470:                 	 *
471:                 	 * Input:			chn		- DMA channel number
472:                 	 * 					eFlags	- event flags with the following significance:
473:                 	 * 								- DMA_EV_ERR: address error event
474:                 	 * 								- DMA_EV_ABORT: transfer abort event
475:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
476:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
477:                 	 * 								- DMA_EV_DST_HALF: destination half event
478:                 	 * 								- DMA_EV_DST_FULL: destination full event
479:                 	 * 								- DMA_EV_SRC_HALF: source half event
480:                 	 * 								- DMA_EV_SRC_FULL: source full event
481:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
482:                 	 *
483:                 	 * Output:          None
484:                 	 *
485:                 	 * Side Effects:    None
486:                 	 *
487:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
488:                 	 * 					The channel event flags are forced to the eFlags value.
489:                 	 *
490:                 	 * Note:            None.
491:                 	 *
492:                 	 * Example:			DmaChnWriteEvEnableFlags(DMA_CHANNEL2, DMA_EV_ALL_EVNTS);
493:                 	 ********************************************************************/
494:                 	 void			DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
495:                 
496:                 	/*********************************************************************
497:                 	 * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
498:                 	 *
499:                 	 * PreCondition:    chn	- valid DMA channel
500:                 	 *
501:                 	 * Input:			chn		- DMA channel number
502:                 	 *
503:                 	 * Output:          - event flags with the following significance:
504:                 	 * 						- DMA_EV_ERR: address error event
505:                 	 * 						- DMA_EV_ABORT: transfer abort event
506:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
507:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
508:                 	 * 						- DMA_EV_DST_HALF: destination half event
509:                 	 * 						- DMA_EV_DST_FULL: destination full event
510:                 	 * 						- DMA_EV_SRC_HALF: source half event
511:                 	 * 						- DMA_EV_SRC_FULL: source full event
512:                 	 *						- DMA_EV_ALL_EVNTS: all of the above flags
513:                 	 *
514:                 	 * Side Effects:    None
515:                 	 *
516:                 	 * Overview:		The function returns the event enabled flags for the selected DMA channel.
517:                 	 *
518:                 	 * Note:            None.
519:                 	 *
520:                 	 * Example:			DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL2);
521:                 	 ********************************************************************/
522:                 	 DmaEvFlags	DmaChnGetEvEnableFlags(DmaChannel chn);
523:                 
524:                 	/*********************************************************************
525:                 	 * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
526:                 	 *
527:                 	 * PreCondition:    chn	- valid DMA channel
528:                 	 *
529:                 	 * Input:			chn		- DMA channel number
530:                 	 * 					eFlags	- event flags with the following significance:
531:                 	 * 								- DMA_EV_ERR: address error event
532:                 	 * 								- DMA_EV_ABORT: transfer abort event
533:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
534:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
535:                 	 * 								- DMA_EV_DST_HALF: destination half event
536:                 	 * 								- DMA_EV_DST_FULL: destination full event
537:                 	 * 								- DMA_EV_SRC_HALF: source half event
538:                 	 * 								- DMA_EV_SRC_FULL: source full event
539:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
540:                 	 *
541:                 	 * Output:          None
542:                 	 *
543:                 	 * Side Effects:    None
544:                 	 *
545:                 	 * Overview:		The function clears the event flags for the selected DMA channel.
546:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
547:                 	 * 					cleared for the selected channel, the other channel event flags won't be touched.
548:                 	 *
549:                 	 * Note:            None.
550:                 	 *
551:                 	 * Example:			DmaChnClrEvFlags(DMA_CHANNEL2, DMA_EV_ALL_EVNTS);
552:                 	 ********************************************************************/
553:                 	 void			DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
554:                 
555:                 	/*********************************************************************
556:                 	 * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
557:                 	 *
558:                 	 * PreCondition:    chn	- valid DMA channel
559:                 	 *
560:                 	 * Input:			chn		- DMA channel number
561:                 	 *
562:                 	 * Output:          event flags with the following significance:
563:                 	 * 						- DMA_EV_ERR: address error event
564:                 	 * 						- DMA_EV_ABORT: transfer abort event
565:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
566:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
567:                 	 * 						- DMA_EV_DST_HALF: destination half event
568:                 	 * 						- DMA_EV_DST_FULL: destination full event
569:                 	 * 						- DMA_EV_SRC_HALF: source half event
570:                 	 * 						- DMA_EV_SRC_FULL: source full event
571:                 	 * 						- DMA_EV_ALL_EVNTS: all of the above flags
572:                 	 *
573:                 	 * Side Effects:    None
574:                 	 *
575:                 	 * Overview:		The function returns the event flags for the selected DMA channel.
576:                 	 *
577:                 	 * Note:            None.
578:                 	 *
579:                 	 * Example:			DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL2);
580:                 	 ********************************************************************/
581:                 	 DmaEvFlags	DmaChnGetEvFlags(DmaChannel chn);
582:                 
583:                 
584:                 	// high level helpers for fast strcpy/memcpy transfers
585:                 
586:                 	/*********************************************************************
587:                 	 * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
588:                 	 *
589:                 	 * PreCondition:    chn		- a valid DMA channel
590:                 	 * 					s1, s2	- valid memory pointers
591:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
592:                 	 *
593:                 	 * Input:			s1		- destination pointer
594:                 	 * 					s2		- source pointer
595:                 	 * 					n		- number of bytes to transfer
596:                 	 * 					chn		- the DMA channel to perform the transfer
597:                 	 * 					chPri	- the desired channel priority
598:                 	 *
599:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
600:                 	 * 					an DmaTxferRes error code  otherwise
601:                 	 *
602:                 	 * Side Effects:    None
603:                 	 *
604:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
605:                 	 * 			Then it copies one block of memory from source to destination.
606:                 	 *
607:                 	 *
608:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
609:                 	 * 						This way, the transfer will occur correctly together with CRC calculation.
610:                 	 * 					- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
611:                 	 * 					- Multiple channels could be opened to perform fast memory transfers, if necessary.
612:                 	 * 					- The function clears the suspend state and resumes the operation of the DMA controller.
613:                 	 *
614:                  	 * Example:		res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL2, DMA_CHN_PRI3);
615:                  	 ********************************************************************/
616:                 	 DmaTxferRes	DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
617:                 
618:                 	/*********************************************************************
619:                 	 * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
620:                 	 *
621:                 	 * PreCondition:    chn		- a valid DMA channel
622:                 	 * 					s1, s2	- valid memory pointers
623:                 	 *
624:                 	 * Input:			s1		- destination pointer
625:                 	 * 					s2		- source pointer
626:                 	 * 					chn		- the DMA channel to perform the transfer
627:                 	 * 					chPri	- the desired channel priority
628:                 	 *
629:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
630:                 	 * 					an DmaTxferRes error code  otherwise
631:                 	 *
632:                 	 * Side Effects:    None
633:                 	 *
634:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
635:                 	 * 			Then it copies one zero terminated string from source to destination.
636:                 	 *
637:                 	 *
638:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
639:                 	 *				This way, the transfer will occur correctly together with CRC calculation.
640:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
641:                 	 *			- Multiple channels could be opened to perform fast memory transfers, if necessary.
642:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
643:                 	 *
644:                 	 *
645:                  	 * Example:		res=DmaChnStrcpy(str1, str2, DMA_CHANNEL2, DMA_CHN_PRI3);
646:                 	 *********************************************************************/
647:                 	 DmaTxferRes	DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
648:                 
649:                 	/*********************************************************************
650:                 	 * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
651:                 	 *
652:                 	 * PreCondition:    chn		- a valid DMA channel
653:                 	 * 				- s1, s2	- valid memory pointers
654:                 	 *                              - 0 < n <= DmaGetMaxTxferSize()
655:                 	 *
656:                 	 * Input:			s1		- destination pointer
657:                 	 * 					s2		- source pointer
658:                 	 * 					n	- max number of bytes to transfer
659:                 	 * 					chn		- the DMA channel to perform the transfer
660:                 	 * 					chPri	- the desired channel priority
661:                 	 *
662:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
663:                 	 * 					an DmaTxferRes error code  otherwise
664:                 	 *
665:                 	 * Side Effects:    None
666:                 	 *
667:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
668:                 	 * 			Then it copies one zero terminated string from source to destination.
669:                 	 * 			It copies no more than n characters from s2.
670:                 	 *
671:                 	 *
672:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
673:                 	 *				This way, the transfer will occur correctly together with CRC calculation.
674:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
675:                 	 *			- Multiple channels could be opened to perform fast memory transfers, if necessary.
676:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
677:                 	 *
678:                 	 *
679:                  	 * Example:		res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL2, DMA_CHN_PRI3);
680:                 	 ********************************************************************/
681:                 	 DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
682:                 
683:                 	/*********************************************************************
684:                 	 * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
685:                 	 *
686:                 	 * PreCondition:    chn		- a valid DMA channel
687:                 	 * 					d, s		- valid memory pointer
688:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
689:                 	 *
690:                 	 * Input:			d		- address where to deposit the result
691:                 	 * 					s		- source buffer pointer
692:                 	 * 					n		- number of bytes in the pointer
693:                 	 * 					chn		- the DMA channel to use
694:                 	 * 					chPri	- the desired channel priority
695:                 	 *
696:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
697:                 	 * 					an DmaTxferRes error code  otherwise
698:                 	 *
699:                 	 * Side Effects:    None
700:                 	 *
701:                 	 * Overview:		The function is a helper that calculates the CRC of a memory block.
702:                 	 * 			The function configures the DMA channel for a fast memory transfer and calculates the CRC.
703:                 	 *
704:                 	 *
705:                 	 * Note:            - The CRC generator must have been previously configured using mCrcConfigure()
706:                 	 * 					- No transfer is done, just the CRC is calculated.
707:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
708:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
709:                 	 *
710:                 	 * Example:		int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
711:                 	 ********************************************************************/
712:                 	 DmaTxferRes	DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
713:                 
714:                 
715:                 	// High level CRC functions
716:                 
717:                 	/*********************************************************************
718:                 	 * Function:        void DmaCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
719:                 	 *
720:                 	 * PreCondition:    pLen		- valid polynomial length within 1-16
721:                 	 *
722:                 	 * Input:			polynomial	- the layout of the CRC generator
723:                 	 * 					pLen		- the length of the CRC generator polynomial
724:                 	 * 					seed		- the initial seed of the CRC generator
725:                 	 *
726:                 	 * Output:          None
727:                 	 *
728:                 	 * Side Effects:    None
729:                 	 *
730:                 	 * Overview:		The function configures the CRC module by setting the parameters that define the generator polynomial:
731:                 	 * 					- the length of the CRC generator polynomial, pLen;
732:                 	 * 					- the function sets the layout of the shift stages that take place in the CRC generation.
733:                 	 * 						Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
734:                 	 * 						If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
735:                 	 * 						Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
736:                 	 * 						are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
737:                 	 * 						feedback should be 0x8005, or 0x8004, but not 0x018005;
738:                 	 *					- the function sets the seed of the CRC generator. This is the initial data present in the
739:                 	 * 						CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
740:                 	 *
741:                 	 * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
742:                 	 * 					- When the append mode is set, the attached DMA channel has to have destination size <=4.
743:                 	 * 						Upon the transfer completion the calculated CRC is stored at the destination address.
744:                 	 * 					- When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
745:                 	 * 						the CrcResult() function.
746:                 	 * 					- The CRC module should be configured before enabled.
747:                 	 *
748:                 	 * Example:			DmaCrcConfigure(0x8005, 16, 0xffff);
749:                 	 ********************************************************************/
750:                 	extern __inline__ void __attribute__((always_inline)) DmaCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
751:                 	{
752:                 		DCRCCONCLR=_DCRCCON_PLEN_MASK;
753:                 		DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
754:                 		DCRCDATA=seed;
755:                 		DCRCXOR=polynomial;
756:                 	}
757:                 
758:                 	/*********************************************************************
759:                 	 * Function:        void CrcAttachChannel(DmaChannel chn, int appendMode)
760:                 	 *
761:                 	 * PreCondition:    chn		- valid DMA channel
762:                 	 *
763:                 	 * Input:			chn			- the DMA channel to be attached to the CRC generator module.
764:                 	 * 					appendMode	- if TRUE the data passed to the CRC generator is not transferred to destination
765:                 	 * 									but it's written to the destination address when the block transfer is complete.
766:                 	 * 								- if FALSE the data is transferred normally while the CRC is calculated. The CRC will
767:                 	 * 									be available using the CrcResult function.
768:                 	 *
769:                 	 * Output:          None
770:                 	 *
771:                 	 * Side Effects:    None
772:                 	 *
773:                 	 * Overview:		The function attaches the CRC module to an DMA channel and enables the CRC generator.
774:                 	 * 					From now on, all the DMA traffic is directed to the CRC generator. Once the DMA block transfer
775:                 	 * 					is complete, the CRC result is available both at the DMA destination address and in the CRC data register.
776:                 	 *
777:                 	 * Note:            None
778:                 	 *
779:                 	 * Example:			CrcAttachChannel(0, TRUE);
780:                 	 ********************************************************************/
781:                 	 void			CrcAttachChannel(DmaChannel chn, int appendMode);
782:                 
783:                 	/*********************************************************************
784:                 	 * Function:        unsigned int CrcResult(void)
785:                 	 *
786:                 	 * PreCondition:    None
787:                 	 *
788:                 	 * Input:			None
789:                 	 *
790:                 	 * Output:          the current value of the CRC generator.
791:                 	 *
792:                 	 * Side Effects:    None
793:                 	 *
794:                 	 * Overview:		The function returns the calculated CRC value.
795:                 	 *
796:                 	 * Note:            The function returns the valid CRC result by masking out the unused MSbits in the CRC register.
797:                 	 * 					Use CrcGetValue() to get the full CRC register value.
798:                 	 *
799:                 	 * Example:			int myCrc=CrcResult();
800:                 	 ********************************************************************/
801:                 	 unsigned int		CrcResult(void);
802:                 
803:                 
804:                 /*********************  end of high level functions ****************************************/
805:                 
806:                 	// low level definitions for the API functions
807:                 
808:                 
809:                 	typedef struct
810:                 	{
811:                 		union
812:                 		{
813:                 			struct
814:                 			{
815:                 				unsigned int chn:	3;		// last active DMA channel
816:                 				unsigned int rdOp:	1;		// last DMA operation, read if 1, write if 0
817:                 			};
818:                 			unsigned int	w;						// word access
819:                 		}lastAccess;
820:                 		void*	lastAddress;		// most recent DMA address
821:                 	}DmaStatus;			// DMA controller status
822:                 #if(defined(__32MX330F064H__)||\
823:                     defined(__32MX330F064L__)||\
824:                     defined(__32MX350F128H__)||\
825:                     defined(__32MX350F128L__)||\
826:                     defined(__32MX350F256H__)||\
827:                     defined(__32MX350F256L__)||\
828:                 	defined(__32MX370F512H__)||\
829:                 	defined(__32MX370F512L__)||\
830:                     defined(__32MX430F064H__)||\
831:                     defined(__32MX430F064L__)||\
832:                     defined(__32MX450F128H__)||\
833:                     defined(__32MX450F128L__)||\
834:                     defined(__32MX450F256H__)||\
835:                     defined(__32MX450F256L__)||\
836:                 	defined(__32MX470F512L__)||\
837:                 	defined(__32MX470F512L__))
838:                 typedef enum
839:                 	{
840:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
841:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
842:                 		//
843:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_ON		// all flags
844:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
845:                 #else
846:                 	typedef enum
847:                 	{
848:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
849:                 		DMA_GFLG_SIDL =		_DMACON_SIDL_MASK,		// DMA controller sleep/active in idle mode
850:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
851:                 		//
852:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_SIDL|DMA_GFLG_ON		// all flags
853:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
854:                 
855:                 #endif
856:                 
857:                 
858:                 	typedef enum
859:                 	{
860:                 		DMA_EV_ABORT_IRQ_EN =		_DCH0ECON_AIRQEN_MASK,
861:                 		DMA_EV_START_IRQ_EN =		_DCH0ECON_SIRQEN_MASK,
862:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
863:                         // the start and abort IRQ signals
864:                 		DMA_EV_MATCH_EN =			_DCH0ECON_PATEN_MASK,
865:                 
866:                 
867:                         // compiler use only field
868:                         _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
869:                 	}DmaEvCtrlFlags;	// DMA channel event control fields accessibile as flags
870:                 	// also part of DmaEvCtrlFlags:
871:                 	#define	DMA_EV_START_IRQ(irq)	(DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
872:                 	#define	DMA_EV_ABORT_IRQ(irq)	(DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
873:                 
874:                 	// DMA channel event control as a structure:
875:                 	#define	DmaEvCtrl	__DCH0ECONbits_t
876:                 
877:                 
878:                 
879:                 
880:                 	typedef enum
881:                 	{
882:                 		DMA_CTL_AUTO_EN =		_DCH0CON_CHAEN_MASK,
883:                 		DMA_CTL_CHAIN_EN =		_DCH0CON_CHCHN_MASK,
884:                 		DMA_CTL_DET_EN =		_DCH0CON_CHAED_MASK,
885:                 		DMA_CTL_CHN_EN =		_DCH0CON_CHEN_MASK,
886:                 		DMA_CTL_CHAIN_DIR =		_DCH0CON_CHCHNS_MASK,
887:                         // use the DMA_CTL_PRI() below for selecting the DMA
888:                         // channel priority
889:                 	}DmaChnCtrlFlags;	// controlling the DMA channel with flags
890:                 	// also part of DmaChnCtrlFlags:
891:                 	#define	DMA_CTL_PRI(pri)	((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
892:                 
893:                 	// DMA channel control as a structure:
894:                 	#define	DmaChnCtrl  	__DCH0CONbits_t
895:                 
896:                 	typedef struct
897:                 	{
898:                 		void*	vSrcAdd;		// source of the DMA transfer, virtual
899:                 		void*	vDstAdd;		// destination of the DMA transfer, virtual
900:                 		int	srcSize;		// source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
901:                 		int	dstSize;		// destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
902:                 		int	cellSize;		// no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
903:                 	}DmaTxferCtrl;		// transfer setting: the transfer source, destination addresses and size, cell size
904:                 
905:                 
906:                 	/********************** low level DMA channel functions *******************************/
907:                 
908:                 
909:                 
910:                 	// Global DMA controller functions
911:                 
912:                 
913:                 	/*********************************************************************
914:                 	 * Function:        void DmaEnable(int enable)
915:                 	 *
916:                 	 * PreCondition:    None
917:                 	 *
918:                 	 * Input:           enable - boolean to enable/disable the DMA controller
919:                 	 *
920:                 	 * Output:          None
921:                 	 *
922:                 	 * Side Effects:    None
923:                 	 *
924:                 	 * Overview:       The function enables/disables the DMA controller.
925:                 	 *
926:                 	 * Note:           None.
927:                 	 *
928:                 	 * Example:        DmaEnable(1);
929:                 	 ********************************************************************/
930:                 	extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
931:                 	{
932:                 		if(enable)
933:                 		{
934:                 			DMACONSET=_DMACON_ON_MASK;
935:                 		}
936:                 		else
937:                 		{
938:                 			DMACONCLR=_DMACON_ON_MASK;
939:                 			while(DMACONbits.ON);		// wait to take effect
940:                 		}
941:                 	}
942:                 
943:                 	/*********************************************************************
944:                 	 * Function:        void DmaReset(void)
945:                 	 *
946:                 	 * PreCondition:    None
947:                 	 *
948:                 	 * Input:		None
949:                 	 *
950:                 	 * Output:          None
951:                 	 *
952:                 	 * Side Effects:    None
953:                 	 *
954:                 	 * Overview:        The function resets the DMA controller.
955:                 	 *
956:                 	 * Note:            None.
957:                 	 *
958:                 	 * Example:        DmaReset();
959:                 	 ********************************************************************/
960:                 	#define            DmaReset()	DmaEnable(0)
961:                 
962:                 	/*********************************************************************
963:                 	 * Function:        int DmaSuspend(void)
964:                 	 *
965:                 	 * PreCondition:    None
966:                 	 *
967:                 	 * Input:		None
968:                 	 *
969:                 	 * Output:          true if the DMA was previously suspended, false otherwise
970:                 	 *
971:                 	 *
972:                 	 * Side Effects:    None
973:                 	 *
974:                 	 * Overview:        The function suspends the DMA controller.
975:                 	 *
976:                 	 * Note:            After the execution of this function the DMA operation is supposed to be suspended.
977:                 	 *                  I.e. the function has to wait for the suspension to take place!
978:                 	 *
979:                 	 * Example:			int susp=DmaSuspend();
980:                 	 ********************************************************************/
981:                     extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
982:                 	{
983:                 		int suspSt;
984:                 		if(!(suspSt=DMACONbits.SUSPEND))
9D004748  3C02BF88   LUI V0, -16504
9D00474C  8C423000   LW V0, 12288(V0)
9D004750  7C420300   EXT V0, V0, 12, 1
9D004754  304200FF   ANDI V0, V0, 255
9D004758  AFC20040   SW V0, 64(S8)
9D00475C  8FC20040   LW V0, 64(S8)
9D004760  14400009   BNE V0, ZERO, 0x9D004788
9D004764  00000000   NOP
9D00481C  3C02BF88   LUI V0, -16504
9D004820  8C423000   LW V0, 12288(V0)
9D004824  7C420300   EXT V0, V0, 12, 1
9D004828  304200FF   ANDI V0, V0, 255
9D00482C  AFC2004C   SW V0, 76(S8)
9D004830  8FC2004C   LW V0, 76(S8)
9D004834  14400010   BNE V0, ZERO, 0x9D004878
9D004838  00000000   NOP
9D004FDC  3C02BF88   LUI V0, -16504
9D004FE0  8C423000   LW V0, 12288(V0)
9D004FE4  7C420300   EXT V0, V0, 12, 1
9D004FE8  304200FF   ANDI V0, V0, 255
9D004FEC  AFC20018   SW V0, 24(S8)
9D004FF0  8FC20018   LW V0, 24(S8)
9D004FF4  14400009   BNE V0, ZERO, 0x9D00501C
9D004FF8  00000000   NOP
9D0050A4  3C02BF88   LUI V0, -16504
9D0050A8  8C423000   LW V0, 12288(V0)
9D0050AC  7C420300   EXT V0, V0, 12, 1
9D0050B0  304200FF   ANDI V0, V0, 255
9D0050B4  AFC20020   SW V0, 32(S8)
9D0050B8  8FC20020   LW V0, 32(S8)
9D0050BC  14400010   BNE V0, ZERO, 0x9D005100
9D0050C0  00000000   NOP
985:                 		{
986:                 			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
9D004768  3C02BF88   LUI V0, -16504
9D00476C  24031000   ADDIU V1, ZERO, 4096
9D004770  AC433008   SW V1, 12296(V0)
9D00483C  3C02BF88   LUI V0, -16504
9D004840  24031000   ADDIU V1, ZERO, 4096
9D004844  AC433008   SW V1, 12296(V0)
9D004FFC  3C02BF88   LUI V0, -16504
9D005000  24031000   ADDIU V1, ZERO, 4096
9D005004  AC433008   SW V1, 12296(V0)
9D0050C4  3C02BF88   LUI V0, -16504
9D0050C8  24031000   ADDIU V1, ZERO, 4096
9D0050CC  AC433008   SW V1, 12296(V0)
987:                 			while(!(DMACONbits.SUSPEND));	// wait to be actually suspended
9D004774  3C02BF88   LUI V0, -16504
9D004778  8C423000   LW V0, 12288(V0)
9D00477C  30421000   ANDI V0, V0, 4096
9D004780  1040FFFC   BEQ V0, ZERO, 0x9D004774
9D004784  00000000   NOP
9D004848  3C02BF88   LUI V0, -16504
9D00484C  8C423000   LW V0, 12288(V0)
9D004850  30421000   ANDI V0, V0, 4096
9D004854  1040FFFC   BEQ V0, ZERO, 0x9D004848
9D004858  00000000   NOP
9D005008  3C02BF88   LUI V0, -16504
9D00500C  8C423000   LW V0, 12288(V0)
9D005010  30421000   ANDI V0, V0, 4096
9D005014  1040FFFC   BEQ V0, ZERO, 0x9D005008
9D005018  00000000   NOP
9D0050D0  3C02BF88   LUI V0, -16504
9D0050D4  8C423000   LW V0, 12288(V0)
9D0050D8  30421000   ANDI V0, V0, 4096
9D0050DC  1040FFFC   BEQ V0, ZERO, 0x9D0050D0
9D0050E0  00000000   NOP
988:                 		}
989:                 		return suspSt;
9D004788  8FC20040   LW V0, 64(S8)
9D00485C  0B40121F   J 0x9D00487C
9D004860  00000000   NOP
9D004878  00000000   NOP
9D00501C  8FC20018   LW V0, 24(S8)
9D0050E4  0B401441   J 0x9D005104
9D0050E8  00000000   NOP
9D005100  00000000   NOP
990:                 	}
991:                 
992:                 
993:                 
994:                 	/*********************************************************************
995:                 	 * Function:        void DmaResume(int susp)
996:                 	 *
997:                 	 * PreCondition:    None
998:                 	 *
999:                 	 * Input:		the desired DMA suspended state.
1000:                	 *
1001:                	 * Output:          None
1002:                	 *
1003:                	 * Side Effects:    None
1004:                	 *
1005:                	 * Overview:		The function restores the DMA controller activity to the old suspended mode.
1006:                	 *
1007:                	 * Note:            None.
1008:                	 *
1009:                	 * Example:			int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1010:                	 ********************************************************************/
1011:                    extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1012:                	{
1013:                		if(susp)
9D004810  8FC20048   LW V0, 72(S8)
9D004814  10400013   BEQ V0, ZERO, 0x9D004864
9D004818  00000000   NOP
9D005098  8FC2001C   LW V0, 28(S8)
9D00509C  10400013   BEQ V0, ZERO, 0x9D0050EC
9D0050A0  00000000   NOP
1014:                		{
1015:                			DmaSuspend();
1016:                		}
1017:                		else
1018:                		{
1019:                			DMACONCLR=_DMACON_SUSPEND_MASK;		// resume DMA activity
9D004864  3C02BF88   LUI V0, -16504
9D004868  24031000   ADDIU V1, ZERO, 4096
9D00486C  AC433004   SW V1, 12292(V0)
9D004870  0B40121F   J 0x9D00487C
9D004874  00000000   NOP
9D0050EC  3C02BF88   LUI V0, -16504
9D0050F0  24031000   ADDIU V1, ZERO, 4096
9D0050F4  AC433004   SW V1, 12292(V0)
9D0050F8  0B401441   J 0x9D005104
9D0050FC  00000000   NOP
1020:                		}
1021:                	}
1022:                
1023:                	/*********************************************************************
1024:                	 * Function:        void DmaGetStatus(DmaStatus* pStat)
1025:                	 *
1026:                	 * PreCondition:    pStat	- valid pointer
1027:                	 *
1028:                	 * Input:			pStat	- pointer to a DmaStatus structure to store the current DMA controller
1029:                	 * 							status, carrying the following info:
1030:                	 * 								- chn:	the last active DMA channel
1031:                	 * 								- rdOp: the last DMA operation, read/write
1032:                	 * 								- lastAddress: the most recent DMA address
1033:                	 *
1034:                	 * Output:          None
1035:                	 *
1036:                	 * Side Effects:    None
1037:                	 *
1038:                	 * Overview:		The function updates the info for the current DMA controller status.
1039:                	 * 					It updates the last DMA: operation, channel used and address.
1040:                	 *
1041:                	 * Note:            None.
1042:                	 *
1043:                	 * Example:			DmaStatus stat; DmaGetStatus(&stat);
1044:                	 ********************************************************************/
1045:                	 void			DmaGetStatus(DmaStatus* pStat);
1046:                
1047:                	/*********************************************************************
1048:                	 * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1049:                	 *
1050:                	 * PreCondition:    None
1051:                	 *
1052:                	 * Input:			gFlags	- flags to be set, having the following fields:
1053:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1054:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1055:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1056:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1057:                	 *
1058:                	 * Output:          None
1059:                	 *
1060:                	 * Side Effects:    None
1061:                	 *
1062:                	 * Overview:		The function affects the global behavior of the DMA controller.
1063:                	 * 					It sets the specified flags. Any flag that is set in the gFlags will be
1064:                	 * 					enabled, the other flags won't be touched.
1065:                	 *
1066:                	 * Note:            None.
1067:                	 *
1068:                	 * Example:			DmaSetGlobalFlags(DMA_GFLG_SIDL|DMA_GFLG_ON);
1069:                	 ********************************************************************/
1070:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1071:                	{
1072:                		DMACONSET=gFlags;
1073:                	}
1074:                
1075:                	/*********************************************************************
1076:                	 * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1077:                	 *
1078:                	 * PreCondition:    None
1079:                	 *
1080:                	 * Input:			gFlags	- flags to be cleared, having the following fields:
1081:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1082:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1083:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1084:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1085:                	 *
1086:                	 * Output:          None
1087:                	 *
1088:                	 * Side Effects:    None
1089:                	 *
1090:                	 * Overview:		The function affects the global behavior of the DMA controller.
1091:                	 * 					It clears the specified flags. Any flag that is set in the gFlags will be
1092:                	 * 					cleared, the other flags won't be touched.
1093:                	 *
1094:                	 * Note:            None.
1095:                	 *
1096:                	 * Example:			DmaClrGlobalFlags(DMA_GFLG_SUSPEND|DMA_GFLG_SIDL);
1097:                	 ********************************************************************/
1098:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1099:                	{
1100:                		DMACONCLR=gFlags;
1101:                	}
1102:                
1103:                
1104:                	/*********************************************************************
1105:                	 * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1106:                	 *
1107:                	 * PreCondition:    None
1108:                	 *
1109:                	 * Input:			gFlags	- flags to be set, having the following fields:
1110:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1111:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1112:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1113:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1114:                	 *
1115:                	 * Output:          None
1116:                	 *
1117:                	 * Side Effects:    None
1118:                	 *
1119:                	 * Overview:		The function affects the global behavior of the DMA controller.
1120:                	 * 					It forces the flags to have the specified gFlags value.
1121:                	 *
1122:                	 * Note:            None.
1123:                	 *
1124:                	 * Example:			DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1125:                	 ********************************************************************/
1126:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1127:                	{
1128:                		DMACON=gFlags;
1129:                	}
1130:                
1131:                	/*********************************************************************
1132:                	 * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1133:                	 *
1134:                	 * PreCondition:    None
1135:                	 *
1136:                	 * Input:			None
1137:                	 *
1138:                	 * Output:          The current DMA controller flags settings.
1139:                	 * 						- DMA_GFLG_SUSPEND: DMA controller operation suspend
1140:                	 * 						- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1141:                	 * 						- DMA_GFLG_ON: DMA controller enabled/desabled
1142:                	 *
1143:                	 * Side Effects:    None
1144:                	 *
1145:                	 * Overview:		The function returns the global flags of the DMA controller.
1146:                	 *
1147:                	 * Note:            None.
1148:                	 *
1149:                	 * Example:			DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1150:                	 ********************************************************************/
1151:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1152:                	{
1153:                		return (DmaGlblFlags)DMACON;
1154:                	}
1155:                
1156:                
1157:                	/*********************************************************************
1158:                	 * Function:        int DmaGetMaxTxferSize(void)
1159:                	 *
1160:                	 * PreCondition:    None
1161:                	 *
1162:                	 * Input:           None
1163:                	 *
1164:                	 * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1165:                	 *
1166:                	 * Side Effects:    None
1167:                	 *
1168:                	 * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1169:                	 *
1170:                	 * Note:            Revision dependant.
1171:                	 *
1172:                	 * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1173:                	 ********************************************************************/
1174:                	extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1175:                	{
1176:                		return 256;
1177:                	}
1178:                
1179:                
1180:                	// Direct Channel control functions
1181:                
1182:                	typedef enum
1183:                	{
1184:                		DMA_CONFIG_DEFAULT = 0,							        // DMA default operation
1185:                		DMA_CONFIG_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
1186:                		DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
1187:                		DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),			// DMA channel is chained to higher channel
1188:                		DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,				// events detection enabled while channel off
1189:                		DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
1190:                		DMA_CONFIG_MATCH	= 0x80000000,						// DMA channel stops on match
1191:                	}DmaConfigFlags;	// flags for the channel configuration
1192:                
1193:                	/*********************************************************************
1194:                	 * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1195:                	 *
1196:                	 * PreCondition:    chPri  - valid channel priority, 0-3
1197:                	 *
1198:                	 * Input:           chn    - channel to be configured in the DMA controller
1199:                	 *                  chPri  - the priority given to the channel, 0-3
1200:                	 *                  cFlags - orred flags specifying the configuration:
1201:                	 *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1202:                	 *                           DMA_CONFIG_AUTO:	DMA channel is auto enabled
1203:                	 *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1204:                	 *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1205:                	 *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1206:                	 *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1207:                	 *                           DMA_CONFIG_MATCH:	DMA channel stops on match
1208:                	 *
1209:                	 *
1210:                	 *
1211:                	 * Output:          None
1212:                	 *
1213:                	 * Side Effects:    None
1214:                	 *
1215:                	 * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1216:                	 *
1217:                	 * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1218:                	 *                  The channel is just configured.
1219:                	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1220:                	 *                  if DMA_CONFIG_ENABLE flag was not specified.
1221:                	 *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1222:                	 *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1223:                	 *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1224:                	 *                  User has to call event channel functions to clear/enable the event flags if needed.
1225:                	 *
1226:                	 * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1227:                	 ********************************************************************/
1228:                	void			DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1229:                
1230:                
1231:                	/*********************************************************************
1232:                	 * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1233:                	 *
1234:                	 * PreCondition:    chn	- valid DMA channel
1235:                	 *
1236:                	 * Input:			chn		- DMA channel number
1237:                	 *
1238:                	 * Output:          Current channel source pointer.
1239:                	 *
1240:                	 * Side Effects:    None
1241:                	 *
1242:                	 * Overview:		The function retrieves the current source pointer for the selected DMA channel.
1243:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1244:                	 *
1245:                	 * Note:            None
1246:                	 *
1247:                	 * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL2);
1248:                	 ********************************************************************/
1249:                	 int			DmaChnGetSrcPnt(DmaChannel chn);
1250:                
1251:                	/*********************************************************************
1252:                	 * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1253:                	 *
1254:                	 * PreCondition:    chn	- valid DMA channel
1255:                	 *
1256:                	 * Input:			chn		- DMA channel number
1257:                	 *
1258:                	 * Output:          Current channel destination pointer.
1259:                	 *
1260:                	 * Side Effects:    None
1261:                	 *
1262:                	 * Overview:		The function retrieves the current destination pointer for the selected DMA channel.
1263:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1264:                	 *
1265:                	 * Note:            None
1266:                	 *
1267:                	 * Example:			int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL2);
1268:                	 ********************************************************************/
1269:                	 int			DmaChnGetDstPnt(DmaChannel chn);
1270:                
1271:                	/*********************************************************************
1272:                	 * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1273:                	 *
1274:                	 * PreCondition:    chn	- valid DMA channel
1275:                	 *
1276:                	 * Input:			chn		- DMA channel number
1277:                	 *
1278:                	 * Output:          Current channel transfer pointer.
1279:                	 *
1280:                	 * Side Effects:    None
1281:                	 *
1282:                	 * Overview:		The function retrieves the current transfer progress pointer for the selected DMA channel.
1283:                	 * 					It ranges 0 to DmaGetMaxTxferSize()-1.
1284:                	 *
1285:                	 * Note:            None
1286:                	 *
1287:                	 * Example:			int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL2);
1288:                	 ********************************************************************/
1289:                	 int			DmaChnGetCellPnt(DmaChannel chn);
1290:                
1291:                
1292:                
1293:                	/*********************************************************************
1294:                	 * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1295:                	 *
1296:                	 * PreCondition:    chn	- valid DMA channel
1297:                	 *
1298:                	 * Input:			chn			- DMA channel number
1299:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1300:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1301:                	 * 										- SIRQEN: enable/disable the start IRQ action
1302:                	 * 										- PATEN: enable/disable the pattern match and abort
1303:                	 * 									or any of the DmaEvCtrlFlags:
1304:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1305:                	 *
1306:                	 *
1307:                	 * Output:          None
1308:                	 *
1309:                	 * Side Effects:    None
1310:                	 *
1311:                	 * Overview:		The function sets the events that start and abort the transfer
1312:                	 * 					for the selected DMA channel.
1313:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1314:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1315:                	 *
1316:                	 * Note:            None.
1317:                	 *
1318:                	 * Example:			either:
1319:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1320:                	 * 					or:
1321:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1322:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1323:                	 *
1324:                	 ********************************************************************/
1325:                	 void			DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1326:                
1327:                
1328:                	/*********************************************************************
1329:                	 * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1330:                	 *
1331:                	 * PreCondition:    chn	- valid DMA channel
1332:                	 *
1333:                	 * Input:			chn			- DMA channel number
1334:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1335:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1336:                	 * 										- SIRQEN: enable/disable the start IRQ action
1337:                	 * 										- PATEN: enable/disable the pattern match and abort
1338:                	 * 									or any of the DmaEvCtrlFlags:
1339:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1340:                	 *
1341:                	 *
1342:                	 * Output:          None
1343:                	 *
1344:                	 * Side Effects:    None
1345:                	 *
1346:                	 * Overview:		The function clears the events that start and abort the transfer
1347:                	 * 					for the selected DMA channel.
1348:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1349:                	 * 					disabled for the selected channel, the other channel event flags won't be touched.
1350:                	 *
1351:                	 * Note:            None.
1352:                	 *
1353:                	 * Example:			either:
1354:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1355:                	 * 					or:
1356:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1357:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1358:                	 *
1359:                	 ********************************************************************/
1360:                	 void			DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1361:                
1362:                
1363:                
1364:                	/*********************************************************************
1365:                	 * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1366:                	 *
1367:                	 * PreCondition:    chn	- valid DMA channel
1368:                	 *
1369:                	 * Input:			chn			- DMA channel number
1370:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1371:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1372:                	 * 										- SIRQEN: enable/disable the start IRQ action
1373:                	 * 										- PATEN: enable/disable the pattern match and abort
1374:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1375:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1376:                	 * 									or any of the DmaEvCtrlFlags:
1377:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1378:                	 *
1379:                	 *
1380:                	 * Output:          None
1381:                	 *
1382:                	 * Side Effects:    None
1383:                	 *
1384:                	 * Overview:		The function writes the events that start and abort the transfer
1385:                	 * 					for the selected DMA channel.
1386:                	 *
1387:                	 * Note:            None.
1388:                	 *
1389:                	 * Example:			either:
1390:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1391:                	 * 					or:
1392:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1393:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1394:                	 *
1395:                	 ********************************************************************/
1396:                	 void			DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1397:                
1398:                
1399:                
1400:                	/*********************************************************************
1401:                	 * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1402:                	 *
1403:                	 * PreCondition:    chn	- valid DMA channel
1404:                	 *
1405:                	 * Input:			chn			- DMA channel number
1406:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1407:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1408:                	 * 										- SIRQEN: enable/disable the start IRQ action
1409:                	 * 										- PATEN: enable/disable the pattern match and abort
1410:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1411:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1412:                	 * 									or any of the DmaEvCtrlFlags:
1413:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1414:                	 *
1415:                	 *
1416:                	 * Output:          None
1417:                	 *
1418:                	 * Side Effects:    None
1419:                	 *
1420:                	 * Overview:		The function sets the events that start and abort the transfer
1421:                	 * 					for the selected DMA channel.
1422:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1423:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1424:                	 *
1425:                	 * Note:           A shorter name for DmaChnWriteEventControlFlags();
1426:                	 *
1427:                	 * Example:			either:
1428:                	 * 						DmaChnSetEventControl(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1429:                	 * 					or:
1430:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1431:                	 * 						DmaChnSetEventControl(DMA_CHANNEL2, evCtrl.w);
1432:                	 *
1433:                	 ********************************************************************/
1434:                	#define			DmaChnSetEventControl(chn, dmaEvCtrl)	DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1435:                
1436:                
1437:                	/*********************************************************************
1438:                	 * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1439:                	 *
1440:                	 * PreCondition:    chn	- valid DMA channel
1441:                	 *
1442:                	 * Input:			chn		- DMA channel number
1443:                	 *
1444:                	 * Output:          - 	either a DmaEvCtrl structure field, carrying the following info:
1445:                	 * 							- AIRQEN: enable/disable the abort IRQ action
1446:                	 * 							- SIRQEN: enable/disable the start IRQ action
1447:                	 * 							- PATEN: enable/disable the pattern match and abort
1448:                	 * 							- CHSIRQ: IRQ number to start the DMA channel transfer
1449:                	 * 							- CHAIRQ: IRQ number to abort the DMA channel transfer
1450:                	 * 						or any of the DmaEvCtrlFlags:
1451:                	 * 							DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1452:                	 *
1453:                	 *
1454:                	 * Side Effects:    None
1455:                	 *
1456:                	 * Overview:		The function retrieves the events that start and abort the transfer
1457:                	 * 					for the selected DMA channel.
1458:                	 *
1459:                	 * Note:            None.
1460:                	 *
1461:                	 * Example:			either:
1462:                	 * 						DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL2); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1463:                	 * 					or:
1464:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL2); if(evCtrl.PATEN){...}
1465:                	 *
1466:                	 ********************************************************************/
1467:                	 DmaEvCtrlFlags	DmaChnGetEventControl(DmaChannel chn);
1468:                
1469:                
1470:                	/*********************************************************************
1471:                	 * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1472:                	 *
1473:                	 * PreCondition:    chn	- valid DMA channel
1474:                	 *
1475:                	 * Input:			chn			- DMA channel number
1476:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1477:                	 * 										- autoEn: enable/disable the automatic mode
1478:                	 * 										- chainEn: enable/disable channel chaining
1479:                	 * 										- detectEn: enable/disable events detection when channel disabled
1480:                	 * 										- chEn: enable/disable channel functionality
1481:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1482:                	 * 									or any of the DmaChnCtrlFlags flags:
1483:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1484:                	 *
1485:                	 * Output:          None
1486:                	 *
1487:                	 * Side Effects:    None
1488:                	 *
1489:                	 * Overview:		The function sets the selected DMA channel control flags:
1490:                	 * 					the chaining or auto mode, and events detection.
1491:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1492:                	 * 					set for the selected channel, the other channel control flags won't be touched.
1493:                	 *
1494:                	 * Note:            None.
1495:                	 *
1496:                	 * Example:			either:
1497:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL2, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1498:                	 * 					or:
1499:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1500:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL2, chCtrl.w);
1501:                	 *
1502:                	 ********************************************************************/
1503:                	 void			DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1504:                
1505:                	/*********************************************************************
1506:                	 * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1507:                	 *
1508:                	 * PreCondition:    chn	- valid DMA channel
1509:                	 *
1510:                	 * Input:			chn			- DMA channel number
1511:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1512:                	 * 										- autoEn: enable/disable the automatic mode
1513:                	 * 										- chainEn: enable/disable channel chaining
1514:                	 * 										- detectEn: enable/disable events detection when channel disabled
1515:                	 * 										- chEn: enable/disable channel functionality
1516:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1517:                	 * 									or any of the DmaChnCtrlFlags flags:
1518:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1519:                	 *
1520:                	 * Output:          None
1521:                	 *
1522:                	 * Side Effects:    None
1523:                	 *
1524:                	 * Overview:		The function clears the selected DMA channel control flags:
1525:                	 * 					the chaining or auto mode and events detection.
1526:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1527:                	 * 					cleared for the selected channel, the other channel control flags won't be touched.
1528:                	 *
1529:                	 * Note:            None.
1530:                	 *
1531:                	 * Example:			either:
1532:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL2, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1533:                	 * 					or:
1534:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1535:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL2, chCtrl.w);
1536:                	 *
1537:                	 ********************************************************************/
1538:                	 void			DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1539:                
1540:                	/*********************************************************************
1541:                	 * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1542:                	 *
1543:                	 * PreCondition:    chn	- valid DMA channel
1544:                	 *
1545:                	 * Input:			chn			- DMA channel number
1546:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1547:                	 * 										- chPri: channel priority 0-3
1548:                	 * 										- autoEn: enable/disable the automatic mode
1549:                	 * 										- chainEn: enable/disable channel chaining
1550:                	 * 										- detectEn: enable/disable events detection when channel disabled
1551:                	 * 										- chEn: enable/disable channel functionality
1552:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1553:                	 * 									or any of the DmaChnCtrlFlags flags:
1554:                	 * 										DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1555:                	 *
1556:                	 * Output:          None
1557:                	 *
1558:                	 * Side Effects:    None
1559:                	 *
1560:                	 * Overview:		The function enables/disables the selected DMA channel and also sets
1561:                	 * 					the channel priority, chaining mode or auto and events detection.
1562:                	 *
1563:                	 * Note:            None.
1564:                	 *
1565:                	 * Example:			either:
1566:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL2, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1567:                	 * 					or:
1568:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1569:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL2, chCtrl.w);
1570:                	 *
1571:                	 ********************************************************************/
1572:                	 void			DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1573:                
1574:                	/*********************************************************************
1575:                	 * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1576:                	 *
1577:                	 * PreCondition:    chn	- valid DMA channel
1578:                	 *
1579:                	 * Input:	    chn		- DMA channel number
1580:                	 *                  dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1581:                	 * 						- chPri: channel priority 0-3
1582:                	 * 						- autoEn: enable/disable the automatic mode
1583:                	 * 						- chainEn: enable/disable channel chaining
1584:                	 * 						- detectEn: enable/disable events detection when channel disabled
1585:                	 * 						- chEn: enable/disable channel functionality
1586:                	 * 						- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1587:                	 * 					or any of the DmaChnCtrlFlags flags:
1588:                	 * 						DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1589:                	 *
1590:                	 * Output:          None
1591:                	 *
1592:                	 * Side Effects:    None
1593:                	 *
1594:                	 * Overview:        The function enables/disables the selected DMA channel and also sets
1595:                	 * 					the channel priority, chaining mode or auto and events detection.
1596:                	 *
1597:                	 * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1598:                	 *
1599:                	 * Example:         either:
1600:                	 *                      DmaChnSetControl(DMA_CHANNEL2, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1601:                	 *                  or:
1602:                	 *                     	DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1603:                	 * 			DmaChnSetControl(DMA_CHANNEL2, chCtrl.w);
1604:                	 *
1605:                	 ********************************************************************/
1606:                #define		DmaChnSetControl(chn, dmaChnCtrl)	DmaChnWriteControlFlags(chn, dmaChnCtrl)
1607:                
1608:                	/*********************************************************************
1609:                	 * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1610:                	 *
1611:                	 * PreCondition:    chn	- valid DMA channel
1612:                	 *
1613:                	 * Input:			chn			- DMA channel number
1614:                	 *
1615:                	 * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1616:                	 * 							- chPri: channel priority 0-3
1617:                	 * 							- autoEn: enable/disable the automatic mode
1618:                	 * 							- chainEn: enable/disable channel chaining
1619:                	 * 							- detectEn: enable/disable events detection when channel disabled
1620:                	 * 							- chEn: enable/disable channel functionality
1621:                	 * 							- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1622:                	 *						or any of the DmaChnCtrlFlags flags:
1623:                	 *							DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1624:                	 *
1625:                	 * Side Effects:    None
1626:                	 *
1627:                	 * Overview:		The function retrieves the current control settings for the selected DMA channel,
1628:                	 * 					including the channel enable/disable status, the channel priority,
1629:                	 * 					chaining mode, auto mode and events detection.
1630:                	 *
1631:                	 * Note:            None.
1632:                	 *
1633:                	 * Example:			either:
1634:                	 * 						DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL2); if(ctrl&DMA_CTL_AUTO_EN) {...}
1635:                	 * 					or:
1636:                	 * 						DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL2); if(chnCtrl.autoEn) {...}
1637:                	 *
1638:                	 ********************************************************************/
1639:                	 DmaChnCtrlFlags	DmaChnGetControlFlags(DmaChannel chn);
1640:                
1641:                
1642:                	/*********************************************************************
1643:                	 * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1644:                	 *
1645:                	 * PreCondition:    chn	- valid DMA channel
1646:                	 *
1647:                	 * Input:			chn		- DMA channel number
1648:                	 *
1649:                	 * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1650:                	 *
1651:                	 * Side Effects:    None
1652:                	 *
1653:                	 * Overview:		The function returns the current event detection for the selected DMA channel.
1654:                	 *
1655:                	 * Note:            None.
1656:                	 *
1657:                	 * Example:			int evDetect=DmaChnGetEvDetect(DMA_CHANNEL2);
1658:                	 *
1659:                	 ********************************************************************/
1660:                	 int			DmaChnGetEvDetect(DmaChannel chn);
1661:                
1662:                	/*********************************************************************
1663:                	 * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1664:                	 *
1665:                	 * PreCondition:    chn		- valid DMA channel
1666:                	 * 					pTxCtrl	- valid pointer
1667:                	 *
1668:                	 * Input:			chn			- DMA channel number
1669:                	 * 					pTxCtrl		- pointer to a DmaTxferCtrl that will carry the following info:
1670:                	 * 								- vSrcAdd: source of the DMA transfer
1671:                	 * 								- vDstAdd: destination of the DMA transfer
1672:                	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1673:                	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1674:                	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1675:                	 *					mapToK0		- if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1676:                	 *
1677:                	 * Output:          None
1678:                	 *
1679:                	 * Side Effects:    None
1680:                	 *
1681:                	 * Overview:		The function retrieves the transfer characteristics for a DMA channel transfer:
1682:                	 * 					the source and the destination addresses.
1683:                	 * 					It also retrieves the source and destination lengths
1684:                	 * 					and the number of bytes	transferred per event.
1685:                	 *
1686:                	 * Note:            None
1687:                	 *
1688:                	 * Example:			DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL2, &txCtl, FALSE);
1689:                	 ********************************************************************/
1690:                	 void			DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1691:                
1692:                	// Low level CRC functions
1693:                
1694:                	/*********************************************************************
1695:                	 * Function:        void DmaCrcEnable(int enable)
1696:                	 *
1697:                	 * PreCondition:    None
1698:                	 *
1699:                	 * Input:           enable - boolean to enable/disable the CRC module
1700:                	 *
1701:                	 * Output:          None
1702:                	 *
1703:                	 * Side Effects:    None
1704:                	 *
1705:                	 * Overview:        The function enables the CRC module functionality and the attached DMA channel transfers are routed to the CRC module.
1706:                	 *
1707:                	 * Note:            The CRC module should be properly configured before enabled.
1708:                	 *
1709:                	 * Example:         CrcEnable(1);
1710:                	 ********************************************************************/
1711:                	extern __inline__ void __attribute__((always_inline)) DmaCrcEnable(int enable)
1712:                	{
1713:                		if(enable)
1714:                		{
1715:                			DCRCCONSET=_DCRCCON_CRCEN_MASK;
1716:                		}
1717:                		else
1718:                		{
1719:                			DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1720:                		}
1721:                	}
1722:                
1723:                
1724:                
1725:                	/*********************************************************************
1726:                	 * Function:        int DmaCrcGetEnable(void)
1727:                	 *
1728:                	 * PreCondition:    None
1729:                	 *
1730:                	 * Input:			None
1731:                	 *
1732:                	 * Output:          TRUE, if the CRC module is enabled
1733:                	 * 					FALSE otherwise
1734:                	 *
1735:                	 * Side Effects:    None
1736:                	 *
1737:                	 * Overview:		The function returns the CRC module enabling status.
1738:                	 *
1739:                	 * Note:            None
1740:                	 *
1741:                	 * Example:			int isCrcEnabled=DmaCrcGetEnable();
1742:                	 ********************************************************************/
1743:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetEnable(void)
1744:                	{
1745:                		return	DCRCCONbits.CRCEN!=0;
1746:                	}
1747:                
1748:                	
1749:                	/*********************************************************************
1750:                	 * Function:        void DmaCrcAppendModeEnable(int enable)
1751:                	 *
1752:                	 * PreCondition:    None
1753:                	 *
1754:                	 * Input:           enable - boolean to enable/disable the append mode
1755:                	 *
1756:                	 * Output:          None
1757:                	 *
1758:                	 * Side Effects:    None
1759:                	 *
1760:                	 * Overview:		The function enables the CRC append mode. In this mode, the attached DMA channel reads
1761:                	 * 					the source data but does not write it to the destination address. The data it's just passed
1762:                	 * 					to the CRC generator for CRC calculation.
1763:                	 * 					When the block transfer is completed, the CRC result is written to the
1764:                	 * 					DMA channel destination address.
1765:                	 *
1766:                	 * Note:            The CRC module should be properly configured before enabled.
1767:                	 *
1768:                	 * Example:         DmaCrcAppendModeEnable(1);
1769:                	 ********************************************************************/
1770:                	extern __inline__ void __attribute__((always_inline)) DmaCrcAppendModeEnable(int enable)
1771:                	{
1772:                		if(enable)
1773:                		{
1774:                			DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1775:                		}
1776:                		else
1777:                		{
1778:                			DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1779:                		}
1780:                	}
1781:                
1782:                
1783:                	/*********************************************************************
1784:                	 * Function:        int DmaCrcGetAppendMode(void)
1785:                	 *
1786:                	 * PreCondition:    None
1787:                	 *
1788:                	 * Input:           None
1789:                	 *
1790:                	 * Output:          TRUE, if the CRC append mode is enabled
1791:                	 * 					FALSE otherwise
1792:                	 *
1793:                	 * Side Effects:    None
1794:                	 *
1795:                	 * Overview:		The function returns the CRC module enabling status.
1796:                	 *
1797:                	 * Note:            None
1798:                	 *
1799:                	 * Example:			int isAppendEnabled=DmaCrcGetAppendMode();
1800:                	 ********************************************************************/
1801:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetAppendMode(void)
1802:                	{
1803:                		return DCRCCONbits.CRCAPP!=0;
1804:                	}
1805:                
1806:                	/*********************************************************************
1807:                	 * Function:        void DmaCrcSetAttach(DmaChannel chn)
1808:                	 *
1809:                	 * PreCondition:    chn		- valid DMA channel
1810:                	 *
1811:                	 * Input:			chn	- the DMA channel to be attached to the CRC module (the DMA channel transfers will be routed to the CRC module)
1812:                	 *
1813:                	 * Output:          None
1814:                	 *
1815:                	 * Side Effects:    None
1816:                	 *
1817:                	 * Overview:		The function attaches a DMA channel to the CRC module.
1818:                	 *
1819:                	 * Note:            None
1820:                	 *
1821:                	 * Example:			DmaCrcSetAttach(DMA_CHANNEL0);
1822:                	 ********************************************************************/
1823:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetAttach(DmaChannel chn)
1824:                	{
1825:                		DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1826:                		DCRCCONSET=chn;
1827:                	}
1828:                		
1829:                	/*********************************************************************
1830:                	 * Function:        DmaChannel DmaCrcGetAttach(void)
1831:                	 *
1832:                	 * PreCondition:    None
1833:                	 *
1834:                	 * Input:			None
1835:                	 *
1836:                	 * Output:          the DMA channel that is currently attached to the CRC module
1837:                	 *
1838:                	 * Side Effects:    None
1839:                	 *
1840:                	 * Overview:		The function returns the DMA channel number that is currently attached to the CRC module.
1841:                	 *
1842:                	 * Note:            None
1843:                	 *
1844:                	 * Example:			DmaChannel chn=DmaCrcGetAttach();
1845:                	 ********************************************************************/
1846:                	extern __inline__ DmaChannel __attribute__((always_inline)) DmaCrcGetAttach(void)
1847:                	{
1848:                		return	(DmaChannel)DCRCCONbits.CRCCH;
1849:                	}
1850:                
1851:                
1852:                	/*********************************************************************
1853:                	 * Function:        void DmaCrcSetPLen(int pLen)
1854:                	 *
1855:                	 * PreCondition:    pLen	- valid polynomial length within 1-16
1856:                	 *
1857:                	 * Input:			pLen	- the length of the CRC generator polynomial
1858:                	 *
1859:                	 * Output:          None
1860:                	 *
1861:                	 * Side Effects:    None
1862:                	 *
1863:                	 * Overview:		The length of the CRC generator polynomial is set as being pLen;
1864:                	 *
1865:                	 * Note:            None
1866:                	 *
1867:                	 * Example:         DmaCrcSetPLen(16);
1868:                	 ********************************************************************/
1869:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
1870:                	{
1871:                		DCRCCONCLR=_DCRCCON_PLEN_MASK;
1872:                		DCRCCONSET=(pLen)-1;
1873:                	}
1874:                		
1875:                	/*********************************************************************
1876:                	 * Function:        int DmaCrcGetPLen(void)
1877:                	 *
1878:                	 * PreCondition:    None
1879:                	 *
1880:                	 * Input:           None
1881:                	 *
1882:                	 * Output:          the length of the CRC generator polynomial
1883:                	 *
1884:                	 * Side Effects:    None
1885:                	 *
1886:                	 * Overview:        The function returns the current length of the CRC generator polynomial.
1887:                	 *                  It's always a number between 1 and 16.
1888:                	 *
1889:                	 * Note:            None
1890:                	 *
1891:                	 * Example:         int polyLen=DmaCrcGetPLen();
1892:                	 ********************************************************************/
1893:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
1894:                	{
1895:                		return	DCRCCONbits.PLEN+1; 
1896:                	}
1897:                	
1898:                
1899:                	/*********************************************************************
1900:                	 * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
1901:                	 *
1902:                	 * PreCondition:    None
1903:                	 *
1904:                	 * Input:			feedback	- the layout of the CRC generator
1905:                	 *
1906:                	 * Output:          None
1907:                	 *
1908:                	 * Side Effects:    None
1909:                	 *
1910:                	 * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
1911:                	 *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
1912:                	 *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
1913:                	 *
1914:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
1915:                	 *
1916:                	 * Example:         DmaCrcSetShiftFeedback(0x8005);
1917:                	 ********************************************************************/
1918:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
1919:                	{
1920:                		DCRCXOR=feedback;
1921:                	}
1922:                
1923:                		
1924:                	/*********************************************************************
1925:                	 * Function:        unsigned int DmaCrcGetShiftFeedback(void)
1926:                	 *
1927:                	 * PreCondition:    None
1928:                	 *
1929:                	 * Input:			None
1930:                	 *
1931:                	 * Output:          the current layout of the CRC generator
1932:                	 *
1933:                	 * Side Effects:    None
1934:                	 *
1935:                	 * Overview:		The function returns the layout of the shift stages that take place in the CRC generation.
1936:                	 * 					A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
1937:                	 * 					If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
1938:                	 *
1939:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
1940:                	 *
1941:                	 * Example:         int feedback=DmaCrcGetShiftFeedback();
1942:                	 ********************************************************************/
1943:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
1944:                	{
1945:                		return DCRCXOR;
1946:                	}
1947:                
1948:                	/*********************************************************************
1949:                	 * Function:        void DmaCrcSetSeed(unsigned int seed)
1950:                	 *
1951:                	 * PreCondition:    None
1952:                	 *
1953:                	 * Input:			seed	- the initial seed of the CRC generator
1954:                	 *
1955:                	 * Output:          None
1956:                	 *
1957:                	 * Side Effects:    None
1958:                	 *
1959:                	 * Overview:		The function sets the seed of the CRC generator. This is the initial data present in the
1960:                	 * 					CRC shift register before the CRC calculation begins.
1961:                	 *
1962:                	 * Note:            None
1963:                	 *
1964:                	 * Example:			DmaCrcSetSeed(0xffff);
1965:                	 ********************************************************************/
1966:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetSeed(unsigned int seed)
1967:                	{
1968:                		DCRCDATA=seed;
1969:                	}
1970:                		
1971:                	/*********************************************************************
1972:                	 * Function:        unsigned int DmaCrcGetValue(void)
1973:                	 *
1974:                	 * PreCondition:    None
1975:                	 *
1976:                	 * Input:			None
1977:                	 *
1978:                	 * Output:          the current value of the CRC generator
1979:                	 *
1980:                	 * Side Effects:    None
1981:                	 *
1982:                	 * Overview:		The function returns the current value of the CRC generator.
1983:                	 *
1984:                	 * Note:            Only the remainder bits (0 to pLen-1) are significant, the rest should be ignored.
1985:                	 *
1986:                	 * Example:		unsigned int calcCrc=DmaCrcGetValue();
1987:                	 ********************************************************************/
1988:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetValue(void)
1989:                	{
1990:                		return DCRCDATA;
1991:                	}
1992:                
1993:                
1994:                	// Channel test/debug and special functions
1995:                
1996:                	/*********************************************************************
1997:                	 * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
1998:                	 *
1999:                	 * PreCondition:    chn	- valid DMA channel
2000:                	 *
2001:                	 * Input:			chn		- DMA channel number
2002:                	 * 					eFlags	- event flags with the following significance:
2003:                	 * 								- DMA_EV_ERR: address error event
2004:                	 * 								- DMA_EV_ABORT: transfer abort event
2005:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2006:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2007:                	 * 								- DMA_EV_DST_HALF: destination half event
2008:                	 * 								- DMA_EV_DST_FULL: destination full event
2009:                	 * 								- DMA_EV_SRC_HALF: source half event
2010:                	 * 								- DMA_EV_SRC_FULL: source full event
2011:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2012:                	 *
2013:                	 * Output:          None
2014:                	 *
2015:                	 * Side Effects:    None
2016:                	 *
2017:                	 * Overview:		The function sets the event flags for the selected DMA channel.
2018:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2019:                	 * 					set for the selected channel, the other channel event flags won't be touched.
2020:                	 *
2021:                	 * Note:            This is intended as a channel test function.
2022:                	 *
2023:                	 * Example:			DmaChnSetEvFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2024:                	 ********************************************************************/
2025:                	 void			DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2026:                
2027:                	/*********************************************************************
2028:                	 * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2029:                	 *
2030:                	 * PreCondition:    chn	- valid DMA channel
2031:                	 *
2032:                	 * Input:			chn		- DMA channel number
2033:                	 * 					eFlags	- event flags with the following significance:
2034:                	 * 								- DMA_EV_ERR: address error event
2035:                	 * 								- DMA_EV_ABORT: transfer abort event
2036:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2037:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2038:                	 * 								- DMA_EV_DST_HALF: destination half event
2039:                	 * 								- DMA_EV_DST_FULL: destination full event
2040:                	 * 								- DMA_EV_SRC_HALF: source half event
2041:                	 * 								- DMA_EV_SRC_FULL: source full event
2042:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2043:                	 *
2044:                	 * Output:          None
2045:                	 *
2046:                	 * Side Effects:    None
2047:                	 *
2048:                	 * Overview:		The function writes the event flags for the selected DMA channel.
2049:                	 * 					The channel event flags are forced to the eFlags value.
2050:                	 *
2051:                	 * Note:            This is intended as a channel test function.
2052:                	 *
2053:                	 * Example:			DmaChnWriteEvFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2054:                	 ********************************************************************/
2055:                	 void			DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2056:                
2057:                
2058:                	/********************************************************************
2059:                	 * Include legacy DMA functions
2060:                	 * New projects should not use them!
2061:                	 * Note that interrupt functions are no longer provided.
2062:                	 * The functions in the int.h should be used instead.
2063:                	 ********************************************************************/
2064:                	#ifndef _PLIB_DISABLE_LEGACY
2065:                		#include <peripheral/legacy/dma_legacy.h>
2066:                	#endif
2067:                
2068:                	 
2069:                #else
2070:                	#undef _DMA_CHANNELS		// no DMA channels
2071:                #endif	// _DMAC0
2072:                
2073:                #endif /*_DMA_H_*/
2074:                
2075:                
---  /home/bekeband/MPLABXProjects/AN1388_Source_Code_2014_02_14/PIC32_Bootloaders/Firmware/Bootloader/Source/USB/usb_function_hid.c
1:                   /********************************************************************
2:                     File Information:
3:                       FileName:     	usb_function_hid.c
4:                       Dependencies:   See INCLUDES section
5:                       Processor:      PIC18 or PIC24 USB Microcontrollers
6:                       Hardware:       The code is natively intended to be used on the following
7:                       				hardware platforms: PICDEMï¿½ FS USB Demo Board, 
8:                       				PIC18F87J50 FS USB Plug-In Module, or
9:                       				Explorer 16 + PIC24 USB PIM.  The firmware may be
10:                      				modified for use on other USB platforms by editing the
11:                      				HardwareProfile.h file.
12:                      Complier:  	    Microchip C18 (for PIC18) or C30 (for PIC24)
13:                      Company:        Microchip Technology, Inc.
14:                      
15:                      Software License Agreement:
16:                      
17:                      The software supplied herewith by Microchip Technology Incorporated
18:                      (the ï¿½Companyï¿½) for its PICï¿½ Microcontroller is intended and
19:                      supplied to you, the Companyï¿½s customer, for use solely and
20:                      exclusively on Microchip PIC Microcontroller products. The
21:                      software is owned by the Company and/or its supplier, and is
22:                      protected under applicable copyright laws. All rights are reserved.
23:                      Any use in violation of the foregoing restrictions may subject the
24:                      user to criminal sanctions under applicable laws, as well as to
25:                      civil liability for the breach of the terms and conditions of this
26:                      license.
27:                      
28:                      THIS SOFTWARE IS PROVIDED IN AN ï¿½AS ISï¿½ CONDITION. NO WARRANTIES,
29:                      WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                      TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                      PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                      IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                      CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                  
35:                    File Description:
36:                      
37:                      Change History:
38:                       Rev   Date         Description
39:                       1.0   11/19/2004   Initial release
40:                       2.1   02/26/2007   Updated for simplicity and to use common
41:                                          coding style
42:                  
43:                    Summary:
44:                      This file contains all of functions, macros, definitions, variables,
45:                      datatypes, etc. that are required for usage with the HID function
46:                      driver. This file should be included in projects that use the HID
47:                      /function driver.
48:                      
49:                      
50:                      
51:                      This file is located in the "/<Install Directory/>//Microchip//USB//HID
52:                      Device Driver" directory.
53:                    Description:
54:                      USB HID Function Driver File
55:                      
56:                      This file contains all of functions, macros, definitions, variables,
57:                      datatypes, etc. that are required for usage with the HID function
58:                      driver. This file should be included in projects that use the HID
59:                      /function driver.
60:                      
61:                      This file is located in the "/<Install Directory/>//Microchip//USB//HID
62:                      Device Driver" directory.
63:                      
64:                      When including this file in a new project, this file can either be
65:                      referenced from the directory in which it was installed or copied
66:                      directly into the user application folder. If the first method is
67:                      chosen to keep the file located in the folder in which it is installed
68:                      then include paths need to be added so that the library and the
69:                      application both know where to reference each others files. If the
70:                      application folder is located in the same folder as the Microchip
71:                      folder (like the current demo folders), then the following include
72:                      paths need to be added to the application's project:
73:                      
74:                      ..//Include
75:                      
76:                      ..//..//Include
77:                      
78:                      ..//..//Microchip//Include
79:                      
80:                      ..//..///<Application Folder/>
81:                      
82:                      ..//..//..///<Application Folder/>
83:                      
84:                      If a different directory structure is used, modify the paths as
85:                      required. An example using absolute paths instead of relative paths
86:                      would be the following:
87:                      
88:                      C://Microchip Solutions//Microchip//Include
89:                      
90:                      C://Microchip Solutions//My Demo Application  
91:                  *******************************************************************/
92:                  
93:                  #ifndef USB_FUNCTION_HID_C
94:                  #define USB_FUNCTION_HID_C
95:                  
96:                  /** INCLUDES *******************************************************/
97:                  #include "GenericTypeDefs.h"
98:                  #include "Compiler.h"
99:                  #include "./USB/usb.h"
100:                 #include "./USB/usb_function_hid.h"
101:                 
102:                 
103:                 /** VARIABLES ******************************************************/
104:                 #pragma udata
105:                 BYTE idle_rate;
106:                 BYTE active_protocol;   // [0] Boot Protocol [1] Report Protocol
107:                 
108:                 /** EXTERNAL PROTOTYPES ********************************************/
109:                 #ifdef __cplusplus
110:                 extern "C" {
111:                 #endif
112:                 #if defined USER_GET_REPORT_HANDLER
113:                     void USER_GET_REPORT_HANDLER(void);
114:                 #endif
115:                 
116:                 #if defined USER_SET_REPORT_HANDLER
117:                     void USER_SET_REPORT_HANDLER(void);
118:                 #endif     
119:                 #ifdef __cplusplus
120:                 }
121:                 #endif
122:                 
123:                 /** Section: DECLARATIONS ***************************************************/
124:                 #pragma code
125:                 
126:                 /** Section: CLASS SPECIFIC REQUESTS ****************************************/
127:                 
128:                 /********************************************************************
129:                 	Function:
130:                 		void USBCheckHIDRequest(void)
131:                 		
132:                  	Summary:
133:                  		This routine handles HID specific request that happen on EP0.  
134:                         This function should be called from the USBCBCheckOtherReq() call back 
135:                         function whenever implementing a HID device.
136:                 
137:                  	Description:
138:                  		This routine handles HID specific request that happen on EP0.  These
139:                         include, but are not limited to, requests for the HID report 
140:                         descriptors.  This function should be called from the 
141:                         USBCBCheckOtherReq() call back function whenever using an HID device.	
142:                 
143:                         Typical Usage:
144:                         <code>
145:                         void USBCBCheckOtherReq(void)
146:                         {
147:                             //Since the stack didn't handle the request I need to check
148:                             //  my class drivers to see if it is for them
149:                             USBCheckHIDRequest();
150:                         }
151:                         </code>
152:                 		
153:                 	PreCondition:
154:                 		None
155:                 		
156:                 	Parameters:
157:                 		None
158:                 		
159:                 	Return Values:
160:                 		None
161:                 		
162:                 	Remarks:
163:                 		None
164:                  
165:                  *******************************************************************/
166:                 void USBCheckHIDRequest(void)
167:                 {
9D005288  27BDFFF8   ADDIU SP, SP, -8
9D00528C  AFBE0004   SW S8, 4(SP)
9D005290  03A0F021   ADDU S8, SP, ZERO
168:                     if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
9D005294  9382806C   LBU V0, -32660(GP)
9D005298  304200FF   ANDI V0, V0, 255
9D00529C  3042001F   ANDI V0, V0, 31
9D0052A0  304300FF   ANDI V1, V0, 255
9D0052A4  24020001   ADDIU V0, ZERO, 1
9D0052A8  1462008C   BNE V1, V0, 0x9D0054DC
9D0052AC  00000000   NOP
9D0054DC  00000000   NOP
9D0054E0  0B40153E   J 0x9D0054F8
9D0054E4  00000000   NOP
169:                     if(SetupPkt.bIntfID != HID_INTF_ID) return;
9D0052B0  93828070   LBU V0, -32656(GP)
9D0052B4  304200FF   ANDI V0, V0, 255
9D0052B8  1440008B   BNE V0, ZERO, 0x9D0054E8
9D0052BC  00000000   NOP
9D0054E8  00000000   NOP
9D0054EC  0B40153E   J 0x9D0054F8
9D0054F0  00000000   NOP
170:                     
171:                     /*
172:                      * There are two standard requests that hid.c may support.
173:                      * 1. GET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
174:                      * 2. SET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
175:                      */
176:                     if(SetupPkt.bRequest == USB_REQUEST_GET_DESCRIPTOR)
9D0052C0  9382806D   LBU V0, -32659(GP)
9D0052C4  304300FF   ANDI V1, V0, 255
9D0052C8  24020006   ADDIU V0, ZERO, 6
9D0052CC  14620037   BNE V1, V0, 0x9D0053AC
9D0052D0  00000000   NOP
177:                     {
178:                         switch(SetupPkt.bDescriptorType)
9D0052D4  9382806F   LBU V0, -32657(GP)
9D0052D8  304200FF   ANDI V0, V0, 255
9D0052DC  24030022   ADDIU V1, ZERO, 34
9D0052E0  10430019   BEQ V0, V1, 0x9D005348
9D0052E4  00000000   NOP
9D0052E8  24030023   ADDIU V1, ZERO, 35
9D0052EC  10430028   BEQ V0, V1, 0x9D005390
9D0052F0  00000000   NOP
9D0052F4  24030021   ADDIU V1, ZERO, 33
9D0052F8  1443002C   BNE V0, V1, 0x9D0053AC
9D0052FC  00000000   NOP
179:                         {
180:                             case DSC_HID: //HID Descriptor          
181:                                 if(USBActiveConfiguration == 1)
9D005300  9383807C   LBU V1, -32644(GP)
9D005304  24020001   ADDIU V0, ZERO, 1
9D005308  14620024   BNE V1, V0, 0x9D00539C
9D00530C  00000000   NOP
182:                                 {
183:                                     USBEP0SendROMPtr(
9D005310  3C02A000   LUI V0, -24576
9D005314  3C039D00   LUI V1, -25344
9D005318  24635532   ADDIU V1, V1, 21810
9D00531C  AC4302C0   SW V1, 704(V0)
9D005320  3C02A000   LUI V0, -24576
9D005324  244202C0   ADDIU V0, V0, 704
9D005328  24030009   ADDIU V1, ZERO, 9
9D00532C  A4430008   SH V1, 8(V0)
9D005330  3C02A000   LUI V0, -24576
9D005334  244202C0   ADDIU V0, V0, 704
9D005338  2403FFC0   ADDIU V1, ZERO, -64
9D00533C  A0430004   SB V1, 4(V0)
184:                                         (ROM BYTE*)&configDescriptor1 + 18,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
185:                                         sizeof(USB_HID_DSC)+3,
186:                                         USB_EP0_INCLUDE_ZERO);
187:                                 }
188:                                 break;
9D005340  0B4014EB   J 0x9D0053AC
9D005344  00000000   NOP
9D00539C  00000000   NOP
9D0053A0  0B4014EB   J 0x9D0053AC
9D0053A4  00000000   NOP
189:                             case DSC_RPT:  //Report Descriptor           
190:                                 if(USBActiveConfiguration == 1)
9D005348  9383807C   LBU V1, -32644(GP)
9D00534C  24020001   ADDIU V0, ZERO, 1
9D005350  14620015   BNE V1, V0, 0x9D0053A8
9D005354  00000000   NOP
191:                                 {
192:                                     USBEP0SendROMPtr(
9D005358  3C02A000   LUI V0, -24576
9D00535C  3C039D00   LUI V1, -25344
9D005360  246355AC   ADDIU V1, V1, 21932
9D005364  AC4302C0   SW V1, 704(V0)
9D005368  3C02A000   LUI V0, -24576
9D00536C  244202C0   ADDIU V0, V0, 704
9D005370  2403001D   ADDIU V1, ZERO, 29
9D005374  A4430008   SH V1, 8(V0)
9D005378  3C02A000   LUI V0, -24576
9D00537C  244202C0   ADDIU V0, V0, 704
9D005380  2403FFC0   ADDIU V1, ZERO, -64
9D005384  A0430004   SB V1, 4(V0)
193:                                         (ROM BYTE*)&hid_rpt01,
194:                                         sizeof(hid_rpt01),     //See usbcfg.h
195:                                         USB_EP0_INCLUDE_ZERO);
196:                                 }
197:                                 break;
9D005388  0B4014EB   J 0x9D0053AC
9D00538C  00000000   NOP
9D0053A8  00000000   NOP
198:                             case DSC_PHY:  //Physical Descriptor
199:                 				//Note: The below placeholder code is commented out.  HID Physical Descriptors are optional and are not used
200:                 				//in many types of HID applications.  If an application does not have a physical descriptor,
201:                 				//then the device should return STALL in response to this request (stack will do this automatically
202:                 				//if no-one claims ownership of the control transfer).
203:                 				//If an application does implement a physical descriptor, then make sure to declare
204:                 				//hid_phy01 (rom structure containing the descriptor data), and hid_phy01 (the size of the descriptors in bytes),
205:                 				//and then uncomment the below code.
206:                                 //if(USBActiveConfiguration == 1)
207:                                 //{
208:                                 //    USBEP0SendROMPtr((ROM BYTE*)&hid_phy01, sizeof(hid_phy01), USB_EP0_INCLUDE_ZERO);
209:                                 //}
210:                                 break;
9D005390  00000000   NOP
9D005394  0B4014EB   J 0x9D0053AC
9D005398  00000000   NOP
211:                         }//end switch(SetupPkt.bDescriptorType)
212:                     }//end if(SetupPkt.bRequest == GET_DSC)
213:                     
214:                     if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD)
9D0053AC  9382806C   LBU V0, -32660(GP)
9D0053B0  304200FF   ANDI V0, V0, 255
9D0053B4  30420060   ANDI V0, V0, 96
9D0053B8  304300FF   ANDI V1, V0, 255
9D0053BC  24020020   ADDIU V0, ZERO, 32
9D0053C0  1462004C   BNE V1, V0, 0x9D0054F4
9D0053C4  00000000   NOP
215:                     {
216:                         return;
9D0054F4  00000000   NOP
217:                     }
218:                 
219:                     switch(SetupPkt.bRequest)
9D0053C8  9382806D   LBU V0, -32659(GP)
9D0053CC  304200FF   ANDI V0, V0, 255
9D0053D0  2C43000C   SLTIU V1, V0, 12
9D0053D4  10600048   BEQ V1, ZERO, 0x9D0054F8
9D0053D8  00000000   NOP
9D0053DC  00021880   SLL V1, V0, 2
9D0053E0  3C029D00   LUI V0, -25344
9D0053E4  244253F8   ADDIU V0, V0, 21496
9D0053E8  00621021   ADDU V0, V1, V0
9D0053EC  8C420000   LW V0, 0(V0)
9D0053F0  00400008   JR V0
9D0053F4  00000000   NOP
220:                     {
221:                         case GET_REPORT:
222:                             #if defined USER_GET_REPORT_HANDLER
223:                                 USER_GET_REPORT_HANDLER();
224:                             #endif
225:                             break;
226:                         case SET_REPORT:
227:                             #if defined USER_SET_REPORT_HANDLER
228:                                 USER_SET_REPORT_HANDLER();
229:                             #endif       
230:                             break;
231:                         case GET_IDLE:
232:                             USBEP0SendRAMPtr(
9D005428  3C02A000   LUI V0, -24576
9D00542C  27838091   ADDIU V1, GP, -32623
9D005430  AC4302C0   SW V1, 704(V0)
9D005434  3C02A000   LUI V0, -24576
9D005438  244202C0   ADDIU V0, V0, 704
9D00543C  24030001   ADDIU V1, ZERO, 1
9D005440  A4430008   SH V1, 8(V0)
9D005444  3C02A000   LUI V0, -24576
9D005448  244202C0   ADDIU V0, V0, 704
9D00544C  2403FFC1   ADDIU V1, ZERO, -63
9D005450  A0430004   SB V1, 4(V0)
233:                                 (BYTE*)&idle_rate,
234:                                 1,
235:                                 USB_EP0_INCLUDE_ZERO);
236:                             break;
9D005454  0B40153E   J 0x9D0054F8
9D005458  00000000   NOP
237:                         case SET_IDLE:
238:                             USBEP0Transmit(USB_EP0_NO_DATA);
9D00545C  3C02A000   LUI V0, -24576
9D005460  244202C0   ADDIU V0, V0, 704
9D005464  2403FF80   ADDIU V1, ZERO, -128
9D005468  A0430004   SB V1, 4(V0)
239:                             idle_rate = SetupPkt.W_Value.byte.HB;
9D00546C  9382806F   LBU V0, -32657(GP)
9D005470  304200FF   ANDI V0, V0, 255
9D005474  A3828091   SB V0, -32623(GP)
240:                             break;
9D005478  0B40153E   J 0x9D0054F8
9D00547C  00000000   NOP
241:                         case GET_PROTOCOL:
242:                             USBEP0SendRAMPtr(
9D005480  3C02A000   LUI V0, -24576
9D005484  27838090   ADDIU V1, GP, -32624
9D005488  AC4302C0   SW V1, 704(V0)
9D00548C  3C02A000   LUI V0, -24576
9D005490  244202C0   ADDIU V0, V0, 704
9D005494  24030001   ADDIU V1, ZERO, 1
9D005498  A4430008   SH V1, 8(V0)
9D00549C  3C02A000   LUI V0, -24576
9D0054A0  244202C0   ADDIU V0, V0, 704
9D0054A4  2403FF81   ADDIU V1, ZERO, -127
9D0054A8  A0430004   SB V1, 4(V0)
243:                                 (BYTE*)&active_protocol,
244:                                 1,
245:                                 USB_EP0_NO_OPTIONS);
246:                             break;
9D0054AC  0B40153E   J 0x9D0054F8
9D0054B0  00000000   NOP
247:                         case SET_PROTOCOL:
248:                             USBEP0Transmit(USB_EP0_NO_DATA);
9D0054B4  3C02A000   LUI V0, -24576
9D0054B8  244202C0   ADDIU V0, V0, 704
9D0054BC  2403FF80   ADDIU V1, ZERO, -128
9D0054C0  A0430004   SB V1, 4(V0)
249:                             active_protocol = SetupPkt.W_Value.byte.LB;
9D0054C4  9382806E   LBU V0, -32658(GP)
9D0054C8  304200FF   ANDI V0, V0, 255
9D0054CC  A3828090   SB V0, -32624(GP)
250:                             break;
9D0054D0  00000000   NOP
9D0054D4  0B40153E   J 0x9D0054F8
9D0054D8  00000000   NOP
251:                     }//end switch(SetupPkt.bRequest)
252:                 
253:                 }//end USBCheckHIDRequest
9D0054F8  03C0E821   ADDU SP, S8, ZERO
9D0054FC  8FBE0004   LW S8, 4(SP)
9D005500  27BD0008   ADDIU SP, SP, 8
9D005504  03E00008   JR RA
9D005508  00000000   NOP
254:                 
255:                 /** USER API *******************************************************/
256:                 
257:                 #endif
258:                 /** EOF usb_function_hid.c ******************************************************/
---  /home/bekeband/MPLABXProjects/AN1388_Source_Code_2014_02_14/PIC32_Bootloaders/Firmware/Bootloader/Source/USB/usb_device.c
1:                   /********************************************************************
2:                     File Information:
3:                       FileName:     	usb_device.c
4:                       Dependencies:	See INCLUDES section
5:                       Processor:		PIC18,PIC24, PIC32 and dsPIC33E USB Microcontrollers
6:                       Hardware:		This code is natively intended to be used on Mirochip USB
7:                                       demo boards.  See www.microchip.com/usb (Software & Tools 
8:                                       section) for list of available platforms.  The firmware may 
9:                                       be modified for use on other USB platforms by editing the
10:                      				HardwareProfile.h and HardwareProfile - [platform].h files.
11:                      Complier:  	    Microchip C18 (for PIC18),C30 (for PIC24 and dsPIC33E)
12:                                      and C32 (for PIC32)
13:                      Company:		Microchip Technology, Inc.
14:                      
15:                      Software License Agreement:
16:                      
17:                      The software supplied herewith by Microchip Technology Incorporated
18:                      (the "Company") for its PIC(r) Microcontroller is intended and
19:                      supplied to you, the Company's customer, for use solely and
20:                      exclusively on Microchip PIC Microcontroller products. The
21:                      software is owned by the Company and/or its supplier, and is
22:                      protected under applicable copyright laws. All rights are reserved.
23:                      Any use in violation of the foregoing restrictions may subject the
24:                      user to criminal sanctions under applicable laws, as well as to
25:                      civil liability for the breach of the terms and conditions of this
26:                      license.
27:                      
28:                      THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                      WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                      TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                      PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                      IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                      CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                  
35:                    Summary:
36:                      This file contains functions, macros, definitions, variables,
37:                      datatypes, etc. that are required for usage with the MCHPFSUSB device
38:                      stack. This file should be included in projects that use the device stack. 
39:                      
40:                      This file is located in the "/<Install Directory/>//Microchip//USB"
41:                      directory.
42:                  
43:                    Description:
44:                      USB Device Stack File
45:                      
46:                      This file contains functions, macros, definitions, variables,
47:                      datatypes, etc. that are required for usage with the MCHPFSUSB device
48:                      stack. This file should be included in projects that use the device stack.
49:                      
50:                      This file is located in the "/<Install Directory/>//Microchip//USB"
51:                      directory.
52:                      
53:                      When including this file in a new project, this file can either be
54:                      referenced from the directory in which it was installed or copied
55:                      directly into the user application folder. If the first method is
56:                      chosen to keep the file located in the folder in which it is installed
57:                      then include paths need to be added so that the library and the
58:                      application both know where to reference each others files. If the
59:                      application folder is located in the same folder as the Microchip
60:                      folder (like the current demo folders), then the following include
61:                      paths need to be added to the application's project:
62:                      
63:                      .
64:                      ..//..//MicrochipInclude
65:                      
66:                      If a different directory structure is used, modify the paths as
67:                      required. An example using absolute paths instead of relative paths
68:                      would be the following:
69:                      
70:                      C://Microchip Solutions//Microchip//Include
71:                      
72:                      C://Microchip Solutions//My Demo Application 
73:                  
74:                  ********************************************************************
75:                   File Description:
76:                  
77:                   Change History:
78:                    Rev    Description
79:                    ----   -----------
80:                    2.6    Added USBCancelIO() function.  Moved and some stack
81:                           defintions to be more consistant with the host stack.
82:                  
83:                    2.6a   Fixed issue where a SET_CONFIGURATION received could cause
84:                           inability to transmit on an endpoint if using ping-pong
85:                           and an odd number of packets had been sent on that endpoint 
86:                  
87:                    2.7    Fixed error where the USB error interrupt flag was not getting
88:                           cleared properly for PIC32 resulting in lots of extra error interrupts.
89:                           http://www.microchip.com/forums/tm.aspx?m=479085
90:                  
91:                           Fixed issue with dual role mode when device run in polling
92:                           mode.  Interrupts were remaining enabled after the host mode
93:                           operation was complete.  This was incompatible with polling
94:                           mode operation.
95:                  
96:                           Changed how the bus sensing works.  In previous revisions it
97:                           was impossible to use the USBDeviceDetach to detach from the
98:                           bus if the bus voltage was still present.  This is now
99:                           possible.  It was also possible to move the device to the 
100:                          ATTACHED state in interrupt mode even if the bus voltage 
101:                          wasn't available.  This is now prohibited unless VBUS is
102:                          present.
103:                          
104:                          Improved error case handling when the host sends more OUT
105:                          bytes in a control transfer than the firmware was expecting
106:                          to receive (based on the size parameter when calling USBEP0Receive()).
107:                          
108:                          In the USBStdSetCfgHandler(), modified the code so the USBDeviceState
109:                          variable only gets updated to the CONFIGURED_STATE at the end of the 
110:                          function.  
111:                 
112:                   2.7a   Update to support the PIC18F47J53 A1 and later revision
113:                          devices.
114:                 
115:                          Fixed an error on 16-bit and 32-bit processors where a word access
116:                          could be performed on a byte pointer resulting in possible address
117:                          errors with odd aligned pointers.
118:                          
119:                   2.8    Several changes to the way control transfers get processed,
120:                          so as to support the ability to allow application/class specific
121:                          handler code to defer the status stage.  
122:                          Implemented USBCtrlEPAllowStatusStage() API function.
123:                          Implemented USBDeferStatusStage() API function (macro).
124:                          These changes also greatly relax the USBDeviceTasks() calling frequency 
125:                          requirement, while allowing USB class handlers more flexibility.
126:                          
127:                          Also implemented the following API functions and macros, for delaying 
128:                          the data stage of a control transfer (with data stage):
129:                          USBDeferINDataStage()
130:                          USBDeferOUTDataStage()
131:                          USBOUTDataStageDeferred()
132:                          USBINDataStageDeferred()
133:                          USBCtrlEPAllowDataStage()      
134:                          
135:                          Fixed USB reset event handler issue, where the USB stack would 
136:                          re-initialize global interrupt settings in the interrupt context, on 
137:                          PIC18 devices with the stack operated in USB_INTERRUPT mode.
138:                          
139:                          Fixed handling of SET/CLEAR FEATURE (endpoint halt) host requests.
140:                          Previous implementation would not always initialize endpoints correctly 
141:                          to DATA0 DTS state after a clear feature endpoint halt request, for 
142:                          all ping pong mode and usage scenarios.
143:                          
144:                    2.9   Fixed an issue with STALL handling behavior on non-EP0 endpoints, for 
145:                          PIC24 and PIC32 devices.  
146:                    		  
147:                    		 Fixed an issue where the ep_data_in[]/ep_data_out[] flags weren't 
148:                    		 getting re-initialized coincident with the hardware ping pong pointer 
149:                    		 reset during set configuration events.
150:                    		 
151:                    		 Implemented USBGetNextHandle() API function (actually a macro, defined
152:                    		 in usb_device.h).
153:                 
154:                    2.9d  Added build option for disabling DTS checking
155:                    
156:                    2.9f  Adding pragma for PIC18F97J94 Family BDT location.
157:                 ********************************************************************/
158:                 
159:                 /*----------------------------------------------------------------------------------
160:                 The USBDeviceTasks() function is responsible for detecting and processing various
161:                 USB bus events and host requests, such as those required for USB enumeration, when
162:                 the USB cable is first attached to the host.  This function is the main dispatcher
163:                 routine for the USB stack.
164:                 
165:                 Additional API functions and macros are also provided by the USB stack, which can be 
166:                 used to send/receive USB data to/from the host, among other things.  A full list 
167:                 of the available implemented functions/macros are provided in the 
168:                 "MCHPFSUSB Library Help".  For normal installations of the MCHPFSUSB Framework,
169:                 the USB API documentation can be found from:
170:                 
171:                 Start menu --> (All Programs) --> Microchip --> MCHPFSUSB vX.x --> Documents --> MCHPFSUSB Library Help
172:                 
173:                 Once the help file is opened, the API functions/macros are described in the following section:
174:                 Library Interface (API) --> Device/Peripheral --> Device Stack --> Interface Routines
175:                 Additional API functions may also be provided depending upon the specific USB device class
176:                 implemented, and these functions are also documented in the MCHPFSUSB Library Help.
177:                 
178:                 
179:                 If the USB stack is operated in "USB_POLLING" mode (user selectable option in 
180:                 usb_config.h), then the application firmware is reponsible for calling the 
181:                 USBDeviceTasks() function periodically.  If the USB stack is operated in the 
182:                 "USB_INTERRUPT" mode, then the application firmware does not have to directly 
183:                 call USBDeviceTasks(), as it will execute only when necessary as an interrupt handler.
184:                 
185:                 In order to properly operate a USB connection, and to correctly process and respond
186:                 to control transfers in the maximum time allowed by the USB specifications, the
187:                 USBDeviceTasks() function/interrupt handler must be allowed to execute in a timely
188:                 fashion.
189:                 
190:                 When the USB module is enabled, the USB cable is attached to the host, the USB bus
191:                 is not in the suspend state, and the USB stack is operated in the USB_POLLING mode 
192:                 with ping pong buffering enabled (at least) on EP0 OUT,  then the maximum allowed 
193:                 time between calls to the USBDeviceTasks() function needs to be:
194:                 
195:                 The faster of:
196:                 1.  Once per ~1.8ms, when USBDeviceState == ADR_PENDING_STATE
197:                 2.  Once per ~9.8ms, when USBDeviceState == (any other value other than ADR_PENDING_STATE)
198:                 3.  Fast enough to ensure the USTAT FIFO can never get full.  See additional explanation below.
199:                 
200:                 Additional details of the above timing limits are provided:
201:                 
202:                 Timing item #1: This parameter originates from the 2ms set address "recovery interval"
203:                 specification dictated by section "9.2.6.3 Set Address Processing" of the official 
204:                 USB 2.0 specifications.
205:                 
206:                 Timing item #2: This parameter originates from several "10 ms" criteria in the 
207:                 USB 2.0 specifications.  For example, reset recovery intervals, resume recovery 
208:                 intervals, suspend to actual current reduction, etc. have timing maximums of 10ms.
209:                 
210:                 Timing item #3: This is not a fixed X.X ms parameter, but depends on the  
211:                 transaction rate implemented by the application.  The USBDeviceTasks() function is
212:                 responsible for popping entries off the USTAT FIFO.  If the FIFO ever gets full,
213:                 then no further USB transactions are allowed to occur, until the firmware pops entries
214:                 off the FIFO.  In practice, this means the firmware should call USBDeviceTasks() at
215:                 a rate at least as fast as once every three times the USBTransferOnePacket() function
216:                 is called.  This ensures that the rate that USTAT FIFO entries are getting added to
217:                 the FIFO is lower than the rate that the entries are getting popped off the FIFO (the
218:                 USBDeviceTasks() function will pop up to 4 entries per call), which is a
219:                 necessary criteria to ensure the USTAT FIFO entries don't "pile up."  Calling
220:                 USBDeviceTasks() even more often, ex: >=1 to 1 ratio of USBDeviceTasks() to 
221:                 USBTransferOnePacket(), adds further protection against the USTAT FIFO getting full,
222:                 and is therefore recommended.
223:                 
224:                 When the USB stack is operated in USB_INTERRUPT mode, then the above timing 
225:                 parameters should be interpreted to be the longest allowed time that the USB 
226:                 interrupts may be masked/disabled for, before re-enabling the USB interrupts.
227:                 
228:                 Calling USBDeviceTasks() (or allowing USBDeviceTasks() to be called) more often 
229:                 will still have potential USB data rate speed and processing latency benefits.
230:                 It is also beneficial to call USBDeviceTasks() more often than theoretically 
231:                 required, since it has been observed that not all host/drivers/bios/hubs are 
232:                 100% consistently compliant with all timing parameters of the USB 2.0 specifications.
233:                 Therefore, in a USB_POLLING based application, it is still suggested to call 
234:                 USBDeviceTasks() as often as there are free CPU cycles.  This ensures best 
235:                 performance, along with best possible compatibility with all existing USB 
236:                 hosts/hubs (both those that are compliant and [partially] non-compliant).
237:                 
238:                 If ping pong buffering is not enabled on (at least) EP0 OUT, then it is required
239:                 to call (or allow to execute) USBDeviceTasks() much more frequently (ex: once 
240:                 per 100us, or preferrably faster).  Therefore, in all applications, it is 
241:                 normally recommended to select either the USB_PING_PONG__FULL_PING_PONG or 
242:                 USB_PING_PONG__EP0_OUT_ONLY mode (user option in usb_config.h), as these modes
243:                 allow for much more relaxed timing requirements, and therefore greater application
244:                 firmware design flexibility.
245:                 //----------------------------------------------------------------------------------*/
246:                 
247:                 /** INCLUDES *******************************************************/
248:                 #include "./USB/usb.h"
249:                 #include "HardwareProfile.h"
250:                 
251:                 #include "../USB/usb_device_local.h"
252:                 
253:                 
254:                 #if defined(USB_USE_MSD)
255:                     #include "./USB/usb_function_msd.h"
256:                 #endif
257:                 
258:                 #if !defined(USE_USB_BUS_SENSE_IO)
259:                     #undef USB_BUS_SENSE
260:                     #define USB_BUS_SENSE 1
261:                 #endif
262:                 
263:                 #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
264:                     #define _DTS_CHECKING_ENABLED 0
265:                 #else
266:                     #define _DTS_CHECKING_ENABLED _DTSEN
267:                 #endif
268:                 
269:                 /** DEFINITIONS ****************************************************/
270:                 
271:                 /** VARIABLES ******************************************************/
272:                 #if defined(__18CXX)
273:                     #pragma udata
274:                 #endif
275:                 
276:                 USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
277:                 USB_VOLATILE BYTE USBActiveConfiguration;
278:                 USB_VOLATILE BYTE USBAlternateInterface[USB_MAX_NUM_INT];
279:                 volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
280:                 volatile BDT_ENTRY *pBDTEntryEP0OutNext;
281:                 volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
282:                 volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
283:                 USB_VOLATILE BYTE shortPacketStatus;
284:                 USB_VOLATILE BYTE controlTransferState;
285:                 USB_VOLATILE IN_PIPE inPipes[1];
286:                 USB_VOLATILE OUT_PIPE outPipes[1];
287:                 USB_VOLATILE BYTE *pDst;
288:                 USB_VOLATILE BOOL RemoteWakeup;
289:                 USB_VOLATILE BOOL USBBusIsSuspended;
290:                 USB_VOLATILE USTAT_FIELDS USTATcopy;
291:                 USB_VOLATILE BYTE endpoint_number;
292:                 USB_VOLATILE BOOL BothEP0OutUOWNsSet;
293:                 USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
294:                 USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
295:                 USB_VOLATILE BYTE USBStatusStageTimeoutCounter;
296:                 volatile BOOL USBDeferStatusStagePacket;
297:                 volatile BOOL USBStatusStageEnabledFlag1;
298:                 volatile BOOL USBStatusStageEnabledFlag2;
299:                 volatile BOOL USBDeferINDataStagePackets;
300:                 volatile BOOL USBDeferOUTDataStagePackets;
301:                 
302:                 
303:                 /** USB FIXED LOCATION VARIABLES ***********************************/
304:                 #if defined(__18CXX)
305:                     #if defined(__18F14K50) || defined(__18F13K50) || defined(__18LF14K50) || defined(__18LF13K50)
306:                         #pragma udata USB_BDT=0x200     //See Linker Script, BDT in bank 2 on these devices - usb2:0x200-0x2FF(256-byte)
307:                     #elif defined(__18F47J53) || defined(__18F46J53) || defined(__18F27J53) || defined(__18F26J53) || defined(__18LF47J53) || defined(__18LF46J53) || defined(__18LF27J53) || defined(__18LF26J53)
308:                         #pragma udata USB_BDT=0xD00		//BDT in Bank 13 on these devices
309:                     #elif defined(__18F97J94) || defined(__18F87J94) || defined(__18F67J94) || defined(__18F96J94) || defined(__18F86J94) || defined(__18F66J94) || defined(__18F96J99) || defined(__18F95J94) || defined(__18F86J99) || defined(__18F85J94) || defined(__18F66J99) || defined(__18F65J94)
310:                         #pragma udata USB_BDT=0x100		//BDT in Bank 1 on these devices
311:                     #else
312:                         #pragma udata USB_BDT=0x400     //All other PIC18 devices place the BDT in usb4:0x400-0x4FF(256-byte)
313:                     #endif
314:                 #endif
315:                 
316:                 /********************************************************************
317:                  * Section A: Buffer Descriptor Table
318:                  * - 256 bytes max.  Actual size depends on number of endpoints enabled and 
319:                  *   the ping pong buffering mode.
320:                  * - USB_MAX_EP_NUMBER is defined in usb_config.h
321:                  *******************************************************************/
322:                 #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
323:                     volatile BDT_ENTRY BDT[(USB_MAX_EP_NUMBER + 1) * 2] __attribute__ ((aligned (512)));
324:                 #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
325:                     volatile BDT_ENTRY BDT[((USB_MAX_EP_NUMBER + 1) * 2)+1] __attribute__ ((aligned (512)));
326:                 #elif (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
327:                     volatile BDT_ENTRY BDT[(USB_MAX_EP_NUMBER + 1) * 4] __attribute__ ((aligned (512)));
328:                 #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
329:                     volatile BDT_ENTRY BDT[((USB_MAX_EP_NUMBER + 1) * 4)-2] __attribute__ ((aligned (512)));
330:                 #else
331:                     #error "No ping pong mode defined."
332:                 #endif
333:                 
334:                 /********************************************************************
335:                  * Section B: EP0 Buffer Space
336:                  *******************************************************************/
337:                 volatile CTRL_TRF_SETUP SetupPkt;           // 8-byte only
338:                 volatile BYTE CtrlTrfData[USB_EP0_BUFF_SIZE];
339:                 
340:                 /********************************************************************
341:                  * Section C: non-EP0 Buffer Space
342:                  *******************************************************************/
343:                 // Can provide compile time option to do software pingpong
344:                 #if defined(USB_USE_HID)
345:                     volatile unsigned char hid_report_out[HID_INT_OUT_EP_SIZE];
346:                     volatile unsigned char hid_report_in[HID_INT_IN_EP_SIZE];
347:                 #endif
348:                 
349:                 #if defined(USB_USE_MSD)
350:                 	//volatile far USB_MSD_CBW_CSW msd_cbw_csw;
351:                 	volatile USB_MSD_CBW msd_cbw;
352:                 	volatile USB_MSD_CSW msd_csw;
353:                 	//#pragma udata
354:                 
355:                 	#if defined(__18CXX)
356:                 		#pragma udata myMSD=MSD_BUFFER_ADDRESS
357:                 	#endif
358:                 	volatile char msd_buffer[512];
359:                 #endif
360:                 
361:                 #if defined(__18CXX)
362:                 #pragma udata
363:                 #endif
364:                 
365:                 ////Depricated in v2.2 - will be removed in a future revision
366:                 #if !defined(USB_USER_DEVICE_DESCRIPTOR)
367:                     //Device descriptor
368:                     extern ROM USB_DEVICE_DESCRIPTOR device_dsc;
369:                 #else
370:                     USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
371:                 #endif
372:                 
373:                 #if !defined(USB_USER_CONFIG_DESCRIPTOR)
374:                     //Array of configuration descriptors
375:                     extern ROM BYTE *ROM USB_CD_Ptr[];
376:                 #else
377:                     USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
378:                 #endif
379:                 
380:                 extern ROM BYTE *ROM USB_SD_Ptr[];
381:                 
382:                 /** DECLARATIONS ***************************************************/
383:                 #if defined(__18CXX)
384:                     #pragma code
385:                 #endif
386:                 
387:                 /** Macros *********************************************************/
388:                 
389:                 /** Function Prototypes ********************************************/
390:                 #ifdef __cplusplus
391:                 extern "C" {
392:                 #endif
393:                 //External
394:                 //This is the prototype for the required user event handler
395:                 BOOL USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, WORD size);
396:                 
397:                 //Internal Functions
398:                 static void USBCtrlEPService(void);
399:                 static void USBCtrlTrfSetupHandler(void);
400:                 static void USBCtrlTrfInHandler(void);
401:                 static void USBCheckStdRequest(void);
402:                 static void USBStdGetDscHandler(void);
403:                 static void USBCtrlEPServiceComplete(void);
404:                 static void USBCtrlTrfTxService(void);
405:                 static void USBCtrlTrfRxService(void);
406:                 static void USBStdSetCfgHandler(void);
407:                 static void USBStdGetStatusHandler(void);
408:                 static void USBStdFeatureReqHandler(void);
409:                 static void USBCtrlTrfOutHandler(void);
410:                 static void USBConfigureEndpoint(BYTE EPNum, BYTE direction);
411:                 static void USBWakeFromSuspend(void);
412:                 static void USBSuspend(void);
413:                 static void USBStallHandler(void);
414:                 
415:                 //static BOOL USBIsTxBusy(BYTE EPNumber);
416:                 //static void USBPut(BYTE EPNum, BYTE Data);
417:                 //static void USBEPService(void);
418:                 //static void USBProtocolResetHandler(void);
419:                 #ifdef __cplusplus
420:                 }
421:                 #endif
422:                 
423:                 /******************************************************************************/
424:                 /** Function Implementations *************************************************/
425:                 /******************************************************************************/
426:                 
427:                 /******************************************************************************/
428:                 /** Internal Macros *********************************************************/
429:                 /******************************************************************************/
430:                 
431:                 /****************************************************************************
432:                   Function:
433:                     void USBAdvancePingPongBuffer(BDT_ENTRY** buffer)
434:                 
435:                   Description:
436:                     This function will advance the passed pointer to the next buffer based on
437:                     the ping pong option setting.  This function should be used for EP1-EP15
438:                     only.  This function is not valid for EP0.
439:                 
440:                   Precondition:
441:                     None
442:                 
443:                   Parameters:
444:                     BDT_ENTRY** - pointer to the BDT_ENTRY pointer that you want to be advanced
445:                     to the next buffer state
446:                 
447:                   Return Values:
448:                     None
449:                 
450:                   Remarks:
451:                     None
452:                 
453:                   ***************************************************************************/
454:                 #define USBAdvancePingPongBuffer(buffer) ((BYTE_VAL*)buffer)->Val ^= USB_NEXT_PING_PONG;
455:                 #define USBHALPingPongSetToOdd(buffer)   {((BYTE_VAL*)buffer)->Val |= USB_NEXT_PING_PONG;}
456:                 #define USBHALPingPongSetToEven(buffer)  {((BYTE_VAL*)buffer)->Val &= ~USB_NEXT_PING_PONG;}
457:                 
458:                 
459:                 /******************************************************************************/
460:                 /** External API Functions ****************************************************/
461:                 /******************************************************************************/
462:                 
463:                 /**************************************************************************
464:                     Function:
465:                         void USBDeviceInit(void)
466:                     
467:                     Description:
468:                         This function initializes the device stack it in the default state. The
469:                         USB module will be completely reset including all of the internal
470:                         variables, registers, and interrupt flags.
471:                                 
472:                     Precondition:
473:                         This function must be called before any of the other USB Device
474:                         functions can be called, including USBDeviceTasks().
475:                         
476:                     Parameters:
477:                         None
478:                      
479:                     Return Values:
480:                         None
481:                         
482:                     Remarks:
483:                         None
484:                                                                           
485:                   ***************************************************************************/
486:                 void USBDeviceInit(void)
487:                 {
9D000020  27BDFFF0   ADDIU SP, SP, -16
9D000024  AFBE000C   SW S8, 12(SP)
9D000028  03A0F021   ADDU S8, SP, ZERO
488:                     BYTE i;
489:                 
490:                     USBDisableInterrupts();
9D00002C  3C02BF88   LUI V0, -16504
9D000030  3C030200   LUI V1, 512
9D000034  AC431074   SW V1, 4212(V0)
491:                 
492:                     // Clear all USB error flags
493:                     USBClearInterruptRegister(U1EIR);  
9D000038  3C02BF88   LUI V0, -16504
9D00003C  240300FF   ADDIU V1, ZERO, 255
9D000040  AC435220   SW V1, 21024(V0)
494:                        
495:                     // Clears all USB interrupts          
496:                     USBClearInterruptRegister(U1IR); 
9D000044  3C02BF88   LUI V0, -16504
9D000048  240300FF   ADDIU V1, ZERO, 255
9D00004C  AC435200   SW V1, 20992(V0)
497:                 
498:                     //Clear all of the endpoint control registers
499:                     U1EP0 = 0;
9D000050  3C02BF88   LUI V0, -16504
9D000054  AC405300   SW ZERO, 21248(V0)
500:                     DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
9D000058  3C02BF88   LUI V0, -16504
9D00005C  24425310   ADDIU V0, V0, 21264
9D000060  AFC20004   SW V0, 4(S8)
9D000064  A3C00001   SB ZERO, 1(S8)
9D000068  0B400024   J 0x9D000090
9D00006C  00000000   NOP
9D000070  8FC20004   LW V0, 4(S8)
9D000074  AC400000   SW ZERO, 0(V0)
9D000078  8FC20004   LW V0, 4(S8)
9D00007C  24420010   ADDIU V0, V0, 16
9D000080  AFC20004   SW V0, 4(S8)
9D000084  93C20001   LBU V0, 1(S8)
9D000088  24420001   ADDIU V0, V0, 1
9D00008C  A3C20001   SB V0, 1(S8)
9D000090  93C20001   LBU V0, 1(S8)
9D000094  1040FFF6   BEQ V0, ZERO, 0x9D000070
9D000098  00000000   NOP
501:                 
502:                     SetConfigurationOptions();
9D00009C  3C02BF88   LUI V0, -16504
9D0000A0  AC4052E0   SW ZERO, 21216(V0)
9D0000A4  3C02BF88   LUI V0, -16504
9D0000A8  2403009F   ADDIU V1, ZERO, 159
9D0000AC  AC435230   SW V1, 21040(V0)
9D0000B0  3C02BF88   LUI V0, -16504
9D0000B4  2403009F   ADDIU V1, ZERO, 159
9D0000B8  AC435210   SW V1, 21008(V0)
9D0000BC  3C02BF88   LUI V0, -16504
9D0000C0  8C425070   LW V0, 20592(V0)
9D0000C4  3043000F   ANDI V1, V0, 15
9D0000C8  3C02BF88   LUI V0, -16504
9D0000CC  AC435070   SW V1, 20592(V0)
9D0000D0  3C02BF88   LUI V0, -16504
9D0000D4  8C435070   LW V1, 20592(V0)
9D0000D8  3C02BF88   LUI V0, -16504
9D0000DC  AC435070   SW V1, 20592(V0)
503:                 
504:                     //power up the module (if not already powered)
505:                     USBPowerModule();
9D0000E0  3C03BF88   LUI V1, -16504
9D0000E4  8C625080   LW V0, 20608(V1)
9D0000E8  24040001   ADDIU A0, ZERO, 1
9D0000EC  7C820004   INS V0, A0, 0, 1
9D0000F0  AC625080   SW V0, 20608(V1)
506:                 
507:                     //set the address of the BDT (if applicable)
508:                     USBSetBDTAddress(BDT);
9D0000F4  3C02A000   LUI V0, -24576
9D0000F8  24420200   ADDIU V0, V0, 512
9D0000FC  7C42E000   EXT V0, V0, 0, 29
9D000100  00021E02   SRL V1, V0, 24
9D000104  3C02BF88   LUI V0, -16504
9D000108  AC4352D0   SW V1, 21200(V0)
9D00010C  3C02A000   LUI V0, -24576
9D000110  24420200   ADDIU V0, V0, 512
9D000114  7C42E000   EXT V0, V0, 0, 29
9D000118  00021C02   SRL V1, V0, 16
9D00011C  3C02BF88   LUI V0, -16504
9D000120  AC4352C0   SW V1, 21184(V0)
9D000124  3C02A000   LUI V0, -24576
9D000128  24420200   ADDIU V0, V0, 512
9D00012C  7C42E000   EXT V0, V0, 0, 29
9D000130  00021A02   SRL V1, V0, 8
9D000134  3C02BF88   LUI V0, -16504
9D000138  AC435270   SW V1, 21104(V0)
509:                 
510:                     //Clear all of the BDT entries
511:                     for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
9D00013C  A3C00000   SB ZERO, 0(S8)
9D000140  0B40005E   J 0x9D000178
9D000144  00000000   NOP
9D00016C  93C20000   LBU V0, 0(S8)
9D000170  24420001   ADDIU V0, V0, 1
9D000174  A3C20000   SB V0, 0(S8)
9D000178  93C20000   LBU V0, 0(S8)
9D00017C  2C420008   SLTIU V0, V0, 8
9D000180  1440FFF1   BNE V0, ZERO, 0x9D000148
9D000184  00000000   NOP
512:                     {
513:                         BDT[i].Val = 0x00;
9D000148  93C30000   LBU V1, 0(S8)
9D00014C  3C02A000   LUI V0, -24576
9D000150  000318C0   SLL V1, V1, 3
9D000154  24420200   ADDIU V0, V0, 512
9D000158  00621021   ADDU V0, V1, V0
9D00015C  00002021   ADDU A0, ZERO, ZERO
9D000160  00002821   ADDU A1, ZERO, ZERO
9D000164  AC440000   SW A0, 0(V0)
9D000168  AC450004   SW A1, 4(V0)
514:                     }
515:                 
516:                     // Assert reset request to all of the Ping Pong buffer pointers
517:                     USBPingPongBufferReset = 1;                    
9D000188  3C03BF88   LUI V1, -16504
9D00018C  8C625250   LW V0, 21072(V1)
9D000190  24040001   ADDIU A0, ZERO, 1
9D000194  7C820844   INS V0, A0, 1, 1
9D000198  AC625250   SW V0, 21072(V1)
518:                 
519:                     // Reset to default address
520:                     U1ADDR = 0x00;                   
9D00019C  3C02BF88   LUI V0, -16504
9D0001A0  AC405260   SW ZERO, 21088(V0)
521:                 
522:                     // Make sure packet processing is enabled
523:                     USBPacketDisable = 0;           
9D0001A4  3C03BF88   LUI V1, -16504
9D0001A8  8C625250   LW V0, 21072(V1)
9D0001AC  7C022944   INS V0, ZERO, 5, 1
9D0001B0  AC625250   SW V0, 21072(V1)
524:                 
525:                     //Stop trying to reset ping pong buffer pointers
526:                     USBPingPongBufferReset = 0;
9D0001B4  3C03BF88   LUI V1, -16504
9D0001B8  8C625250   LW V0, 21072(V1)
9D0001BC  7C020844   INS V0, ZERO, 1, 1
9D0001C0  AC625250   SW V0, 21072(V1)
527:                 
528:                     // Flush any pending transactions
529:                     while(USBTransactionCompleteIF == 1)      
9D0001C4  0B400081   J 0x9D000204
9D0001C8  00000000   NOP
9D000204  3C02BF88   LUI V0, -16504
9D000208  8C425200   LW V0, 20992(V0)
9D00020C  30420008   ANDI V0, V0, 8
9D000210  1440FFEE   BNE V0, ZERO, 0x9D0001CC
9D000214  00000000   NOP
530:                     {
531:                         USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
9D0001CC  3C02BF88   LUI V0, -16504
9D0001D0  24030008   ADDIU V1, ZERO, 8
9D0001D4  AC435200   SW V1, 20992(V0)
532:                         //Initialize USB stack software state variables
533:                         inPipes[0].info.Val = 0;
9D0001D8  3C02A000   LUI V0, -24576
9D0001DC  244202C0   ADDIU V0, V0, 704
9D0001E0  A0400004   SB ZERO, 4(V0)
534:                         outPipes[0].info.Val = 0;
9D0001E4  3C02A000   LUI V0, -24576
9D0001E8  24420310   ADDIU V0, V0, 784
9D0001EC  A0400004   SB ZERO, 4(V0)
535:                         outPipes[0].wCount.Val = 0;
9D0001F0  3C02A000   LUI V0, -24576
9D0001F4  24430310   ADDIU V1, V0, 784
9D0001F8  8C620004   LW V0, 4(V1)
9D0001FC  7C02BA04   INS V0, ZERO, 8, 16
9D000200  AC620004   SW V0, 4(V1)
536:                     }
537:                 
538:                     //Set flags to TRUE, so the USBCtrlEPAllowStatusStage() function knows not to
539:                     //try and arm a status stage, even before the first control transfer starts.
540:                     USBStatusStageEnabledFlag1 = TRUE;  
9D000218  24020001   ADDIU V0, ZERO, 1
9D00021C  AF82804C   SW V0, -32692(GP)
541:                     USBStatusStageEnabledFlag2 = TRUE;
9D000220  24020001   ADDIU V0, ZERO, 1
9D000224  AF828050   SW V0, -32688(GP)
542:                     //Initialize other flags
543:                     USBDeferINDataStagePackets = FALSE;
9D000228  AF808030   SW ZERO, -32720(GP)
544:                     USBDeferOUTDataStagePackets = FALSE;
9D00022C  AF808034   SW ZERO, -32716(GP)
545:                     USBBusIsSuspended = FALSE;
9D000230  AF808064   SW ZERO, -32668(GP)
546:                 
547:                 	//Initialize all pBDTEntryIn[] and pBDTEntryOut[]
548:                 	//pointers to NULL, so they don't get used inadvertently.  
549:                 	for(i = 0; i < (BYTE)(USB_MAX_EP_NUMBER+1u); i++)
9D000234  A3C00000   SB ZERO, 0(S8)
9D000238  0B4000A5   J 0x9D000294
9D00023C  00000000   NOP
9D000288  93C20000   LBU V0, 0(S8)
9D00028C  24420001   ADDIU V0, V0, 1
9D000290  A3C20000   SB V0, 0(S8)
9D000294  93C20000   LBU V0, 0(S8)
9D000298  2C420002   SLTIU V0, V0, 2
9D00029C  1440FFE8   BNE V0, ZERO, 0x9D000240
9D0002A0  00000000   NOP
550:                 	{
551:                 		pBDTEntryIn[i] = 0u;
9D000240  93C20000   LBU V0, 0(S8)
9D000244  00021880   SLL V1, V0, 2
9D000248  27828040   ADDIU V0, GP, -32704
9D00024C  00621021   ADDU V0, V1, V0
9D000250  AC400000   SW ZERO, 0(V0)
552:                 		pBDTEntryOut[i] = 0u;		
9D000254  93C20000   LBU V0, 0(S8)
9D000258  00021880   SLL V1, V0, 2
9D00025C  27828054   ADDIU V0, GP, -32684
9D000260  00621021   ADDU V0, V1, V0
9D000264  AC400000   SW ZERO, 0(V0)
553:                 		ep_data_in[i].Val = 0u;
9D000268  93C30000   LBU V1, 0(S8)
9D00026C  27828074   ADDIU V0, GP, -32652
9D000270  00621021   ADDU V0, V1, V0
9D000274  A0400000   SB ZERO, 0(V0)
554:                         ep_data_out[i].Val = 0u;
9D000278  93C30000   LBU V1, 0(S8)
9D00027C  27828048   ADDIU V0, GP, -32696
9D000280  00621021   ADDU V0, V1, V0
9D000284  A0400000   SB ZERO, 0(V0)
555:                 	}
556:                 
557:                     //Get ready for the first packet
558:                     pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
9D0002A4  3C02A000   LUI V0, -24576
9D0002A8  24420210   ADDIU V0, V0, 528
9D0002AC  AF828040   SW V0, -32704(GP)
559:                     // Initialize EP0 as a Ctrl EP
560:                     U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
9D0002B0  3C02BF88   LUI V0, -16504
9D0002B4  2403000D   ADDIU V1, ZERO, 13
9D0002B8  AC435300   SW V1, 21248(V0)
561:                 	//Prepare for the first SETUP on EP0 OUT
562:                     BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
9D0002BC  2782806C   ADDIU V0, GP, -32660
9D0002C0  7C43E000   EXT V1, V0, 0, 29
9D0002C4  3C02A000   LUI V0, -24576
9D0002C8  24420200   ADDIU V0, V0, 512
9D0002CC  AC430004   SW V1, 4(V0)
563:                     BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
9D0002D0  3C03A000   LUI V1, -24576
9D0002D4  8C620200   LW V0, 512(V1)
9D0002D8  24040040   ADDIU A0, ZERO, 64
9D0002DC  7C82CC04   INS V0, A0, 16, 10
9D0002E0  AC620200   SW V0, 512(V1)
564:                     BDT[EP0_OUT_EVEN].STAT.Val = _USIE|_DAT0|_BSTALL;
9D0002E4  3C02A000   LUI V0, -24576
9D0002E8  24030084   ADDIU V1, ZERO, 132
9D0002EC  A4430200   SH V1, 512(V0)
565:                 
566:                     // Clear active configuration
567:                     USBActiveConfiguration = 0;     
9D0002F0  A380807C   SB ZERO, -32644(GP)
568:                 
569:                     //Indicate that we are now in the detached state        
570:                     USBDeviceState = DETACHED_STATE;
9D0002F4  AF808038   SW ZERO, -32712(GP)
571:                 }
9D0002F8  03C0E821   ADDU SP, S8, ZERO
9D0002FC  8FBE000C   LW S8, 12(SP)
9D000300  27BD0010   ADDIU SP, SP, 16
9D000304  03E00008   JR RA
9D000308  00000000   NOP
572:                 
573:                 /**************************************************************************
574:                   Function:
575:                         void USBDeviceTasks(void)
576:                     
577:                   Summary:
578:                     This function is the main state machine/transaction handler of the USB 
579:                     device side stack.  When the USB stack is operated in "USB_POLLING" mode 
580:                     (usb_config.h user option) the USBDeviceTasks() function should be called 
581:                     periodically to receive and transmit packets through the stack. This 
582:                     function also takes care of control transfers associated with the USB 
583:                     enumeration process, and detecting various USB events (such as suspend).  
584:                     This function should be called at least once every 1.8ms during the USB 
585:                     enumeration process. After the enumeration process is complete (which can 
586:                     be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
587:                     USBDeviceTasks() handler may be called the faster of: either once 
588:                     every 9.8ms, or as often as needed to make sure that the hardware USTAT 
589:                     FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
590:                     a minimum rate of either the frequency that USBTransferOnePacket() gets 
591:                     called, or, once/1.8ms, whichever is faster.  See the inline code comments 
592:                     near the top of usb_device.c for more details about minimum timing 
593:                     requirements when calling USBDeviceTasks().
594:                     
595:                     When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
596:                     to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
597:                     mode, the USBDeviceTasks() handler only needs to execute when a USB 
598:                     interrupt occurs, and therefore only needs to be called from the interrupt 
599:                     context.
600:                 
601:                   Description:
602:                     This function is the main state machine/transaction handler of the USB 
603:                     device side stack.  When the USB stack is operated in "USB_POLLING" mode 
604:                     (usb_config.h user option) the USBDeviceTasks() function should be called 
605:                     periodically to receive and transmit packets through the stack. This 
606:                     function also takes care of control transfers associated with the USB 
607:                     enumeration process, and detecting various USB events (such as suspend).  
608:                     This function should be called at least once every 1.8ms during the USB 
609:                     enumeration process. After the enumeration process is complete (which can 
610:                     be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
611:                     USBDeviceTasks() handler may be called the faster of: either once 
612:                     every 9.8ms, or as often as needed to make sure that the hardware USTAT 
613:                     FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
614:                     a minimum rate of either the frequency that USBTransferOnePacket() gets 
615:                     called, or, once/1.8ms, whichever is faster.  See the inline code comments 
616:                     near the top of usb_device.c for more details about minimum timing 
617:                     requirements when calling USBDeviceTasks().
618:                     
619:                     When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
620:                     to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
621:                     mode, the USBDeviceTasks() handler only needs to execute when a USB 
622:                     interrupt occurs, and therefore only needs to be called from the interrupt 
623:                     context.
624:                 
625:                     Typical usage:
626:                     <code>
627:                     void main(void)
628:                     {
629:                         USBDeviceInit();
630:                         while(1)
631:                         {
632:                             USBDeviceTasks(); //Takes care of enumeration and other USB events
633:                             if((USBGetDeviceState() /< CONFIGURED_STATE) ||
634:                                (USBIsDeviceSuspended() == TRUE))
635:                             {
636:                                 //Either the device is not configured or we are suspended,
637:                                 // so we don't want to execute any USB related application code
638:                                 continue;   //go back to the top of the while loop
639:                             }
640:                             else
641:                             {
642:                                 //Otherwise we are free to run USB and non-USB related user 
643:                                 //application code.
644:                                 UserApplication();
645:                             }
646:                         }
647:                     }
648:                     </code>
649:                 
650:                   Precondition:
651:                     Make sure the USBDeviceInit() function has been called prior to calling
652:                     USBDeviceTasks() for the first time.
653:                   Remarks:
654:                     USBDeviceTasks() does not need to be called while in the USB suspend mode, 
655:                     if the user application firmware in the USBCBSuspend() callback function
656:                     enables the ACTVIF USB interrupt source and put the microcontroller into 
657:                     sleep mode.  If the application firmware decides not to sleep the 
658:                     microcontroller core during USB suspend (ex: continues running at full 
659:                     frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
660:                     function must still be called periodically, at a rate frequent enough to 
661:                     ensure the 10ms resume recovery interval USB specification is met.  Assuming
662:                     a worst case primary oscillator and PLL start up time of <5ms, then 
663:                     USBDeviceTasks() should be called once every 5ms in this scenario.
664:                    
665:                     When the USB cable is detached, or the USB host is not actively powering 
666:                     the VBUS line to +5V nominal, the application firmware does not always have 
667:                     to call USBDeviceTasks() frequently, as no USB activity will be taking 
668:                     place.  However, if USBDeviceTasks() is not called regularly, some 
669:                     alternative means of promptly detecting when VBUS is powered (indicating 
670:                     host attachment), or not powered (host powered down or USB cable unplugged)
671:                     is still needed.  For self or dual self/bus powered USB applications, see 
672:                     the USBDeviceAttach() and USBDeviceDetach() API documentation for additional 
673:                     considerations.
674:                                      
675:                   **************************************************************************/
676:                 
677:                 #if defined(USB_INTERRUPT) 
678:                   #if defined(__18CXX)
679:                     void USBDeviceTasks(void)
680:                   #elif defined(__C30__) || defined __XC16__
681:                     void __attribute__((interrupt,auto_psv)) _USB1Interrupt()
682:                   #elif defined(__PIC32MX__)
683:                    // void __attribute__((interrupt(),vector(_USB_1_VECTOR))) _USB1Interrupt( void ) 
684:                      void __attribute__((nomips16)) __attribute__((interrupt(),vector(_USB_1_VECTOR))) _USB1Interrupt( void ) 
685:                   #endif
686:                 #else
687:                 void USBDeviceTasks(void)
688:                 #endif
689:                 {
9D00030C  27BDFFE0   ADDIU SP, SP, -32
9D000310  AFBF001C   SW RA, 28(SP)
9D000314  AFBE0018   SW S8, 24(SP)
9D000318  03A0F021   ADDU S8, SP, ZERO
690:                     BYTE i;
691:                 
692:                 #ifdef USB_SUPPORT_OTG
693:                     //SRP Time Out Check
694:                     if (USBOTGSRPIsReady())
695:                     {
696:                         if (USBT1MSECIF && USBT1MSECIE)
697:                         {
698:                             if (USBOTGGetSRPTimeOutFlag())
699:                             {
700:                                 if (USBOTGIsSRPTimeOutExpired())
701:                                 {
702:                                     USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
703:                                 }       
704:                             }
705:                 
706:                             //Clear Interrupt Flag
707:                             USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
708:                         }
709:                     }
710:                 #endif
711:                 
712:                     #if defined(USB_POLLING)
713:                     //If the interrupt option is selected then the customer is required
714:                     //  to notify the stack when the device is attached or removed from the
715:                     //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
716:                     if (USB_BUS_SENSE != 1)
717:                     {
718:                          // Disable module & detach from bus
719:                          U1CON = 0;             
720:                 
721:                          // Mask all USB interrupts              
722:                          U1IE = 0;          
723:                 
724:                          //Move to the detached state                  
725:                          USBDeviceState = DETACHED_STATE;
726:                 
727:                          #ifdef  USB_SUPPORT_OTG    
728:                              //Disable D+ Pullup
729:                              U1OTGCONbits.DPPULUP = 0;
730:                 
731:                              //Disable HNP
732:                              USBOTGDisableHnp();
733:                 
734:                              //Deactivate HNP
735:                              USBOTGDeactivateHnp();
736:                              
737:                              //If ID Pin Changed State
738:                              if (USBIDIF && USBIDIE)
739:                              {  
740:                                  //Re-detect & Initialize
741:                                   USBOTGInitialize();
742:                 
743:                                   //Clear ID Interrupt Flag
744:                                   USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
745:                              }
746:                          #endif
747:                 
748:                          #if defined __C30__ || defined __XC16__
749:                              //USBClearInterruptFlag(U1OTGIR, 3); 
750:                          #endif
751:                             //return so that we don't go through the rest of 
752:                             //the state machine
753:                          USBClearUSBInterrupt();
754:                          return;
755:                     }
756:                 
757:                 	#ifdef USB_SUPPORT_OTG
758:                     //If Session Is Started Then
759:                     else
760:                 	{
761:                         //If SRP Is Ready
762:                         if (USBOTGSRPIsReady())
763:                         {   
764:                             //Clear SRPReady
765:                             USBOTGClearSRPReady();
766:                 
767:                             //Clear SRP Timeout Flag
768:                             USBOTGClearSRPTimeOutFlag();
769:                 
770:                             //Indicate Session Started
771:                             UART2PrintString( "/r/n***** USB OTG B Event - Session Started  *****/r/n" );
772:                         }
773:                     }
774:                 	#endif	//#ifdef USB_SUPPORT_OTG
775:                 
776:                     //if we are in the detached state
777:                     if(USBDeviceState == DETACHED_STATE)
9D00031C  8F828038   LW V0, -32712(GP)
9D000320  14400024   BNE V0, ZERO, 0x9D0003B4
9D000324  00000000   NOP
778:                     {
779:                 	    //Initialize register to known value
780:                         U1CON = 0;                          
9D000328  3C02BF88   LUI V0, -16504
9D00032C  AC405250   SW ZERO, 21072(V0)
781:                 
782:                         // Mask all USB interrupts
783:                         U1IE = 0;                                
9D000330  3C02BF88   LUI V0, -16504
9D000334  AC405210   SW ZERO, 21008(V0)
784:                 
785:                         //Enable/set things like: pull ups, full/low-speed mode, 
786:                         //set the ping pong mode, and set internal transceiver
787:                         SetConfigurationOptions();
9D000338  3C02BF88   LUI V0, -16504
9D00033C  AC4052E0   SW ZERO, 21216(V0)
9D000340  3C02BF88   LUI V0, -16504
9D000344  2403009F   ADDIU V1, ZERO, 159
9D000348  AC435230   SW V1, 21040(V0)
9D00034C  3C02BF88   LUI V0, -16504
9D000350  2403009F   ADDIU V1, ZERO, 159
9D000354  AC435210   SW V1, 21008(V0)
9D000358  3C02BF88   LUI V0, -16504
9D00035C  8C425070   LW V0, 20592(V0)
9D000360  3043000F   ANDI V1, V0, 15
9D000364  3C02BF88   LUI V0, -16504
9D000368  AC435070   SW V1, 20592(V0)
9D00036C  3C02BF88   LUI V0, -16504
9D000370  8C435070   LW V1, 20592(V0)
9D000374  3C02BF88   LUI V0, -16504
9D000378  AC435070   SW V1, 20592(V0)
788:                 
789:                         // Enable module & attach to bus
790:                         while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
9D00037C  0B4000E6   J 0x9D000398
9D000380  00000000   NOP
9D000384  3C03BF88   LUI V1, -16504
9D000388  8C625250   LW V0, 21072(V1)
9D00038C  24040001   ADDIU A0, ZERO, 1
9D000390  7C820004   INS V0, A0, 0, 1
9D000394  AC625250   SW V0, 21072(V1)
9D000398  3C02BF88   LUI V0, -16504
9D00039C  8C425250   LW V0, 21072(V0)
9D0003A0  30420001   ANDI V0, V0, 1
9D0003A4  1040FFF7   BEQ V0, ZERO, 0x9D000384
9D0003A8  00000000   NOP
791:                 
792:                         //moved to the attached state
793:                         USBDeviceState = ATTACHED_STATE;
9D0003AC  24020001   ADDIU V0, ZERO, 1
9D0003B0  AF828038   SW V0, -32712(GP)
794:                 
795:                         #ifdef  USB_SUPPORT_OTG
796:                             U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
797:                         #endif
798:                     }
799:                 	#endif  //#if defined(USB_POLLING)
800:                 
801:                     if(USBDeviceState == ATTACHED_STATE)
9D0003B4  8F838038   LW V1, -32712(GP)
9D0003B8  24020001   ADDIU V0, ZERO, 1
9D0003BC  14620012   BNE V1, V0, 0x9D000408
9D0003C0  00000000   NOP
802:                     {
803:                         /*
804:                          * After enabling the USB module, it takes some time for the
805:                          * voltage on the D+ or D- line to rise high enough to get out
806:                          * of the SE0 condition. The USB Reset interrupt should not be
807:                          * unmasked until the SE0 condition is cleared. This helps
808:                          * prevent the firmware from misinterpreting this unique event
809:                          * as a USB bus reset from the USB host.
810:                          */
811:                 
812:                         if(!USBSE0Event)
813:                         {
814:                             USBClearInterruptRegister(U1IR);// Clear all USB interrupts
9D0003C4  3C02BF88   LUI V0, -16504
9D0003C8  240300FF   ADDIU V1, ZERO, 255
9D0003CC  AC435200   SW V1, 20992(V0)
815:                             #if defined(USB_POLLING)
816:                                 U1IE=0;                        // Mask all USB interrupts
9D0003D0  3C02BF88   LUI V0, -16504
9D0003D4  AC405210   SW ZERO, 21008(V0)
817:                             #endif
818:                             USBResetIE = 1;             // Unmask RESET interrupt
9D0003D8  3C03BF88   LUI V1, -16504
9D0003DC  8C625210   LW V0, 21008(V1)
9D0003E0  24040001   ADDIU A0, ZERO, 1
9D0003E4  7C820004   INS V0, A0, 0, 1
9D0003E8  AC625210   SW V0, 21008(V1)
819:                             USBIdleIE = 1;             // Unmask IDLE interrupt
9D0003EC  3C03BF88   LUI V1, -16504
9D0003F0  8C625210   LW V0, 21008(V1)
9D0003F4  24040001   ADDIU A0, ZERO, 1
9D0003F8  7C822104   INS V0, A0, 4, 1
9D0003FC  AC625210   SW V0, 21008(V1)
820:                             USBDeviceState = POWERED_STATE;
9D000400  24020002   ADDIU V0, ZERO, 2
9D000404  AF828038   SW V0, -32712(GP)
821:                         }
822:                     }
823:                 
824:                     #ifdef  USB_SUPPORT_OTG
825:                         //If ID Pin Changed State
826:                         if (USBIDIF && USBIDIE)
827:                         {  
828:                             //Re-detect & Initialize
829:                             USBOTGInitialize();
830:                 
831:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
832:                         }
833:                     #endif
834:                 
835:                     /*
836:                      * Task A: Service USB Activity Interrupt
837:                      */
838:                     if(USBActivityIF && USBActivityIE)
9D000408  3C02BF88   LUI V0, -16504
9D00040C  8C425040   LW V0, 20544(V0)
9D000410  30420010   ANDI V0, V0, 16
9D000414  1040000B   BEQ V0, ZERO, 0x9D000444
9D000418  00000000   NOP
9D00041C  3C02BF88   LUI V0, -16504
9D000420  8C425050   LW V0, 20560(V0)
9D000424  30420010   ANDI V0, V0, 16
9D000428  10400006   BEQ V0, ZERO, 0x9D000444
9D00042C  00000000   NOP
839:                     {
840:                         USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
9D000430  3C02BF88   LUI V0, -16504
9D000434  24030010   ADDIU V1, ZERO, 16
9D000438  AC435040   SW V1, 20544(V0)
841:                         #if defined(USB_SUPPORT_OTG)
842:                             U1OTGIR = 0x10;        
843:                         #else
844:                             USBWakeFromSuspend();
9D00043C  0F4008EC   JAL 0x9D0023B0
9D000440  00000000   NOP
845:                         #endif
846:                     }
847:                 
848:                     /*
849:                      * Pointless to continue servicing if the device is in suspend mode.
850:                      */
851:                     if(USBSuspendControl==1)
9D000444  3C02BF88   LUI V0, -16504
9D000448  8C425080   LW V0, 20608(V0)
9D00044C  30420002   ANDI V0, V0, 2
9D000450  10400006   BEQ V0, ZERO, 0x9D00046C
9D000454  00000000   NOP
852:                     {
853:                         USBClearUSBInterrupt();
9D000458  2404003F   ADDIU A0, ZERO, 63
9D00045C  77401606   JALX INTClearFlag
9D000460  00000000   NOP
854:                         return;
9D000464  0B4001E0   J 0x9D000780
9D000468  00000000   NOP
855:                     }
856:                 
857:                     /*
858:                      * Task B: Service USB Bus Reset Interrupt.
859:                      * When bus reset is received during suspend, ACTVIF will be set first,
860:                      * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
861:                      * This is why URSTIF is checked after ACTVIF.
862:                      *
863:                      * The USB reset flag is masked when the USB state is in
864:                      * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
865:                      * cause a USB reset event during these two states.
866:                      */
867:                     if(USBResetIF && USBResetIE)
9D00046C  3C02BF88   LUI V0, -16504
9D000470  8C425200   LW V0, 20992(V0)
9D000474  30420001   ANDI V0, V0, 1
9D000478  1040000D   BEQ V0, ZERO, 0x9D0004B0
9D00047C  00000000   NOP
9D000480  3C02BF88   LUI V0, -16504
9D000484  8C425210   LW V0, 21008(V0)
9D000488  30420001   ANDI V0, V0, 1
9D00048C  10400008   BEQ V0, ZERO, 0x9D0004B0
9D000490  00000000   NOP
868:                     {
869:                         USBDeviceInit();
9D000494  0F400008   JAL USBDeviceInit
9D000498  00000000   NOP
870:                 
871:                         //Re-enable the interrupts since the USBDeviceInit() function will
872:                         //  disable them.  This will do nothing in a polling setup
873:                         USBUnmaskInterrupts();
874:                 
875:                         USBDeviceState = DEFAULT_STATE;
9D00049C  24020004   ADDIU V0, ZERO, 4
9D0004A0  AF828038   SW V0, -32712(GP)
876:                 
877:                         #ifdef USB_SUPPORT_OTG
878:                              //Disable HNP
879:                              USBOTGDisableHnp();
880:                 
881:                              //Deactivate HNP
882:                              USBOTGDeactivateHnp();
883:                         #endif
884:                 
885:                         USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
9D0004A4  3C02BF88   LUI V0, -16504
9D0004A8  24030001   ADDIU V1, ZERO, 1
9D0004AC  AC435200   SW V1, 20992(V0)
886:                     }
887:                 
888:                     /*
889:                      * Task C: Service other USB interrupts
890:                      */
891:                     if(USBIdleIF && USBIdleIE)
9D0004B0  3C02BF88   LUI V0, -16504
9D0004B4  8C425200   LW V0, 20992(V0)
9D0004B8  30420010   ANDI V0, V0, 16
9D0004BC  1040000B   BEQ V0, ZERO, 0x9D0004EC
9D0004C0  00000000   NOP
9D0004C4  3C02BF88   LUI V0, -16504
9D0004C8  8C425210   LW V0, 21008(V0)
9D0004CC  30420010   ANDI V0, V0, 16
9D0004D0  10400006   BEQ V0, ZERO, 0x9D0004EC
9D0004D4  00000000   NOP
892:                     { 
893:                         #ifdef  USB_SUPPORT_OTG 
894:                             //If Suspended, Try to switch to Host
895:                             USBOTGSelectRole(ROLE_HOST);
896:                         #else
897:                             USBSuspend();
9D0004D8  0F4008D3   JAL 0x9D00234C
9D0004DC  00000000   NOP
898:                         #endif
899:                         
900:                         USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
9D0004E0  3C02BF88   LUI V0, -16504
9D0004E4  24030010   ADDIU V1, ZERO, 16
9D0004E8  AC435200   SW V1, 20992(V0)
901:                     }
902:                 
903:                     if(USBSOFIF)
9D0004EC  3C02BF88   LUI V0, -16504
9D0004F0  8C425200   LW V0, 20992(V0)
9D0004F4  30420004   ANDI V0, V0, 4
9D0004F8  1040001A   BEQ V0, ZERO, 0x9D000564
9D0004FC  00000000   NOP
904:                     {
905:                         if(USBSOFIE)
9D000500  3C02BF88   LUI V0, -16504
9D000504  8C425210   LW V0, 21008(V0)
9D000508  30420004   ANDI V0, V0, 4
9D00050C  10400006   BEQ V0, ZERO, 0x9D000528
9D000510  00000000   NOP
906:                         {
907:                             USB_SOF_HANDLER(EVENT_SOF,0,1);
9D000514  24040073   ADDIU A0, ZERO, 115
9D000518  00002821   ADDU A1, ZERO, ZERO
9D00051C  24060001   ADDIU A2, ZERO, 1
9D000520  0F401375   JAL USER_USB_CALLBACK_EVENT_HANDLER
9D000524  00000000   NOP
908:                         }    
909:                         USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
9D000528  3C02BF88   LUI V0, -16504
9D00052C  24030004   ADDIU V1, ZERO, 4
9D000530  AC435200   SW V1, 20992(V0)
910:                         
911:                         #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
912:                             //Supporting this feature requires a 1ms timebase for keeping track of the timeout interval.
913:                             #if(USB_SPEED_OPTION == USB_LOW_SPEED)
914:                                 #warning "Double click this message.  See inline code comments."
915:                                 //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
916:                                 //not strictly needed in all applications (ex: those that never call 
917:                                 //USBDeferStatusStage() and don't use host to device (OUT) control
918:                                 //transfers with data stage).  
919:                                 //However, if this feature is enabled and used, it requires a timer 
920:                                 //(preferrably 1ms) to decrement the USBStatusStageTimeoutCounter.  
921:                                 //In USB Full Speed applications, the host sends Start-of-Frame (SOF) 
922:                                 //packets at a 1ms rate, which generates SOFIF interrupts.
923:                                 //These interrupts can be used to decrement USBStatusStageTimeoutCounter as shown 
924:                                 //below.  However, the host does not send SOF packets to Low Speed devices.  
925:                                 //Therefore, some other method  (ex: using a general purpose microcontroller 
926:                                 //timer, such as Timer0) needs to be implemented to call and execute the below code
927:                                 //at a once/1ms rate, in a low speed USB application.
928:                                 //Note: Pre-condition to executing the below code: USBDeviceInit() should have
929:                                 //been called at least once (since the last microcontroller reset/power up), 
930:                                 //prior to executing the below code.
931:                             #endif
932:                             
933:                             //Decrement our status stage counter.
934:                             if(USBStatusStageTimeoutCounter != 0u)
9D000534  93828068   LBU V0, -32664(GP)
9D000538  10400005   BEQ V0, ZERO, 0x9D000550
9D00053C  00000000   NOP
935:                             {
936:                                 USBStatusStageTimeoutCounter--;
9D000540  93828068   LBU V0, -32664(GP)
9D000544  2442FFFF   ADDIU V0, V0, -1
9D000548  304200FF   ANDI V0, V0, 255
9D00054C  A3828068   SB V0, -32664(GP)
937:                             }
938:                             //Check if too much time has elapsed since progress was made in 
939:                             //processing the control transfer, without arming the status stage.  
940:                             //If so, auto-arm the status stage to ensure that the control 
941:                             //transfer can [eventually] complete, within the timing limits
942:                             //dictated by section 9.2.6 of the official USB 2.0 specifications.
943:                             if(USBStatusStageTimeoutCounter == 0)
9D000550  93828068   LBU V0, -32664(GP)
9D000554  14400003   BNE V0, ZERO, 0x9D000564
9D000558  00000000   NOP
944:                             {
945:                                 USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
9D00055C  0F40042F   JAL USBCtrlEPAllowStatusStage
9D000560  00000000   NOP
946:                             } 
947:                         #endif
948:                     }
949:                 
950:                     if(USBStallIF && USBStallIE)
9D000564  3C02BF88   LUI V0, -16504
9D000568  8C425200   LW V0, 20992(V0)
9D00056C  30420080   ANDI V0, V0, 128
9D000570  10400008   BEQ V0, ZERO, 0x9D000594
9D000574  00000000   NOP
9D000578  3C02BF88   LUI V0, -16504
9D00057C  8C425210   LW V0, 21008(V0)
9D000580  30420080   ANDI V0, V0, 128
9D000584  10400003   BEQ V0, ZERO, 0x9D000594
9D000588  00000000   NOP
951:                     {
952:                         USBStallHandler();
9D00058C  0F40089F   JAL 0x9D00227C
9D000590  00000000   NOP
953:                     }
954:                 
955:                     if(USBErrorIF && USBErrorIE)
9D000594  3C02BF88   LUI V0, -16504
9D000598  8C425200   LW V0, 20992(V0)
9D00059C  30420002   ANDI V0, V0, 2
9D0005A0  10400012   BEQ V0, ZERO, 0x9D0005EC
9D0005A4  00000000   NOP
9D0005A8  3C02BF88   LUI V0, -16504
9D0005AC  8C425210   LW V0, 21008(V0)
9D0005B0  30420002   ANDI V0, V0, 2
9D0005B4  1040000D   BEQ V0, ZERO, 0x9D0005EC
9D0005B8  00000000   NOP
956:                     {
957:                         USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
9D0005BC  3C027FFF   LUI V0, 32767
9D0005C0  3444FFFF   ORI A0, V0, -1
9D0005C4  00002821   ADDU A1, ZERO, ZERO
9D0005C8  24060001   ADDIU A2, ZERO, 1
9D0005CC  0F401375   JAL USER_USB_CALLBACK_EVENT_HANDLER
9D0005D0  00000000   NOP
958:                         USBClearInterruptRegister(U1EIR);               // This clears UERRIF
9D0005D4  3C02BF88   LUI V0, -16504
9D0005D8  240300FF   ADDIU V1, ZERO, 255
9D0005DC  AC435220   SW V1, 21024(V0)
959:                 
960:                         //On PIC18, clearing the source of the error will automatically clear
961:                         //  the interrupt flag.  On other devices the interrupt flag must be 
962:                         //  manually cleared. 
963:                         #if defined(__C32__) || defined(__C30__) || defined __XC16__
964:                             USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
9D0005E0  3C02BF88   LUI V0, -16504
9D0005E4  24030002   ADDIU V1, ZERO, 2
9D0005E8  AC435200   SW V1, 20992(V0)
965:                         #endif
966:                     }
967:                 
968:                     /*
969:                      * Pointless to continue servicing if the host has not sent a bus reset.
970:                      * Once bus reset is received, the device transitions into the DEFAULT
971:                      * state and is ready for communication.
972:                      */
973:                     if(USBDeviceState < DEFAULT_STATE)
9D0005EC  8F828038   LW V0, -32712(GP)
9D0005F0  2C420004   SLTIU V0, V0, 4
9D0005F4  10400006   BEQ V0, ZERO, 0x9D000610
9D0005F8  00000000   NOP
974:                     {
975:                 	    USBClearUSBInterrupt();
9D0005FC  2404003F   ADDIU A0, ZERO, 63
9D000600  77401606   JALX INTClearFlag
9D000604  00000000   NOP
976:                 	    return; 
9D000608  0B4001E0   J 0x9D000780
9D00060C  00000000   NOP
977:                 	}  
978:                 
979:                     /*
980:                      * Task D: Servicing USB Transaction Complete Interrupt
981:                      */
982:                     if(USBTransactionCompleteIE)
9D000610  3C02BF88   LUI V0, -16504
9D000614  8C425210   LW V0, 21008(V0)
9D000618  30420008   ANDI V0, V0, 8
9D00061C  10400055   BEQ V0, ZERO, 0x9D000774
9D000620  00000000   NOP
983:                     {
984:                 	    for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth 
9D000624  A3C00010   SB ZERO, 16(S8)
9D000628  0B4001D6   J 0x9D000758
9D00062C  00000000   NOP
9D00074C  93C20010   LBU V0, 16(S8)
9D000750  24420001   ADDIU V0, V0, 1
9D000754  A3C20010   SB V0, 16(S8)
9D000758  93C20010   LBU V0, 16(S8)
9D00075C  2C420004   SLTIU V0, V0, 4
9D000760  1440FFB3   BNE V0, ZERO, 0x9D000630
9D000764  00000000   NOP
9D000768  0B4001DD   J 0x9D000774
9D00076C  00000000   NOP
985:                 		{						//utilization can be compromised, and the device won't be able to receive SETUP packets.
986:                 		    if(USBTransactionCompleteIF)
9D000630  3C02BF88   LUI V0, -16504
9D000634  8C425200   LW V0, 20992(V0)
9D000638  30420008   ANDI V0, V0, 8
9D00063C  1040004C   BEQ V0, ZERO, 0x9D000770
9D000640  00000000   NOP
987:                 		    {
988:                     		    //Save and extract USTAT register info.  Will use this info later.
989:                                 USTATcopy.Val = U1STAT;
9D000644  3C02BF88   LUI V0, -16504
9D000648  8C425240   LW V0, 21056(V0)
9D00064C  304200FF   ANDI V0, V0, 255
9D000650  A3828084   SB V0, -32636(GP)
990:                                 endpoint_number = USBHALGetLastEndpoint(USTATcopy);
9D000654  93828084   LBU V0, -32636(GP)
9D000658  7C421900   EXT V0, V0, 4, 4
9D00065C  304200FF   ANDI V0, V0, 255
9D000660  A382803D   SB V0, -32707(GP)
991:                                 
992:                                 USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
9D000664  3C02BF88   LUI V0, -16504
9D000668  24030008   ADDIU V1, ZERO, 8
9D00066C  AC435200   SW V1, 20992(V0)
993:                                 
994:                                 //Keep track of the hardware ping pong state for endpoints other
995:                                 //than EP0, if ping pong buffering is enabled.
996:                                 #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) 
997:                                     if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
9D000670  93828084   LBU V0, -32636(GP)
9D000674  30420008   ANDI V0, V0, 8
9D000678  304200FF   ANDI V0, V0, 255
9D00067C  14400015   BNE V0, ZERO, 0x9D0006D4
9D000680  00000000   NOP
998:                                     {
999:                                         ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
9D000684  9382803D   LBU V0, -32707(GP)
9D000688  00401821   ADDU V1, V0, ZERO
9D00068C  9382803D   LBU V0, -32707(GP)
9D000690  00402021   ADDU A0, V0, ZERO
9D000694  27828048   ADDIU V0, GP, -32696
9D000698  00821021   ADDU V0, A0, V0
9D00069C  90420000   LBU V0, 0(V0)
9D0006A0  7C420000   EXT V0, V0, 0, 1
9D0006A4  304200FF   ANDI V0, V0, 255
9D0006A8  38420001   XORI V0, V0, 1
9D0006AC  304200FF   ANDI V0, V0, 255
9D0006B0  30420001   ANDI V0, V0, 1
9D0006B4  304400FF   ANDI A0, V0, 255
9D0006B8  27828048   ADDIU V0, GP, -32696
9D0006BC  00621821   ADDU V1, V1, V0
9D0006C0  90620000   LBU V0, 0(V1)
9D0006C4  7C820004   INS V0, A0, 0, 1
9D0006C8  A0620000   SB V0, 0(V1)
9D0006CC  0B4001C7   J 0x9D00071C
9D0006D0  00000000   NOP
1000:                                    }   
1001:                                    else
1002:                                    {
1003:                                        ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
9D0006D4  9382803D   LBU V0, -32707(GP)
9D0006D8  00401821   ADDU V1, V0, ZERO
9D0006DC  9382803D   LBU V0, -32707(GP)
9D0006E0  00402021   ADDU A0, V0, ZERO
9D0006E4  27828074   ADDIU V0, GP, -32652
9D0006E8  00821021   ADDU V0, A0, V0
9D0006EC  90420000   LBU V0, 0(V0)
9D0006F0  7C420000   EXT V0, V0, 0, 1
9D0006F4  304200FF   ANDI V0, V0, 255
9D0006F8  38420001   XORI V0, V0, 1
9D0006FC  304200FF   ANDI V0, V0, 255
9D000700  30420001   ANDI V0, V0, 1
9D000704  304400FF   ANDI A0, V0, 255
9D000708  27828074   ADDIU V0, GP, -32652
9D00070C  00621821   ADDU V1, V1, V0
9D000710  90620000   LBU V0, 0(V1)
9D000714  7C820004   INS V0, A0, 0, 1
9D000718  A0620000   SB V0, 0(V1)
1004:                                    }         
1005:                                #endif    
1006:                                
1007:                                //USBCtrlEPService only services transactions over EP0.
1008:                                //It ignores all other EP transactions.
1009:                                if(endpoint_number == 0)
9D00071C  9382803D   LBU V0, -32707(GP)
9D000720  14400005   BNE V0, ZERO, 0x9D000738
9D000724  00000000   NOP
1010:                                {
1011:                                    USBCtrlEPService();
9D000728  0F400903   JAL 0x9D00240C
9D00072C  00000000   NOP
9D000730  0B4001D3   J 0x9D00074C
9D000734  00000000   NOP
1012:                                }
1013:                                else
1014:                                {
1015:                                    USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (BYTE*)&USTATcopy.Val, 0);
9D000738  24040072   ADDIU A0, ZERO, 114
9D00073C  27858084   ADDIU A1, GP, -32636
9D000740  00003021   ADDU A2, ZERO, ZERO
9D000744  0F401375   JAL USER_USB_CALLBACK_EVENT_HANDLER
9D000748  00000000   NOP
1016:                                }
1017:                		    }//end if(USBTransactionCompleteIF)
1018:                		    else
1019:                		    	break;	//USTAT FIFO must be empty.
9D000770  00000000   NOP
1020:                		}//end for()
1021:                	}//end if(USBTransactionCompleteIE)   
1022:                
1023:                    USBClearUSBInterrupt();
9D000774  2404003F   ADDIU A0, ZERO, 63
9D000778  77401606   JALX INTClearFlag
9D00077C  00000000   NOP
1024:                }//end of USBDeviceTasks()
9D000780  03C0E821   ADDU SP, S8, ZERO
9D000784  8FBF001C   LW RA, 28(SP)
9D000788  8FBE0018   LW S8, 24(SP)
9D00078C  27BD0020   ADDIU SP, SP, 32
9D000790  03E00008   JR RA
9D000794  00000000   NOP
1025:                
1026:                /*******************************************************************************
1027:                  Function:
1028:                        void USBEnableEndpoint(BYTE ep, BYTE options)
1029:                    
1030:                  Summary:
1031:                    This function will enable the specified endpoint with the specified
1032:                    options
1033:                  Description:
1034:                    This function will enable the specified endpoint with the specified
1035:                    options.
1036:                    
1037:                    Typical Usage:
1038:                    <code>
1039:                    void USBCBInitEP(void)
1040:                    {
1041:                        USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1042:                        USBMSDInit();
1043:                    }
1044:                    </code>
1045:                    
1046:                    In the above example endpoint number MSD_DATA_IN_EP is being configured
1047:                    for both IN and OUT traffic with handshaking enabled. Also since
1048:                    MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
1049:                    explicitly disable SETUP packets on this endpoint.
1050:                  Conditions:
1051:                    None
1052:                  Input:
1053:                    BYTE ep -       the endpoint to be configured
1054:                    BYTE options -  optional settings for the endpoint. The options should
1055:                                    be ORed together to form a single options string. The
1056:                                    available optional settings for the endpoint. The
1057:                                    options should be ORed together to form a single options
1058:                                    string. The available options are the following/:
1059:                                    * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
1060:                                      NAK)
1061:                                    * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
1062:                                      NAK)
1063:                                    * USB_OUT_ENABLED enables the out direction
1064:                                    * USB_OUT_DISABLED disables the out direction
1065:                                    * USB_IN_ENABLED enables the in direction
1066:                                    * USB_IN_DISABLED disables the in direction
1067:                                    * USB_ALLOW_SETUP enables control transfers
1068:                                    * USB_DISALLOW_SETUP disables control transfers
1069:                                    * USB_STALL_ENDPOINT STALLs this endpoint
1070:                  Return:
1071:                    None
1072:                  Remarks:
1073:                    None                                                                                                          
1074:                  *****************************************************************************/
1075:                void USBEnableEndpoint(BYTE ep, BYTE options)
1076:                {
9D000798  27BDFFE0   ADDIU SP, SP, -32
9D00079C  AFBF001C   SW RA, 28(SP)
9D0007A0  AFBE0018   SW S8, 24(SP)
9D0007A4  03A0F021   ADDU S8, SP, ZERO
9D0007A8  00801821   ADDU V1, A0, ZERO
9D0007AC  00A01021   ADDU V0, A1, ZERO
9D0007B0  A3C30020   SB V1, 32(S8)
9D0007B4  A3C20024   SB V0, 36(S8)
1077:                    unsigned char* p;
1078:                        
1079:                    //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
1080:                    //starting DTS state in the BDT entry.
1081:                    if(options & USB_OUT_ENABLED)
9D0007B8  93C20024   LBU V0, 36(S8)
9D0007BC  30420008   ANDI V0, V0, 8
9D0007C0  10400006   BEQ V0, ZERO, 0x9D0007DC
9D0007C4  00000000   NOP
1082:                    {
1083:                        USBConfigureEndpoint(ep, OUT_FROM_HOST);
9D0007C8  93C20020   LBU V0, 32(S8)
9D0007CC  00402021   ADDU A0, V0, ZERO
9D0007D0  00002821   ADDU A1, ZERO, ZERO
9D0007D4  0F40052A   JAL 0x9D0014A8
9D0007D8  00000000   NOP
1084:                    }
1085:                    if(options & USB_IN_ENABLED)
9D0007DC  93C20024   LBU V0, 36(S8)
9D0007E0  30420004   ANDI V0, V0, 4
9D0007E4  10400006   BEQ V0, ZERO, 0x9D000800
9D0007E8  00000000   NOP
1086:                    {
1087:                        USBConfigureEndpoint(ep, IN_TO_HOST);
9D0007EC  93C20020   LBU V0, 32(S8)
9D0007F0  00402021   ADDU A0, V0, ZERO
9D0007F4  24050001   ADDIU A1, ZERO, 1
9D0007F8  0F40052A   JAL 0x9D0014A8
9D0007FC  00000000   NOP
1088:                    }
1089:                
1090:                    //Update the relevant UEPx register to actually enable the endpoint with
1091:                    //the specified options (ex: handshaking enabled, control transfers allowed,
1092:                    //etc.)
1093:                    #if defined(__C32__)
1094:                        p = (unsigned char*)(&U1EP0+(4*ep));
9D000800  3C02BF88   LUI V0, -16504
9D000804  24435300   ADDIU V1, V0, 21248
9D000808  93C20020   LBU V0, 32(S8)
9D00080C  00021100   SLL V0, V0, 4
9D000810  00621021   ADDU V0, V1, V0
9D000814  AFC20010   SW V0, 16(S8)
1095:                    #else
1096:                        p = (unsigned char*)(&U1EP0+ep);
1097:                    #endif
1098:                    *p = options;
9D000818  8FC20010   LW V0, 16(S8)
9D00081C  93C30024   LBU V1, 36(S8)
9D000820  A0430000   SB V1, 0(V0)
1099:                }
9D000824  03C0E821   ADDU SP, S8, ZERO
9D000828  8FBF001C   LW RA, 28(SP)
9D00082C  8FBE0018   LW S8, 24(SP)
9D000830  27BD0020   ADDIU SP, SP, 32
9D000834  03E00008   JR RA
9D000838  00000000   NOP
1100:                
1101:                
1102:                /*************************************************************************
1103:                  Function:
1104:                    USB_HANDLE USBTransferOnePacket(BYTE ep, BYTE dir, BYTE* data, BYTE len)
1105:                    
1106:                  Summary:
1107:                    Transfers a single packet (one transaction) of data on the USB bus.
1108:                
1109:                  Description:
1110:                    The USBTransferOnePacket() function prepares a USB endpoint
1111:                    so that it may send data to the host (an IN transaction), or 
1112:                    receive data from the host (an OUT transaction).  The 
1113:                    USBTransferOnePacket() function can be used both to receive	and 
1114:                    send data to the host.  This function is the primary API function 
1115:                    provided by the USB stack firmware for sending or receiving application 
1116:                    data over the USB port.  
1117:                
1118:                    The USBTransferOnePacket() is intended for use with all application 
1119:                    endpoints.  It is not used for sending or receiving applicaiton data 
1120:                    through endpoint 0 by using control transfers.  Separate API 
1121:                    functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
1122:                    USBEP0SendROMPtr() are provided for this purpose.
1123:                
1124:                    The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
1125:                    entry associated with an endpoint buffer, and sets the UOWN bit, which 
1126:                    prepares the USB hardware to allow the transaction to complete.  The 
1127:                    application firmware can use the USBHandleBusy() macro to check the 
1128:                    status of the transaction, to see if the data has been successfully 
1129:                    transmitted yet.
1130:                
1131:                
1132:                    Typical Usage
1133:                    <code>
1134:                    //make sure that the we are in the configured state
1135:                    if(USBGetDeviceState() == CONFIGURED_STATE)
1136:                    {
1137:                        //make sure that the last transaction isn't busy by checking the handle
1138:                        if(!USBHandleBusy(USBInHandle))
1139:                        {
1140:                	        //Write the new data that we wish to send to the host to the INPacket[] array
1141:                	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
1142:                	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
1143:                	        //INPacket[2] = ... (fill in the rest of the packet data)
1144:                	      
1145:                            //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
1146:                            USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(BYTE*)&INPacket[0],sizeof(INPacket));
1147:                        }
1148:                    }
1149:                    </code>
1150:                
1151:                  Conditions:
1152:                    Before calling USBTransferOnePacket(), the following should be true.
1153:                    1.  The USB stack has already been initialized (USBDeviceInit() was called).
1154:                    2.  A transaction is not already pending on the specified endpoint.  This
1155:                        is done by checking the previous request using the USBHandleBusy() 
1156:                        macro (see the typical usage example).
1157:                    3.  The host has already sent a set configuration request and the 
1158:                        enumeration process is complete.
1159:                        This can be checked by verifying that the USBGetDeviceState() 
1160:                        macro returns "CONFIGURED_STATE", prior to calling 
1161:                        USBTransferOnePacket().
1162:                 					
1163:                  Input:
1164:                    BYTE ep - The endpoint number that the data will be transmitted or 
1165:                	          received on
1166:                    BYTE dir - The direction of the transfer
1167:                               This value is either OUT_FROM_HOST or IN_TO_HOST
1168:                    BYTE* data - For IN transactions: pointer to the RAM buffer containing 
1169:                                 the data to be sent to the host.  For OUT transactions: pointer
1170:                                 to the RAM buffer that the received data should get written to.
1171:                   BYTE len - Length of the data needing to be sent (for IN transactions).
1172:                              For OUT transactions, the len parameter should normally be set
1173:                              to the endpoint size specified in the endpoint descriptor.    
1174:                
1175:                  Return Values:
1176:                    USB_HANDLE - handle to the transfer.  The handle is a pointer to 
1177:                                 the BDT entry associated with this transaction.  The
1178:                                 status of the transaction (ex: if it is complete or still
1179:                                 pending) can be checked using the USBHandleBusy() macro
1180:                                 and supplying the USB_HANDLE provided by
1181:                                 USBTransferOnePacket().
1182:                
1183:                  Remarks:
1184:                    If calling the USBTransferOnePacket() function from within the USBCBInitEP()
1185:                    callback function, the set configuration is still being processed and the
1186:                    USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case, 
1187:                    the USBTransferOnePacket() may still be called, but make sure that the 
1188:                    endpoint has been enabled and initialized by the USBEnableEndpoint() 
1189:                    function first.  
1190:                    
1191:                  *************************************************************************/
1192:                USB_HANDLE USBTransferOnePacket(BYTE ep,BYTE dir,BYTE* data,BYTE len)
1193:                {
9D00083C  27BDFFF0   ADDIU SP, SP, -16
9D000840  AFBE000C   SW S8, 12(SP)
9D000844  03A0F021   ADDU S8, SP, ZERO
9D000848  00A01821   ADDU V1, A1, ZERO
9D00084C  AFC60018   SW A2, 24(S8)
9D000850  00E01021   ADDU V0, A3, ZERO
9D000854  A3C40010   SB A0, 16(S8)
9D000858  A3C30014   SB V1, 20(S8)
9D00085C  A3C2001C   SB V0, 28(S8)
1194:                    volatile BDT_ENTRY* handle;
1195:                
1196:                    //If the direction is IN
1197:                    if(dir != 0)
9D000860  93C20014   LBU V0, 20(S8)
9D000864  10400009   BEQ V0, ZERO, 0x9D00088C
9D000868  00000000   NOP
1198:                    {
1199:                        //point to the IN BDT of the specified endpoint
1200:                        handle = pBDTEntryIn[ep];
9D00086C  93C20010   LBU V0, 16(S8)
9D000870  00021880   SLL V1, V0, 2
9D000874  27828040   ADDIU V0, GP, -32704
9D000878  00621021   ADDU V0, V1, V0
9D00087C  8C420000   LW V0, 0(V0)
9D000880  AFC20000   SW V0, 0(S8)
9D000884  0B400229   J 0x9D0008A4
9D000888  00000000   NOP
1201:                    }
1202:                    else
1203:                    {
1204:                        //else point to the OUT BDT of the specified endpoint
1205:                        handle = pBDTEntryOut[ep];
9D00088C  93C20010   LBU V0, 16(S8)
9D000890  00021880   SLL V1, V0, 2
9D000894  27828054   ADDIU V0, GP, -32684
9D000898  00621021   ADDU V0, V1, V0
9D00089C  8C420000   LW V0, 0(V0)
9D0008A0  AFC20000   SW V0, 0(S8)
1206:                    }
1207:                    
1208:                    //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1209:                    //pBDTEntryOut[ep]) is initialized before using it.
1210:                    if(handle == 0)
9D0008A4  8FC20000   LW V0, 0(S8)
9D0008A8  14400004   BNE V0, ZERO, 0x9D0008BC
9D0008AC  00000000   NOP
1211:                    {
1212:                	    return 0;
9D0008B0  00001021   ADDU V0, ZERO, ZERO
9D0008B4  0B4002A4   J 0x9D000A90
9D0008B8  00000000   NOP
1213:                	}
1214:                
1215:                    //Toggle the DTS bit if required
1216:                    #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1217:                        handle->STAT.Val ^= _DTSMASK;
1218:                    #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1219:                        if(ep != 0)
1220:                        {
1221:                            handle->STAT.Val ^= _DTSMASK;
1222:                        }
1223:                    #endif
1224:                
1225:                    //Set the data pointer, data length, and enable the endpoint
1226:                    handle->ADR = ConvertToPhysicalAddress(data);
9D0008BC  8FC20018   LW V0, 24(S8)
9D0008C0  7C43E000   EXT V1, V0, 0, 29
9D0008C4  8FC20000   LW V0, 0(S8)
9D0008C8  306400FF   ANDI A0, V1, 255
9D0008CC  90450004   LBU A1, 4(V0)
9D0008D0  30A50000   ANDI A1, A1, 0
9D0008D4  00A42025   OR A0, A1, A0
9D0008D8  A0440004   SB A0, 4(V0)
9D0008DC  00032202   SRL A0, V1, 8
9D0008E0  308400FF   ANDI A0, A0, 255
9D0008E4  90450005   LBU A1, 5(V0)
9D0008E8  30A50000   ANDI A1, A1, 0
9D0008EC  00A42025   OR A0, A1, A0
9D0008F0  A0440005   SB A0, 5(V0)
9D0008F4  00032402   SRL A0, V1, 16
9D0008F8  308400FF   ANDI A0, A0, 255
9D0008FC  90450006   LBU A1, 6(V0)
9D000900  30A50000   ANDI A1, A1, 0
9D000904  00A42025   OR A0, A1, A0
9D000908  A0440006   SB A0, 6(V0)
9D00090C  00031E02   SRL V1, V1, 24
9D000910  90440007   LBU A0, 7(V0)
9D000914  30840000   ANDI A0, A0, 0
9D000918  00831825   OR V1, A0, V1
9D00091C  A0430007   SB V1, 7(V0)
1227:                    handle->CNT = len;
9D000920  93C2001C   LBU V0, 28(S8)
9D000924  304203FF   ANDI V0, V0, 1023
9D000928  3043FFFF   ANDI V1, V0, -1
9D00092C  8FC20000   LW V0, 0(S8)
9D000930  306400FF   ANDI A0, V1, 255
9D000934  90450002   LBU A1, 2(V0)
9D000938  30A50000   ANDI A1, A1, 0
9D00093C  00A42025   OR A0, A1, A0
9D000940  A0440002   SB A0, 2(V0)
9D000944  00031A02   SRL V1, V1, 8
9D000948  3063FFFF   ANDI V1, V1, -1
9D00094C  30630003   ANDI V1, V1, 3
9D000950  30630003   ANDI V1, V1, 3
9D000954  90450003   LBU A1, 3(V0)
9D000958  2404FFFC   ADDIU A0, ZERO, -4
9D00095C  00A42024   AND A0, A1, A0
9D000960  00831825   OR V1, A0, V1
9D000964  A0430003   SB V1, 3(V0)
1228:                    handle->STAT.Val &= _DTSMASK;
9D000968  8FC20000   LW V0, 0(S8)
9D00096C  90430000   LBU V1, 0(V0)
9D000970  306300FF   ANDI V1, V1, 255
9D000974  90420001   LBU V0, 1(V0)
9D000978  304200FF   ANDI V0, V0, 255
9D00097C  00021200   SLL V0, V0, 8
9D000980  00431025   OR V0, V0, V1
9D000984  3042FFFF   ANDI V0, V0, -1
9D000988  30420040   ANDI V0, V0, 64
9D00098C  3043FFFF   ANDI V1, V0, -1
9D000990  8FC20000   LW V0, 0(S8)
9D000994  306400FF   ANDI A0, V1, 255
9D000998  90450000   LBU A1, 0(V0)
9D00099C  30A50000   ANDI A1, A1, 0
9D0009A0  00A42025   OR A0, A1, A0
9D0009A4  A0440000   SB A0, 0(V0)
9D0009A8  00031A02   SRL V1, V1, 8
9D0009AC  3063FFFF   ANDI V1, V1, -1
9D0009B0  90440001   LBU A0, 1(V0)
9D0009B4  30840000   ANDI A0, A0, 0
9D0009B8  00831825   OR V1, A0, V1
9D0009BC  A0430001   SB V1, 1(V0)
1229:                    handle->STAT.Val |= _USIE | (_DTSEN & _DTS_CHECKING_ENABLED);
9D0009C0  8FC20000   LW V0, 0(S8)
9D0009C4  90430000   LBU V1, 0(V0)
9D0009C8  306300FF   ANDI V1, V1, 255
9D0009CC  90420001   LBU V0, 1(V0)
9D0009D0  304200FF   ANDI V0, V0, 255
9D0009D4  00021200   SLL V0, V0, 8
9D0009D8  00431025   OR V0, V0, V1
9D0009DC  3042FFFF   ANDI V0, V0, -1
9D0009E0  34420088   ORI V0, V0, 136
9D0009E4  3043FFFF   ANDI V1, V0, -1
9D0009E8  8FC20000   LW V0, 0(S8)
9D0009EC  306400FF   ANDI A0, V1, 255
9D0009F0  90450000   LBU A1, 0(V0)
9D0009F4  30A50000   ANDI A1, A1, 0
9D0009F8  00A42025   OR A0, A1, A0
9D0009FC  A0440000   SB A0, 0(V0)
9D000A00  00031A02   SRL V1, V1, 8
9D000A04  3063FFFF   ANDI V1, V1, -1
9D000A08  90440001   LBU A0, 1(V0)
9D000A0C  30840000   ANDI A0, A0, 0
9D000A10  00831825   OR V1, A0, V1
9D000A14  A0430001   SB V1, 1(V0)
1230:                
1231:                    //Point to the next buffer for ping pong purposes.
1232:                    if(dir != OUT_FROM_HOST)
9D000A18  93C20014   LBU V0, 20(S8)
9D000A1C  1040000F   BEQ V0, ZERO, 0x9D000A5C
9D000A20  00000000   NOP
1233:                    {
1234:                        //toggle over the to the next buffer for an IN endpoint
1235:                        USBAdvancePingPongBuffer(&pBDTEntryIn[ep]);      
9D000A24  27838040   ADDIU V1, GP, -32704
9D000A28  93C20010   LBU V0, 16(S8)
9D000A2C  00021080   SLL V0, V0, 2
9D000A30  00621021   ADDU V0, V1, V0
9D000A34  27848040   ADDIU A0, GP, -32704
9D000A38  93C30010   LBU V1, 16(S8)
9D000A3C  00031880   SLL V1, V1, 2
9D000A40  00831821   ADDU V1, A0, V1
9D000A44  90630000   LBU V1, 0(V1)
9D000A48  38630008   XORI V1, V1, 8
9D000A4C  306300FF   ANDI V1, V1, 255
9D000A50  A0430000   SB V1, 0(V0)
9D000A54  0B4002A3   J 0x9D000A8C
9D000A58  00000000   NOP
1236:                    }
1237:                    else
1238:                    {
1239:                        //toggle over the to the next buffer for an OUT endpoint
1240:                        USBAdvancePingPongBuffer(&pBDTEntryOut[ep]);     
9D000A5C  27838054   ADDIU V1, GP, -32684
9D000A60  93C20010   LBU V0, 16(S8)
9D000A64  00021080   SLL V0, V0, 2
9D000A68  00621021   ADDU V0, V1, V0
9D000A6C  27848054   ADDIU A0, GP, -32684
9D000A70  93C30010   LBU V1, 16(S8)
9D000A74  00031880   SLL V1, V1, 2
9D000A78  00831821   ADDU V1, A0, V1
9D000A7C  90630000   LBU V1, 0(V1)
9D000A80  38630008   XORI V1, V1, 8
9D000A84  306300FF   ANDI V1, V1, 255
9D000A88  A0430000   SB V1, 0(V0)
1241:                    }
1242:                    return (USB_HANDLE)handle;
9D000A8C  8FC20000   LW V0, 0(S8)
1243:                }
9D000A90  03C0E821   ADDU SP, S8, ZERO
9D000A94  8FBE000C   LW S8, 12(SP)
9D000A98  27BD0010   ADDIU SP, SP, 16
9D000A9C  03E00008   JR RA
9D000AA0  00000000   NOP
1244:                
1245:                
1246:                /********************************************************************
1247:                    Function:
1248:                        void USBStallEndpoint(BYTE ep, BYTE dir)
1249:                        
1250:                    Summary:
1251:                         Configures the specified endpoint to send STALL to the host, the next
1252:                         time the host tries to access the endpoint.
1253:                    
1254:                    PreCondition:
1255:                        None
1256:                        
1257:                    Parameters:
1258:                        BYTE ep - The endpoint number that should be configured to send STALL.
1259:                        BYTE dir - The direction of the endpoint to STALL, either 
1260:                                   IN_TO_HOST or OUT_FROM_HOST.
1261:                        
1262:                    Return Values:
1263:                        None
1264:                        
1265:                    Remarks:
1266:                        None
1267:                
1268:                 *******************************************************************/
1269:                void USBStallEndpoint(BYTE ep, BYTE dir)
1270:                {
9D000AA4  27BDFFF0   ADDIU SP, SP, -16
9D000AA8  AFBE000C   SW S8, 12(SP)
9D000AAC  03A0F021   ADDU S8, SP, ZERO
9D000AB0  00801821   ADDU V1, A0, ZERO
9D000AB4  00A01021   ADDU V0, A1, ZERO
9D000AB8  A3C30010   SB V1, 16(S8)
9D000ABC  A3C20014   SB V0, 20(S8)
1271:                    BDT_ENTRY *p;
1272:                
1273:                    if(ep == 0)
9D000AC0  93C20010   LBU V0, 16(S8)
9D000AC4  14400039   BNE V0, ZERO, 0x9D000BAC
9D000AC8  00000000   NOP
1274:                    {
1275:                        //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1276:                        //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
1277:                        //packet that will arrrive.
1278:                        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9D000ACC  8F828060   LW V0, -32672(GP)
9D000AD0  90430002   LBU V1, 2(V0)
9D000AD4  30630000   ANDI V1, V1, 0
9D000AD8  34630040   ORI V1, V1, 64
9D000ADC  A0430002   SB V1, 2(V0)
9D000AE0  90440003   LBU A0, 3(V0)
9D000AE4  2403FFFC   ADDIU V1, ZERO, -4
9D000AE8  00831824   AND V1, A0, V1
9D000AEC  A0430003   SB V1, 3(V0)
1279:                        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
9D000AF0  8F828060   LW V0, -32672(GP)
9D000AF4  2783806C   ADDIU V1, GP, -32660
9D000AF8  7C63E000   EXT V1, V1, 0, 29
9D000AFC  306400FF   ANDI A0, V1, 255
9D000B00  90450004   LBU A1, 4(V0)
9D000B04  30A50000   ANDI A1, A1, 0
9D000B08  00A42025   OR A0, A1, A0
9D000B0C  A0440004   SB A0, 4(V0)
9D000B10  00032202   SRL A0, V1, 8
9D000B14  308400FF   ANDI A0, A0, 255
9D000B18  90450005   LBU A1, 5(V0)
9D000B1C  30A50000   ANDI A1, A1, 0
9D000B20  00A42025   OR A0, A1, A0
9D000B24  A0440005   SB A0, 5(V0)
9D000B28  00032402   SRL A0, V1, 16
9D000B2C  308400FF   ANDI A0, A0, 255
9D000B30  90450006   LBU A1, 6(V0)
9D000B34  30A50000   ANDI A1, A1, 0
9D000B38  00A42025   OR A0, A1, A0
9D000B3C  A0440006   SB A0, 6(V0)
9D000B40  00031E02   SRL V1, V1, 24
9D000B44  90440007   LBU A0, 7(V0)
9D000B48  30840000   ANDI A0, A0, 0
9D000B4C  00831825   OR V1, A0, V1
9D000B50  A0430007   SB V1, 7(V0)
1280:                        pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
9D000B54  8F828060   LW V0, -32672(GP)
9D000B58  90430000   LBU V1, 0(V0)
9D000B5C  30630000   ANDI V1, V1, 0
9D000B60  00602021   ADDU A0, V1, ZERO
9D000B64  2403FF8C   ADDIU V1, ZERO, -116
9D000B68  00831825   OR V1, A0, V1
9D000B6C  A0430000   SB V1, 0(V0)
9D000B70  90430001   LBU V1, 1(V0)
9D000B74  30630000   ANDI V1, V1, 0
9D000B78  A0430001   SB V1, 1(V0)
1281:                        pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
9D000B7C  8F828040   LW V0, -32704(GP)
9D000B80  90430000   LBU V1, 0(V0)
9D000B84  30630000   ANDI V1, V1, 0
9D000B88  00602021   ADDU A0, V1, ZERO
9D000B8C  2403FF84   ADDIU V1, ZERO, -124
9D000B90  00831825   OR V1, A0, V1
9D000B94  A0430000   SB V1, 0(V0)
9D000B98  90430001   LBU V1, 1(V0)
9D000B9C  30630000   ANDI V1, V1, 0
9D000BA0  A0430001   SB V1, 1(V0)
9D000BA4  0B400327   J 0x9D000C9C
9D000BA8  00000000   NOP
1282:                               
1283:                    }
1284:                    else
1285:                    {
1286:                        p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
9D000BAC  93C20010   LBU V0, 16(S8)
9D000BB0  00021840   SLL V1, V0, 1
9D000BB4  93C20014   LBU V0, 20(S8)
9D000BB8  00621021   ADDU V0, V1, V0
9D000BBC  00021100   SLL V0, V0, 4
9D000BC0  00401821   ADDU V1, V0, ZERO
9D000BC4  3C02A000   LUI V0, -24576
9D000BC8  24420200   ADDIU V0, V0, 512
9D000BCC  00621021   ADDU V0, V1, V0
9D000BD0  AFC20000   SW V0, 0(S8)
1287:                        p->STAT.Val |= _BSTALL | _USIE;
9D000BD4  8FC20000   LW V0, 0(S8)
9D000BD8  90430000   LBU V1, 0(V0)
9D000BDC  90420001   LBU V0, 1(V0)
9D000BE0  00021200   SLL V0, V0, 8
9D000BE4  00431025   OR V0, V0, V1
9D000BE8  3042FFFF   ANDI V0, V0, -1
9D000BEC  34420084   ORI V0, V0, 132
9D000BF0  3043FFFF   ANDI V1, V0, -1
9D000BF4  8FC20000   LW V0, 0(S8)
9D000BF8  306400FF   ANDI A0, V1, 255
9D000BFC  90450000   LBU A1, 0(V0)
9D000C00  30A50000   ANDI A1, A1, 0
9D000C04  00A42025   OR A0, A1, A0
9D000C08  A0440000   SB A0, 0(V0)
9D000C0C  00031A02   SRL V1, V1, 8
9D000C10  3063FFFF   ANDI V1, V1, -1
9D000C14  90440001   LBU A0, 1(V0)
9D000C18  30840000   ANDI A0, A0, 0
9D000C1C  00831825   OR V1, A0, V1
9D000C20  A0430001   SB V1, 1(V0)
1288:                    
1289:                        //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1290:                        //then stall that entry as well
1291:                        #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1292:                    
1293:                        p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
9D000C24  93C20010   LBU V0, 16(S8)
9D000C28  00021840   SLL V1, V0, 1
9D000C2C  93C20014   LBU V0, 20(S8)
9D000C30  00621021   ADDU V0, V1, V0
9D000C34  00021100   SLL V0, V0, 4
9D000C38  24430008   ADDIU V1, V0, 8
9D000C3C  3C02A000   LUI V0, -24576
9D000C40  24420200   ADDIU V0, V0, 512
9D000C44  00621021   ADDU V0, V1, V0
9D000C48  AFC20000   SW V0, 0(S8)
1294:                        p->STAT.Val |= _BSTALL | _USIE;
9D000C4C  8FC20000   LW V0, 0(S8)
9D000C50  90430000   LBU V1, 0(V0)
9D000C54  90420001   LBU V0, 1(V0)
9D000C58  00021200   SLL V0, V0, 8
9D000C5C  00431025   OR V0, V0, V1
9D000C60  3042FFFF   ANDI V0, V0, -1
9D000C64  34420084   ORI V0, V0, 132
9D000C68  3043FFFF   ANDI V1, V0, -1
9D000C6C  8FC20000   LW V0, 0(S8)
9D000C70  306400FF   ANDI A0, V1, 255
9D000C74  90450000   LBU A1, 0(V0)
9D000C78  30A50000   ANDI A1, A1, 0
9D000C7C  00A42025   OR A0, A1, A0
9D000C80  A0440000   SB A0, 0(V0)
9D000C84  00031A02   SRL V1, V1, 8
9D000C88  3063FFFF   ANDI V1, V1, -1
9D000C8C  90440001   LBU A0, 1(V0)
9D000C90  30840000   ANDI A0, A0, 0
9D000C94  00831825   OR V1, A0, V1
9D000C98  A0430001   SB V1, 1(V0)
1295:                        #endif
1296:                    }
1297:                }
9D000C9C  03C0E821   ADDU SP, S8, ZERO
9D000CA0  8FBE000C   LW S8, 12(SP)
9D000CA4  27BD0010   ADDIU SP, SP, 16
9D000CA8  03E00008   JR RA
9D000CAC  00000000   NOP
1298:                
1299:                /**************************************************************************
1300:                    Function:
1301:                        void USBCancelIO(BYTE endpoint)
1302:                    
1303:                    Description:
1304:                        This function cancels the transfers pending on the specified endpoint.
1305:                        This function can only be used after a SETUP packet is received and 
1306:                        before that setup packet is handled.  This is the time period in which
1307:                        the EVENT_EP0_REQUEST is thrown, before the event handler function
1308:                        returns to the stack.
1309:                
1310:                    Precondition:
1311:                  
1312:                    Parameters:
1313:                        BYTE endpoint - the endpoint number you wish to cancel the transfers for
1314:                     
1315:                    Return Values:
1316:                        None
1317:                        
1318:                    Remarks:
1319:                        None
1320:                                                                          
1321:                  **************************************************************************/
1322:                void USBCancelIO(BYTE endpoint)
1323:                {
9D000CB0  27BDFFF8   ADDIU SP, SP, -8
9D000CB4  AFBE0004   SW S8, 4(SP)
9D000CB8  03A0F021   ADDU S8, SP, ZERO
9D000CBC  00801021   ADDU V0, A0, ZERO
9D000CC0  A3C20008   SB V0, 8(S8)
1324:                    if(USBPacketDisable == 1)
9D000CC4  3C02BF88   LUI V0, -16504
9D000CC8  8C425250   LW V0, 21072(V0)
9D000CCC  30420020   ANDI V0, V0, 32
9D000CD0  104000F5   BEQ V0, ZERO, 0x9D0010A8
9D000CD4  00000000   NOP
1325:                    {
1326:                    	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1327:                    	//to mess with the BDT right now.
1328:                    	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
9D000CD8  93C20008   LBU V0, 8(S8)
9D000CDC  00021880   SLL V1, V0, 2
9D000CE0  27828040   ADDIU V0, GP, -32704
9D000CE4  00621021   ADDU V0, V1, V0
9D000CE8  8C420000   LW V0, 0(V0)
9D000CEC  93C30008   LBU V1, 8(S8)
9D000CF0  00032080   SLL A0, V1, 2
9D000CF4  27838040   ADDIU V1, GP, -32704
9D000CF8  00831821   ADDU V1, A0, V1
9D000CFC  8C630000   LW V1, 0(V1)
9D000D00  906A0000   LBU T2, 0(V1)
9D000D04  314A00FF   ANDI T2, T2, 255
9D000D08  906B0001   LBU T3, 1(V1)
9D000D0C  316B00FF   ANDI T3, T3, 255
9D000D10  000B5A00   SLL T3, T3, 8
9D000D14  016A5025   OR T2, T3, T2
9D000D18  906B0002   LBU T3, 2(V1)
9D000D1C  316B00FF   ANDI T3, T3, 255
9D000D20  000B5C00   SLL T3, T3, 16
9D000D24  016A5025   OR T2, T3, T2
9D000D28  906B0003   LBU T3, 3(V1)
9D000D2C  316B00FF   ANDI T3, T3, 255
9D000D30  000B5E00   SLL T3, T3, 24
9D000D34  016A5025   OR T2, T3, T2
9D000D38  01402021   ADDU A0, T2, ZERO
9D000D3C  906A0004   LBU T2, 4(V1)
9D000D40  314A00FF   ANDI T2, T2, 255
9D000D44  906B0005   LBU T3, 5(V1)
9D000D48  316B00FF   ANDI T3, T3, 255
9D000D4C  000B5A00   SLL T3, T3, 8
9D000D50  016A5025   OR T2, T3, T2
9D000D54  906B0006   LBU T3, 6(V1)
9D000D58  316B00FF   ANDI T3, T3, 255
9D000D5C  000B5C00   SLL T3, T3, 16
9D000D60  016A5025   OR T2, T3, T2
9D000D64  90630007   LBU V1, 7(V1)
9D000D68  306300FF   ANDI V1, V1, 255
9D000D6C  00031E00   SLL V1, V1, 24
9D000D70  006A1825   OR V1, V1, T2
9D000D74  00602821   ADDU A1, V1, ZERO
9D000D78  30880040   ANDI T0, A0, 64
9D000D7C  30A90000   ANDI T1, A1, 0
9D000D80  310300FF   ANDI V1, T0, 255
9D000D84  90440000   LBU A0, 0(V0)
9D000D88  30840000   ANDI A0, A0, 0
9D000D8C  00831825   OR V1, A0, V1
9D000D90  A0430000   SB V1, 0(V0)
9D000D94  00081A02   SRL V1, T0, 8
9D000D98  306300FF   ANDI V1, V1, 255
9D000D9C  90440001   LBU A0, 1(V0)
9D000DA0  30840000   ANDI A0, A0, 0
9D000DA4  00831825   OR V1, A0, V1
9D000DA8  A0430001   SB V1, 1(V0)
9D000DAC  00081C02   SRL V1, T0, 16
9D000DB0  306300FF   ANDI V1, V1, 255
9D000DB4  90440002   LBU A0, 2(V0)
9D000DB8  30840000   ANDI A0, A0, 0
9D000DBC  00831825   OR V1, A0, V1
9D000DC0  A0430002   SB V1, 2(V0)
9D000DC4  00081E02   SRL V1, T0, 24
9D000DC8  90440003   LBU A0, 3(V0)
9D000DCC  30840000   ANDI A0, A0, 0
9D000DD0  00831825   OR V1, A0, V1
9D000DD4  A0430003   SB V1, 3(V0)
9D000DD8  312300FF   ANDI V1, T1, 255
9D000DDC  90440004   LBU A0, 4(V0)
9D000DE0  30840000   ANDI A0, A0, 0
9D000DE4  00831825   OR V1, A0, V1
9D000DE8  A0430004   SB V1, 4(V0)
9D000DEC  00091A02   SRL V1, T1, 8
9D000DF0  306300FF   ANDI V1, V1, 255
9D000DF4  90440005   LBU A0, 5(V0)
9D000DF8  30840000   ANDI A0, A0, 0
9D000DFC  00831825   OR V1, A0, V1
9D000E00  A0430005   SB V1, 5(V0)
9D000E04  00091C02   SRL V1, T1, 16
9D000E08  306300FF   ANDI V1, V1, 255
9D000E0C  90440006   LBU A0, 6(V0)
9D000E10  30840000   ANDI A0, A0, 0
9D000E14  00831825   OR V1, A0, V1
9D000E18  A0430006   SB V1, 6(V0)
9D000E1C  00091E02   SRL V1, T1, 24
9D000E20  90440007   LBU A0, 7(V0)
9D000E24  30840000   ANDI A0, A0, 0
9D000E28  00831825   OR V1, A0, V1
9D000E2C  A0430007   SB V1, 7(V0)
1329:                    	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
9D000E30  93C20008   LBU V0, 8(S8)
9D000E34  00021880   SLL V1, V0, 2
9D000E38  27828040   ADDIU V0, GP, -32704
9D000E3C  00621021   ADDU V0, V1, V0
9D000E40  8C420000   LW V0, 0(V0)
9D000E44  93C30008   LBU V1, 8(S8)
9D000E48  00032080   SLL A0, V1, 2
9D000E4C  27838040   ADDIU V1, GP, -32704
9D000E50  00831821   ADDU V1, A0, V1
9D000E54  8C630000   LW V1, 0(V1)
9D000E58  90680000   LBU T0, 0(V1)
9D000E5C  310800FF   ANDI T0, T0, 255
9D000E60  90690001   LBU T1, 1(V1)
9D000E64  312900FF   ANDI T1, T1, 255
9D000E68  00094A00   SLL T1, T1, 8
9D000E6C  01284025   OR T0, T1, T0
9D000E70  90690002   LBU T1, 2(V1)
9D000E74  312900FF   ANDI T1, T1, 255
9D000E78  00094C00   SLL T1, T1, 16
9D000E7C  01284025   OR T0, T1, T0
9D000E80  90690003   LBU T1, 3(V1)
9D000E84  312900FF   ANDI T1, T1, 255
9D000E88  00094E00   SLL T1, T1, 24
9D000E8C  01284025   OR T0, T1, T0
9D000E90  01002021   ADDU A0, T0, ZERO
9D000E94  90680004   LBU T0, 4(V1)
9D000E98  310800FF   ANDI T0, T0, 255
9D000E9C  90690005   LBU T1, 5(V1)
9D000EA0  312900FF   ANDI T1, T1, 255
9D000EA4  00094A00   SLL T1, T1, 8
9D000EA8  01284025   OR T0, T1, T0
9D000EAC  90690006   LBU T1, 6(V1)
9D000EB0  312900FF   ANDI T1, T1, 255
9D000EB4  00094C00   SLL T1, T1, 16
9D000EB8  01284025   OR T0, T1, T0
9D000EBC  90630007   LBU V1, 7(V1)
9D000EC0  306300FF   ANDI V1, V1, 255
9D000EC4  00031E00   SLL V1, V1, 24
9D000EC8  00681825   OR V1, V1, T0
9D000ECC  00602821   ADDU A1, V1, ZERO
9D000ED0  38860040   XORI A2, A0, 64
9D000ED4  38A70000   XORI A3, A1, 0
9D000ED8  30C300FF   ANDI V1, A2, 255
9D000EDC  90440000   LBU A0, 0(V0)
9D000EE0  30840000   ANDI A0, A0, 0
9D000EE4  00831825   OR V1, A0, V1
9D000EE8  A0430000   SB V1, 0(V0)
9D000EEC  00061A02   SRL V1, A2, 8
9D000EF0  306300FF   ANDI V1, V1, 255
9D000EF4  90440001   LBU A0, 1(V0)
9D000EF8  30840000   ANDI A0, A0, 0
9D000EFC  00831825   OR V1, A0, V1
9D000F00  A0430001   SB V1, 1(V0)
9D000F04  00061C02   SRL V1, A2, 16
9D000F08  306300FF   ANDI V1, V1, 255
9D000F0C  90440002   LBU A0, 2(V0)
9D000F10  30840000   ANDI A0, A0, 0
9D000F14  00831825   OR V1, A0, V1
9D000F18  A0430002   SB V1, 2(V0)
9D000F1C  00061E02   SRL V1, A2, 24
9D000F20  90440003   LBU A0, 3(V0)
9D000F24  30840000   ANDI A0, A0, 0
9D000F28  00831825   OR V1, A0, V1
9D000F2C  A0430003   SB V1, 3(V0)
9D000F30  30E300FF   ANDI V1, A3, 255
9D000F34  90440004   LBU A0, 4(V0)
9D000F38  30840000   ANDI A0, A0, 0
9D000F3C  00831825   OR V1, A0, V1
9D000F40  A0430004   SB V1, 4(V0)
9D000F44  00071A02   SRL V1, A3, 8
9D000F48  306300FF   ANDI V1, V1, 255
9D000F4C  90440005   LBU A0, 5(V0)
9D000F50  30840000   ANDI A0, A0, 0
9D000F54  00831825   OR V1, A0, V1
9D000F58  A0430005   SB V1, 5(V0)
9D000F5C  00071C02   SRL V1, A3, 16
9D000F60  306300FF   ANDI V1, V1, 255
9D000F64  90440006   LBU A0, 6(V0)
9D000F68  30840000   ANDI A0, A0, 0
9D000F6C  00831825   OR V1, A0, V1
9D000F70  A0430006   SB V1, 6(V0)
9D000F74  00071E02   SRL V1, A3, 24
9D000F78  90440007   LBU A0, 7(V0)
9D000F7C  30840000   ANDI A0, A0, 0
9D000F80  00831825   OR V1, A0, V1
9D000F84  A0430007   SB V1, 7(V0)
1330:                    	
1331:                    	//Need to do additional handling if ping-pong buffering is being used
1332:                        #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1333:                        //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1334:                        //(either due to SIE clearing it after a transaction, or the firmware
1335:                        //clearing it) makes hardware ping pong pointer advance.
1336:                        USBAdvancePingPongBuffer(&pBDTEntryIn[endpoint]);       
9D000F88  27838040   ADDIU V1, GP, -32704
9D000F8C  93C20008   LBU V0, 8(S8)
9D000F90  00021080   SLL V0, V0, 2
9D000F94  00621021   ADDU V0, V1, V0
9D000F98  27848040   ADDIU A0, GP, -32704
9D000F9C  93C30008   LBU V1, 8(S8)
9D000FA0  00031880   SLL V1, V1, 2
9D000FA4  00831821   ADDU V1, A0, V1
9D000FA8  90630000   LBU V1, 0(V1)
9D000FAC  38630008   XORI V1, V1, 8
9D000FB0  306300FF   ANDI V1, V1, 255
9D000FB4  A0430000   SB V1, 0(V0)
1337:                    
1338:                    	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
9D000FB8  93C20008   LBU V0, 8(S8)
9D000FBC  00021880   SLL V1, V0, 2
9D000FC0  27828040   ADDIU V0, GP, -32704
9D000FC4  00621021   ADDU V0, V1, V0
9D000FC8  8C420000   LW V0, 0(V0)
9D000FCC  93C30008   LBU V1, 8(S8)
9D000FD0  00032080   SLL A0, V1, 2
9D000FD4  27838040   ADDIU V1, GP, -32704
9D000FD8  00831821   ADDU V1, A0, V1
9D000FDC  8C630000   LW V1, 0(V1)
9D000FE0  90640000   LBU A0, 0(V1)
9D000FE4  308400FF   ANDI A0, A0, 255
9D000FE8  90630001   LBU V1, 1(V1)
9D000FEC  306300FF   ANDI V1, V1, 255
9D000FF0  00031A00   SLL V1, V1, 8
9D000FF4  00641825   OR V1, V1, A0
9D000FF8  3063FFFF   ANDI V1, V1, -1
9D000FFC  30630040   ANDI V1, V1, 64
9D001000  3063FFFF   ANDI V1, V1, -1
9D001004  306400FF   ANDI A0, V1, 255
9D001008  90450000   LBU A1, 0(V0)
9D00100C  30A50000   ANDI A1, A1, 0
9D001010  00A42025   OR A0, A1, A0
9D001014  A0440000   SB A0, 0(V0)
9D001018  00031A02   SRL V1, V1, 8
9D00101C  3063FFFF   ANDI V1, V1, -1
9D001020  90440001   LBU A0, 1(V0)
9D001024  30840000   ANDI A0, A0, 0
9D001028  00831825   OR V1, A0, V1
9D00102C  A0430001   SB V1, 1(V0)
1339:                    	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
9D001030  93C20008   LBU V0, 8(S8)
9D001034  00021880   SLL V1, V0, 2
9D001038  27828040   ADDIU V0, GP, -32704
9D00103C  00621021   ADDU V0, V1, V0
9D001040  8C420000   LW V0, 0(V0)
9D001044  93C30008   LBU V1, 8(S8)
9D001048  00032080   SLL A0, V1, 2
9D00104C  27838040   ADDIU V1, GP, -32704
9D001050  00831821   ADDU V1, A0, V1
9D001054  8C630000   LW V1, 0(V1)
9D001058  90640000   LBU A0, 0(V1)
9D00105C  308400FF   ANDI A0, A0, 255
9D001060  90630001   LBU V1, 1(V1)
9D001064  306300FF   ANDI V1, V1, 255
9D001068  00031A00   SLL V1, V1, 8
9D00106C  00641825   OR V1, V1, A0
9D001070  3063FFFF   ANDI V1, V1, -1
9D001074  38630040   XORI V1, V1, 64
9D001078  3063FFFF   ANDI V1, V1, -1
9D00107C  306400FF   ANDI A0, V1, 255
9D001080  90450000   LBU A1, 0(V0)
9D001084  30A50000   ANDI A1, A1, 0
9D001088  00A42025   OR A0, A1, A0
9D00108C  A0440000   SB A0, 0(V0)
9D001090  00031A02   SRL V1, V1, 8
9D001094  3063FFFF   ANDI V1, V1, -1
9D001098  90440001   LBU A0, 1(V0)
9D00109C  30840000   ANDI A0, A0, 0
9D0010A0  00831825   OR V1, A0, V1
9D0010A4  A0430001   SB V1, 1(V0)
1340:                        #endif
1341:                    }
1342:                }
9D0010A8  03C0E821   ADDU SP, S8, ZERO
9D0010AC  8FBE0004   LW S8, 4(SP)
9D0010B0  27BD0008   ADDIU SP, SP, 8
9D0010B4  03E00008   JR RA
9D0010B8  00000000   NOP
1343:                
1344:                /**************************************************************************
1345:                    Function:
1346:                        void USBDeviceDetach(void)
1347:                   
1348:                    Summary:
1349:                        This function configures the USB module to "soft detach" itself from
1350:                        the USB host.
1351:                        
1352:                    Description:
1353:                        This function configures the USB module to perform a "soft detach"
1354:                        operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1355:                        lets the host know the device is present and attached.  This will make
1356:                        the host think that the device has been unplugged.  This is potentially
1357:                        useful, as it allows the USB device to force the host to re-enumerate
1358:                        the device (on the firmware has re-enabled the USB module/pull up, by
1359:                        calling USBDeviceAttach(), to "soft re-attach" to the host).
1360:                        
1361:                    Precondition:
1362:                        Should only be called when USB_INTERRUPT is defined.  See remarks
1363:                        section if USB_POLLING mode option is being used (usb_config.h option).
1364:                
1365:                        Additionally, this function should only be called from the main() loop 
1366:                        context.  Do not call this function from within an interrupt handler, as 
1367:                        this function may modify global interrupt enable bits and settings.
1368:                        
1369:                    Parameters:
1370:                        None
1371:                     
1372:                    Return Values:
1373:                        None
1374:                        
1375:                    Remarks:
1376:                        If the application firmware calls USBDeviceDetach(), it is strongly
1377:                        recommended that the firmware wait at least >= 80ms before calling
1378:                        USBDeviceAttach().  If the firmeware performs a soft detach, and then
1379:                        re-attaches too soon (ex: after a few micro seconds for instance), some
1380:                        hosts may interpret this as an unexpected "glitch" rather than as a
1381:                        physical removal/re-attachment of the USB device.  In this case the host
1382:                        may simply ignore the event without re-enumerating the device.  To 
1383:                        ensure that the host properly detects and processes the device soft
1384:                        detach/re-attach, it is recommended to make sure the device remains 
1385:                        detached long enough to mimic a real human controlled USB 
1386:                        unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1387:                        call USBDeviceAttach() for at least 80+ms, preferrably longer.
1388:                        
1389:                        Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1390:                        or take long to execute.  It is the application firmware's 
1391:                        responsibility for adding the 80+ms delay, when using these API 
1392:                        functions.
1393:                        
1394:                        Note: The Windows plug and play event handler processing is fairly 
1395:                        slow, especially in certain versions of Windows, and for certain USB
1396:                        device classes.  It has been observed that some device classes need to
1397:                        provide even more USB detach dwell interval (before calling 
1398:                        USBDeviceAttach()), in order to work correctly after re-enumeration.
1399:                        If the USB device is a CDC class device, it is recommended to wait
1400:                        at least 1.5 seconds or longer, before soft re-attaching to the host,
1401:                        to provide the plug and play event handler enough time to finish 
1402:                        processing the removal event, before the re-attach occurs.
1403:                        
1404:                        If the application is using the USB_POLLING mode option, then the 
1405:                        USBDeviceDetach() and USBDeviceAttach() functions are not available.  
1406:                        In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO" 
1407:                        and "#define USB_BUS_SENSE" options in the 
1408:                        HardwareProfile ï¿½ [platform name].h file. 
1409:                
1410:                        When using the USB_POLLING mode option, and the 
1411:                        "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then 
1412:                        the USB stack assumes that it should always enable the USB module at 
1413:                        pretty much all times.  Basically, anytime the application firmware 
1414:                        calls USBDeviceTasks(), the firmware will automatically enable the USB 
1415:                        module.  This mode would typically be selected if the application was 
1416:                        designed to be a purely bus powered device.  In this case, the 
1417:                        application is powered from the +5V VBUS supply from the USB port, so 
1418:                        it is correct and sensible in this type of application to power up and 
1419:                        turn on the USB module, at anytime that the microcontroller is 
1420:                        powered (which implies the USB cable is attached and the host is also 
1421:                        powered).
1422:                
1423:                        In a self powered application, the USB stack is designed with the 
1424:                        intention that the user will enable the "#define USE_USB_BUS_SENSE_IO" 
1425:                        option in the HardwareProfile ï¿½ [platform name].h file.  When this 
1426:                        option is defined, then the USBDeviceTasks() function will automatically 
1427:                        check the I/O pin port value of the designated pin (based on the 
1428:                        #define USB_BUS_SENSE option in the HardwareProfile ï¿½ [platform name].h 
1429:                        file), every time the application calls USBDeviceTasks().  If the 
1430:                        USBDeviceTasks() function is executed and finds that the pin defined by 
1431:                        the #define USB_BUS_SENSE is in a logic low state, then it will 
1432:                        automatically disable the USB module and tri-state the D+ and D- pins.  
1433:                        If however the USBDeviceTasks() function is executed and finds the pin 
1434:                        defined by the #define USB_BUS_SENSE is in a logic high state, then it 
1435:                        will automatically enable the USB module, if it has not already been 
1436:                        enabled.        
1437:                                                                          
1438:                  **************************************************************************/
1439:                #if defined(USB_INTERRUPT)
1440:                void USBDeviceDetach(void)
1441:                {
1442:                    //If the interrupt option is selected then the customer is required
1443:                    //  to notify the stack when the device is attached or removed from the
1444:                    //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1445:                #ifdef USB_SUPPORT_OTG
1446:                    if (USB_BUS_SENSE != 1)
1447:                #endif
1448:                    {
1449:                         // Disable module & detach from bus
1450:                         U1CON = 0;             
1451:                
1452:                         // Mask all USB interrupts              
1453:                         U1IE = 0;          
1454:                
1455:                         //Move to the detached state                  
1456:                         USBDeviceState = DETACHED_STATE;
1457:                
1458:                         #ifdef  USB_SUPPORT_OTG    
1459:                             //Disable D+ Pullup
1460:                             U1OTGCONbits.DPPULUP = 0;
1461:                
1462:                             //Disable HNP
1463:                             USBOTGDisableHnp();
1464:                
1465:                             //Deactivate HNP
1466:                             USBOTGDeactivateHnp();
1467:                             
1468:                             //If ID Pin Changed State
1469:                             if (USBIDIF && USBIDIE)
1470:                             {  
1471:                                 //Re-detect & Initialize
1472:                                  USBOTGInitialize();
1473:                
1474:                                  //Clear ID Interrupt Flag
1475:                                  USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1476:                             }
1477:                         #endif
1478:                
1479:                         #if defined __C30__ || defined __XC16__
1480:                             //USBClearInterruptFlag(U1OTGIR, 3); 
1481:                         #endif
1482:                            //return so that we don't go through the rest of 
1483:                            //the state machine
1484:                          return;
1485:                    }
1486:                
1487:                #ifdef USB_SUPPORT_OTG
1488:                    //If Session Is Started Then
1489:                   else
1490:                   {
1491:                        //If SRP Is Ready
1492:                        if (USBOTGSRPIsReady())
1493:                        {   
1494:                            //Clear SRPReady
1495:                            USBOTGClearSRPReady();
1496:                
1497:                            //Clear SRP Timeout Flag
1498:                            USBOTGClearSRPTimeOutFlag();
1499:                
1500:                            //Indicate Session Started
1501:                            UART2PrintString( "/r/n***** USB OTG B Event - Session Started  *****/r/n" );
1502:                        }
1503:                    }
1504:                #endif
1505:                }
1506:                #endif  //#if defined(USB_INTERRUPT)
1507:                /**************************************************************************
1508:                    Function:
1509:                        void USBDeviceAttach(void)
1510:                    
1511:                    Summary:
1512:                        Checks if VBUS is present, and that the USB module is not already 
1513:                        initalized, and if so, enables the USB module so as to signal device 
1514:                        attachment to the USB host.   
1515:                
1516:                    Description:
1517:                        This function indicates to the USB host that the USB device has been
1518:                        attached to the bus.  This function needs to be called in order for the
1519:                        device to start to enumerate on the bus.
1520:                                
1521:                    Precondition:
1522:                        Should only be called when USB_INTERRUPT is defined.  Also, should only 
1523:                        be called from the main() loop context.  Do not call USBDeviceAttach()
1524:                        from within an interrupt handler, as the USBDeviceAttach() function
1525:                        may modify global interrupt enable bits and settings.
1526:                
1527:                        For normal USB devices:
1528:                        Make sure that if the module was previously on, that it has been turned off 
1529:                        for a long time (ex: 100ms+) before calling this function to re-enable the module.
1530:                        If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1531:                        pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
1532:                        reject this event, since no human could ever unplug and reattach a USB device in a 
1533:                        microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
1534:                        of glitch and ignore the event altogether.  
1535:                    Parameters:
1536:                        None
1537:                     
1538:                    Return Values:
1539:                        None       
1540:                    
1541:                    Remarks: 
1542:                		See also the USBDeviceDetach() API function documentation.                                                 
1543:                ****************************************************************************/
1544:                #if defined(USB_INTERRUPT)
1545:                void USBDeviceAttach(void)
1546:                {
1547:                    //if we are in the detached state
1548:                    if(USBDeviceState == DETACHED_STATE)
1549:                    {
1550:                        if(USB_BUS_SENSE == 1)
1551:                        {
1552:                    	    //Initialize registers to known states.
1553:                            U1CON = 0;          
1554:                    
1555:                            // Mask all USB interrupts
1556:                            U1IE = 0;                                
1557:                    
1558:                            //Configure things like: pull ups, full/low-speed mode, 
1559:                            //set the ping pong mode, and set internal transceiver
1560:                            SetConfigurationOptions();
1561:                    
1562:                            USBEnableInterrupts();  //Modifies global interrupt settings
1563:                    
1564:                            // Enable module & attach to bus
1565:                            while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
1566:                    
1567:                            //moved to the attached state
1568:                            USBDeviceState = ATTACHED_STATE;
1569:                    
1570:                            #ifdef  USB_SUPPORT_OTG
1571:                                U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
1572:                            #endif
1573:                        }
1574:                    }
1575:                }
1576:                #endif  //#if defined(USB_INTERRUPT)
1577:                
1578:                
1579:                /*******************************************************************************
1580:                  Function: void USBCtrlEPAllowStatusStage(void);
1581:                    
1582:                  Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT 
1583:                            (based on the controlTransferState) to allow the status stage packet
1584:                            of a control transfer to complete.  This function gets used 
1585:                            internally by the USB stack itself, but it may also be called from
1586:                            the application firmware, IF the application firmware called
1587:                            the USBDeferStatusStage() function during the initial processing
1588:                            of the control transfer request.  In this case, the application
1589:                            must call the USBCtrlEPAllowStatusStage() once, after it has fully
1590:                            completed processing and handling the data stage portion of the
1591:                            request.  
1592:                            
1593:                            If the application firmware has no need for delaying control 
1594:                            transfers, and therefore never calls USBDeferStatusStage(), then the
1595:                            application firmware should not call USBCtrlEPAllowStatusStage().
1596:                            
1597:                  Description:
1598:                    
1599:                  Conditions:
1600:                    None
1601:                
1602:                  Input:
1603:                
1604:                  Return:
1605:                
1606:                  Remarks:
1607:                    None                                                                                                          
1608:                  *****************************************************************************/
1609:                void USBCtrlEPAllowStatusStage(void)
1610:                {
9D0010BC  27BDFFF8   ADDIU SP, SP, -8
9D0010C0  AFBE0004   SW S8, 4(SP)
9D0010C4  03A0F021   ADDU S8, SP, ZERO
1611:                    //Check and set two flags, prior to actually modifying any BDT entries.
1612:                    //This double checking is necessary to make certain that 
1613:                    //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1614:                    //in main loop context, while simultaneously getting an interrupt which 
1615:                    //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1616:                    if(USBStatusStageEnabledFlag1 == FALSE)
9D0010C8  8F82804C   LW V0, -32692(GP)
9D0010CC  1440007F   BNE V0, ZERO, 0x9D0012CC
9D0010D0  00000000   NOP
1617:                    {
1618:                        USBStatusStageEnabledFlag1 = TRUE;  
9D0010D4  24020001   ADDIU V0, ZERO, 1
9D0010D8  AF82804C   SW V0, -32692(GP)
1619:                        if(USBStatusStageEnabledFlag2 == FALSE)
9D0010DC  8F828050   LW V0, -32688(GP)
9D0010E0  1440007A   BNE V0, ZERO, 0x9D0012CC
9D0010E4  00000000   NOP
1620:                        {
1621:                            USBStatusStageEnabledFlag2 = TRUE;
9D0010E8  24020001   ADDIU V0, ZERO, 1
9D0010EC  AF828050   SW V0, -32688(GP)
1622:                        
1623:                            //Determine which endpoints (EP0 IN or OUT needs arming for the status
1624:                            //stage), based on the type of control transfer currently pending.
1625:                            if(controlTransferState == CTRL_TRF_RX)
9D0010F0  9383803C   LBU V1, -32708(GP)
9D0010F4  24020002   ADDIU V0, ZERO, 2
9D0010F8  14620015   BNE V1, V0, 0x9D001150
9D0010FC  00000000   NOP
1626:                            {
1627:                                pBDTEntryIn[0]->CNT = 0;
9D001100  8F828040   LW V0, -32704(GP)
9D001104  90430002   LBU V1, 2(V0)
9D001108  30630000   ANDI V1, V1, 0
9D00110C  A0430002   SB V1, 2(V0)
9D001110  90440003   LBU A0, 3(V0)
9D001114  2403FFFC   ADDIU V1, ZERO, -4
9D001118  00831824   AND V1, A0, V1
9D00111C  A0430003   SB V1, 3(V0)
1628:                                pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);        
9D001120  8F828040   LW V0, -32704(GP)
9D001124  90430000   LBU V1, 0(V0)
9D001128  30630000   ANDI V1, V1, 0
9D00112C  00602021   ADDU A0, V1, ZERO
9D001130  2403FFC8   ADDIU V1, ZERO, -56
9D001134  00831825   OR V1, A0, V1
9D001138  A0430000   SB V1, 0(V0)
9D00113C  90430001   LBU V1, 1(V0)
9D001140  30630000   ANDI V1, V1, 0
9D001144  A0430001   SB V1, 1(V0)
9D001148  0B4004B3   J 0x9D0012CC
9D00114C  00000000   NOP
1629:                            }
1630:                            else if(controlTransferState == CTRL_TRF_TX)
9D001150  9383803C   LBU V1, -32708(GP)
9D001154  24020001   ADDIU V0, ZERO, 1
9D001158  1462005C   BNE V1, V0, 0x9D0012CC
9D00115C  00000000   NOP
1631:                            {
1632:                        		BothEP0OutUOWNsSet = FALSE;	//Indicator flag used in USBCtrlTrfOutHandler()
9D001160  AF80805C   SW ZERO, -32676(GP)
1633:                        
1634:                                //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1635:                                //next SETUP packet.
1636:                        		#if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1637:                        		pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
9D001164  8F828078   LW V0, -32648(GP)
9D001168  90430002   LBU V1, 2(V0)
9D00116C  30630000   ANDI V1, V1, 0
9D001170  34630040   ORI V1, V1, 64
9D001174  A0430002   SB V1, 2(V0)
9D001178  90440003   LBU A0, 3(V0)
9D00117C  2403FFFC   ADDIU V1, ZERO, -4
9D001180  00831824   AND V1, A0, V1
9D001184  A0430003   SB V1, 3(V0)
1638:                        		pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
9D001188  8F828078   LW V0, -32648(GP)
9D00118C  2783806C   ADDIU V1, GP, -32660
9D001190  7C63E000   EXT V1, V1, 0, 29
9D001194  306400FF   ANDI A0, V1, 255
9D001198  90450004   LBU A1, 4(V0)
9D00119C  30A50000   ANDI A1, A1, 0
9D0011A0  00A42025   OR A0, A1, A0
9D0011A4  A0440004   SB A0, 4(V0)
9D0011A8  00032202   SRL A0, V1, 8
9D0011AC  308400FF   ANDI A0, A0, 255
9D0011B0  90450005   LBU A1, 5(V0)
9D0011B4  30A50000   ANDI A1, A1, 0
9D0011B8  00A42025   OR A0, A1, A0
9D0011BC  A0440005   SB A0, 5(V0)
9D0011C0  00032402   SRL A0, V1, 16
9D0011C4  308400FF   ANDI A0, A0, 255
9D0011C8  90450006   LBU A1, 6(V0)
9D0011CC  30A50000   ANDI A1, A1, 0
9D0011D0  00A42025   OR A0, A1, A0
9D0011D4  A0440006   SB A0, 6(V0)
9D0011D8  00031E02   SRL V1, V1, 24
9D0011DC  90440007   LBU A0, 7(V0)
9D0011E0  30840000   ANDI A0, A0, 0
9D0011E4  00831825   OR V1, A0, V1
9D0011E8  A0430007   SB V1, 7(V0)
1639:                        		pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_BSTALL; //Prepare endpoint to accept a SETUP transaction
9D0011EC  8F828078   LW V0, -32648(GP)
9D0011F0  90430000   LBU V1, 0(V0)
9D0011F4  30630000   ANDI V1, V1, 0
9D0011F8  00602021   ADDU A0, V1, ZERO
9D0011FC  2403FF84   ADDIU V1, ZERO, -124
9D001200  00831825   OR V1, A0, V1
9D001204  A0430000   SB V1, 0(V0)
9D001208  90430001   LBU V1, 1(V0)
9D00120C  30630000   ANDI V1, V1, 0
9D001210  A0430001   SB V1, 1(V0)
1640:                        		BothEP0OutUOWNsSet = TRUE;	//Indicator flag used in USBCtrlTrfOutHandler()
9D001214  24020001   ADDIU V0, ZERO, 1
9D001218  AF82805C   SW V0, -32676(GP)
1641:                        		#endif
1642:                        
1643:                                //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1644:                        		pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9D00121C  8F828060   LW V0, -32672(GP)
9D001220  90430002   LBU V1, 2(V0)
9D001224  30630000   ANDI V1, V1, 0
9D001228  34630040   ORI V1, V1, 64
9D00122C  A0430002   SB V1, 2(V0)
9D001230  90440003   LBU A0, 3(V0)
9D001234  2403FFFC   ADDIU V1, ZERO, -4
9D001238  00831824   AND V1, A0, V1
9D00123C  A0430003   SB V1, 3(V0)
1645:                        		pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
9D001240  8F828060   LW V0, -32672(GP)
9D001244  2783806C   ADDIU V1, GP, -32660
9D001248  7C63E000   EXT V1, V1, 0, 29
9D00124C  306400FF   ANDI A0, V1, 255
9D001250  90450004   LBU A1, 4(V0)
9D001254  30A50000   ANDI A1, A1, 0
9D001258  00A42025   OR A0, A1, A0
9D00125C  A0440004   SB A0, 4(V0)
9D001260  00032202   SRL A0, V1, 8
9D001264  308400FF   ANDI A0, A0, 255
9D001268  90450005   LBU A1, 5(V0)
9D00126C  30A50000   ANDI A1, A1, 0
9D001270  00A42025   OR A0, A1, A0
9D001274  A0440005   SB A0, 5(V0)
9D001278  00032402   SRL A0, V1, 16
9D00127C  308400FF   ANDI A0, A0, 255
9D001280  90450006   LBU A1, 6(V0)
9D001284  30A50000   ANDI A1, A1, 0
9D001288  00A42025   OR A0, A1, A0
9D00128C  A0440006   SB A0, 6(V0)
9D001290  00031E02   SRL V1, V1, 24
9D001294  90440007   LBU A0, 7(V0)
9D001298  30840000   ANDI A0, A0, 0
9D00129C  00831825   OR V1, A0, V1
9D0012A0  A0430007   SB V1, 7(V0)
1646:                        		pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
9D0012A4  8F828060   LW V0, -32672(GP)
9D0012A8  90430000   LBU V1, 0(V0)
9D0012AC  30630000   ANDI V1, V1, 0
9D0012B0  00602021   ADDU A0, V1, ZERO
9D0012B4  2403FF80   ADDIU V1, ZERO, -128
9D0012B8  00831825   OR V1, A0, V1
9D0012BC  A0430000   SB V1, 0(V0)
9D0012C0  90430001   LBU V1, 1(V0)
9D0012C4  30630000   ANDI V1, V1, 0
9D0012C8  A0430001   SB V1, 1(V0)
1647:                            }
1648:                        }    
1649:                    }
1650:                }   
9D0012CC  03C0E821   ADDU SP, S8, ZERO
9D0012D0  8FBE0004   LW S8, 4(SP)
9D0012D4  27BD0008   ADDIU SP, SP, 8
9D0012D8  03E00008   JR RA
9D0012DC  00000000   NOP
1651:                
1652:                
1653:                /*******************************************************************************
1654:                  Function: void USBCtrlEPAllowDataStage(void);
1655:                    
1656:                  Summary: This function allows the data stage of either a host-to-device or
1657:                            device-to-host control transfer (with data stage) to complete.
1658:                            This function is meant to be used in conjunction with either the
1659:                            USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1660:                            does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1661:                            then the firmware does not need to manually call 
1662:                            USBCtrlEPAllowDataStage(), as the USB stack will call this function
1663:                            instead.
1664:                     
1665:                  Description:
1666:                    
1667:                  Conditions: A control transfer (with data stage) should already be pending, 
1668:                                if the firmware calls this function.  Additionally, the firmware
1669:                                should have called either USBDeferOUTDataStage() or 
1670:                                USBDeferINDataStage() at the start of the control transfer, if
1671:                                the firmware will be calling this function manually.
1672:                
1673:                  Input:
1674:                
1675:                  Return:
1676:                
1677:                  Remarks: 
1678:                  *****************************************************************************/
1679:                void USBCtrlEPAllowDataStage(void)
1680:                {
9D0012E0  27BDFFE8   ADDIU SP, SP, -24
9D0012E4  AFBF0014   SW RA, 20(SP)
9D0012E8  AFBE0010   SW S8, 16(SP)
9D0012EC  03A0F021   ADDU S8, SP, ZERO
1681:                    USBDeferINDataStagePackets = FALSE;
9D0012F0  AF808030   SW ZERO, -32720(GP)
1682:                    USBDeferOUTDataStagePackets = FALSE;
9D0012F4  AF808034   SW ZERO, -32716(GP)
1683:                
1684:                    if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
9D0012F8  9383803C   LBU V1, -32708(GP)
9D0012FC  24020002   ADDIU V0, ZERO, 2
9D001300  14620030   BNE V1, V0, 0x9D0013C4
9D001304  00000000   NOP
1685:                    {
1686:                        //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1687:                        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9D001308  8F828060   LW V0, -32672(GP)
9D00130C  90430002   LBU V1, 2(V0)
9D001310  30630000   ANDI V1, V1, 0
9D001314  34630040   ORI V1, V1, 64
9D001318  A0430002   SB V1, 2(V0)
9D00131C  90440003   LBU A0, 3(V0)
9D001320  2403FFFC   ADDIU V1, ZERO, -4
9D001324  00831824   AND V1, A0, V1
9D001328  A0430003   SB V1, 3(V0)
1688:                        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
9D00132C  8F828060   LW V0, -32672(GP)
9D001330  3C03A000   LUI V1, -24576
9D001334  24630240   ADDIU V1, V1, 576
9D001338  7C63E000   EXT V1, V1, 0, 29
9D00133C  306400FF   ANDI A0, V1, 255
9D001340  90450004   LBU A1, 4(V0)
9D001344  30A50000   ANDI A1, A1, 0
9D001348  00A42025   OR A0, A1, A0
9D00134C  A0440004   SB A0, 4(V0)
9D001350  00032202   SRL A0, V1, 8
9D001354  308400FF   ANDI A0, A0, 255
9D001358  90450005   LBU A1, 5(V0)
9D00135C  30A50000   ANDI A1, A1, 0
9D001360  00A42025   OR A0, A1, A0
9D001364  A0440005   SB A0, 5(V0)
9D001368  00032402   SRL A0, V1, 16
9D00136C  308400FF   ANDI A0, A0, 255
9D001370  90450006   LBU A1, 6(V0)
9D001374  30A50000   ANDI A1, A1, 0
9D001378  00A42025   OR A0, A1, A0
9D00137C  A0440006   SB A0, 6(V0)
9D001380  00031E02   SRL V1, V1, 24
9D001384  90440007   LBU A0, 7(V0)
9D001388  30840000   ANDI A0, A0, 0
9D00138C  00831825   OR V1, A0, V1
9D001390  A0430007   SB V1, 7(V0)
1689:                        pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
9D001394  8F828060   LW V0, -32672(GP)
9D001398  90430000   LBU V1, 0(V0)
9D00139C  30630000   ANDI V1, V1, 0
9D0013A0  00602021   ADDU A0, V1, ZERO
9D0013A4  2403FFC8   ADDIU V1, ZERO, -56
9D0013A8  00831825   OR V1, A0, V1
9D0013AC  A0430000   SB V1, 0(V0)
9D0013B0  90430001   LBU V1, 1(V0)
9D0013B4  30630000   ANDI V1, V1, 0
9D0013B8  A0430001   SB V1, 1(V0)
9D0013BC  0B400524   J 0x9D001490
9D0013C0  00000000   NOP
1690:                    }   
1691:                    else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1692:                    {
1693:                        //Error check the data stage byte count.  Make sure the user specified
1694:                        //value was no greater than the number of bytes the host requested.
1695:                		if(SetupPkt.wLength < inPipes[0].wCount.Val)
9D0013C4  97828072   LHU V0, -32654(GP)
9D0013C8  3043FFFF   ANDI V1, V0, -1
9D0013CC  3C02A000   LUI V0, -24576
9D0013D0  244202C0   ADDIU V0, V0, 704
9D0013D4  94420008   LHU V0, 8(V0)
9D0013D8  0062102B   SLTU V0, V1, V0
9D0013DC  10400006   BEQ V0, ZERO, 0x9D0013F8
9D0013E0  00000000   NOP
1696:                		{
1697:                			inPipes[0].wCount.Val = SetupPkt.wLength;
9D0013E4  97828072   LHU V0, -32654(GP)
9D0013E8  3043FFFF   ANDI V1, V0, -1
9D0013EC  3C02A000   LUI V0, -24576
9D0013F0  244202C0   ADDIU V0, V0, 704
9D0013F4  A4430008   SH V1, 8(V0)
1698:                		}
1699:                		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
9D0013F8  0F40060B   JAL 0x9D00182C
9D0013FC  00000000   NOP
1700:                		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1701:                
1702:                	    //Cnt should have been initialized by responsible request owner (ex: by
1703:                	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1704:                		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
9D001400  8F828040   LW V0, -32704(GP)
9D001404  3C03A000   LUI V1, -24576
9D001408  24630240   ADDIU V1, V1, 576
9D00140C  7C63E000   EXT V1, V1, 0, 29
9D001410  306400FF   ANDI A0, V1, 255
9D001414  90450004   LBU A1, 4(V0)
9D001418  30A50000   ANDI A1, A1, 0
9D00141C  00A42025   OR A0, A1, A0
9D001420  A0440004   SB A0, 4(V0)
9D001424  00032202   SRL A0, V1, 8
9D001428  308400FF   ANDI A0, A0, 255
9D00142C  90450005   LBU A1, 5(V0)
9D001430  30A50000   ANDI A1, A1, 0
9D001434  00A42025   OR A0, A1, A0
9D001438  A0440005   SB A0, 5(V0)
9D00143C  00032402   SRL A0, V1, 16
9D001440  308400FF   ANDI A0, A0, 255
9D001444  90450006   LBU A1, 6(V0)
9D001448  30A50000   ANDI A1, A1, 0
9D00144C  00A42025   OR A0, A1, A0
9D001450  A0440006   SB A0, 6(V0)
9D001454  00031E02   SRL V1, V1, 24
9D001458  90440007   LBU A0, 7(V0)
9D00145C  30840000   ANDI A0, A0, 0
9D001460  00831825   OR V1, A0, V1
9D001464  A0430007   SB V1, 7(V0)
1705:                		pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
9D001468  8F828040   LW V0, -32704(GP)
9D00146C  90430000   LBU V1, 0(V0)
9D001470  30630000   ANDI V1, V1, 0
9D001474  00602021   ADDU A0, V1, ZERO
9D001478  2403FFC8   ADDIU V1, ZERO, -56
9D00147C  00831825   OR V1, A0, V1
9D001480  A0430000   SB V1, 0(V0)
9D001484  90430001   LBU V1, 1(V0)
9D001488  30630000   ANDI V1, V1, 0
9D00148C  A0430001   SB V1, 1(V0)
1706:                    }     
1707:                }    
9D001490  03C0E821   ADDU SP, S8, ZERO
9D001494  8FBF0014   LW RA, 20(SP)
9D001498  8FBE0010   LW S8, 16(SP)
9D00149C  27BD0018   ADDIU SP, SP, 24
9D0014A0  03E00008   JR RA
9D0014A4  00000000   NOP
1708:                
1709:                
1710:                /******************************************************************************/
1711:                /** Internal Functions *********************************************************/
1712:                /******************************************************************************/
1713:                
1714:                /********************************************************************
1715:                 * Function:        void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
1716:                 *
1717:                 * PreCondition:    None
1718:                 *
1719:                 * Input:           BYTE EPNum - the endpoint to be configured
1720:                 *                  BYTE direction - the direction to be configured
1721:                 *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1722:                 *
1723:                 * Output:          None
1724:                 *
1725:                 * Side Effects:    None
1726:                 *
1727:                 * Overview:        This function will configure the specified 
1728:                 *                  endpoint
1729:                 *
1730:                 * Note:            None
1731:                 *******************************************************************/
1732:                static void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
1733:                {
9D0014A8  27BDFFF0   ADDIU SP, SP, -16
9D0014AC  AFBE000C   SW S8, 12(SP)
9D0014B0  03A0F021   ADDU S8, SP, ZERO
9D0014B4  00801821   ADDU V1, A0, ZERO
9D0014B8  00A01021   ADDU V0, A1, ZERO
9D0014BC  A3C30010   SB V1, 16(S8)
9D0014C0  A3C20014   SB V0, 20(S8)
1734:                    volatile BDT_ENTRY* handle;
1735:                
1736:                    //Compute a pointer to the even BDT entry corresponding to the
1737:                    //EPNum and direction values passed to this function.
1738:                    handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
9D0014C4  3C02A000   LUI V0, -24576
9D0014C8  24420200   ADDIU V0, V0, 512
9D0014CC  AFC20000   SW V0, 0(S8)
1739:                    handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
9D0014D0  93C20010   LBU V0, 16(S8)
9D0014D4  00021840   SLL V1, V0, 1
9D0014D8  93C20014   LBU V0, 20(S8)
9D0014DC  00621021   ADDU V0, V1, V0
9D0014E0  00021100   SLL V0, V0, 4
9D0014E4  8FC30000   LW V1, 0(S8)
9D0014E8  00621021   ADDU V0, V1, V0
9D0014EC  AFC20000   SW V0, 0(S8)
1740:                    
1741:                    handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
9D0014F0  8FC30000   LW V1, 0(S8)
9D0014F4  90620000   LBU V0, 0(V1)
9D0014F8  7C0239C4   INS V0, ZERO, 7, 1
9D0014FC  A0620000   SB V0, 0(V1)
1742:                    //already cleared the entire BDT table
1743:                
1744:                    //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1745:                    //for USBTransferOnePacket() API calls.
1746:                    if(direction == OUT_FROM_HOST)
9D001500  93C20014   LBU V0, 20(S8)
9D001504  14400009   BNE V0, ZERO, 0x9D00152C
9D001508  00000000   NOP
1747:                    {
1748:                        pBDTEntryOut[EPNum] = handle;
9D00150C  93C20010   LBU V0, 16(S8)
9D001510  00021880   SLL V1, V0, 2
9D001514  27828054   ADDIU V0, GP, -32684
9D001518  00621021   ADDU V0, V1, V0
9D00151C  8FC30000   LW V1, 0(S8)
9D001520  AC430000   SW V1, 0(V0)
9D001524  0B400551   J 0x9D001544
9D001528  00000000   NOP
1749:                    }
1750:                    else
1751:                    {
1752:                        pBDTEntryIn[EPNum] = handle;
9D00152C  93C20010   LBU V0, 16(S8)
9D001530  00021880   SLL V1, V0, 2
9D001534  27828040   ADDIU V0, GP, -32704
9D001538  00621021   ADDU V0, V1, V0
9D00153C  8FC30000   LW V1, 0(S8)
9D001540  AC430000   SW V1, 0(V0)
1753:                    }
1754:                
1755:                    #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1756:                        handle->STAT.DTS = 0;
9D001544  8FC30000   LW V1, 0(S8)
9D001548  90620000   LBU V0, 0(V1)
9D00154C  7C023184   INS V0, ZERO, 6, 1
9D001550  A0620000   SB V0, 0(V1)
1757:                        (handle+1)->STAT.DTS = 1;
9D001554  8FC20000   LW V0, 0(S8)
9D001558  24430008   ADDIU V1, V0, 8
9D00155C  90620000   LBU V0, 0(V1)
9D001560  24040001   ADDIU A0, ZERO, 1
9D001564  7C823184   INS V0, A0, 6, 1
9D001568  A0620000   SB V0, 0(V1)
1758:                    #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1759:                        //Set DTS to one because the first thing we will do
1760:                        //when transmitting is toggle the bit
1761:                        handle->STAT.DTS = 1;
1762:                    #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1763:                        if(EPNum != 0)
1764:                        {
1765:                            handle->STAT.DTS = 1;
1766:                        }
1767:                    #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1768:                        if(EPNum != 0)
1769:                        {
1770:                            handle->STAT.DTS = 0;
1771:                            (handle+1)->STAT.DTS = 1;
1772:                        }
1773:                    #endif
1774:                }
9D00156C  03C0E821   ADDU SP, S8, ZERO
9D001570  8FBE000C   LW S8, 12(SP)
9D001574  27BD0010   ADDIU SP, SP, 16
9D001578  03E00008   JR RA
9D00157C  00000000   NOP
1775:                
1776:                
1777:                /******************************************************************************
1778:                 * Function:        void USBCtrlEPServiceComplete(void)
1779:                 *
1780:                 * PreCondition:    None
1781:                 *
1782:                 * Input:           None
1783:                 *
1784:                 * Output:          None
1785:                 *
1786:                 * Side Effects:    None
1787:                 *
1788:                 * Overview:        This routine wrap up the remaining tasks in servicing
1789:                 *                  a Setup Request. Its main task is to set the endpoint
1790:                 *                  controls appropriately for a given situation. See code
1791:                 *                  below.
1792:                 *                  There are three main scenarios:
1793:                 *                  a) There was no handler for the Request, in this case
1794:                 *                     a STALL should be sent out.
1795:                 *                  b) The host has requested a read control transfer,
1796:                 *                     endpoints are required to be setup in a specific way.
1797:                 *                  c) The host has requested a write control transfer, or
1798:                 *                     a control data stage is not required, endpoints are
1799:                 *                     required to be setup in a specific way.
1800:                 *
1801:                 *                  Packet processing is resumed by clearing PKTDIS bit.
1802:                 *
1803:                 * Note:            None
1804:                 *****************************************************************************/
1805:                static void USBCtrlEPServiceComplete(void)
1806:                {
9D001580  27BDFFE8   ADDIU SP, SP, -24
9D001584  AFBF0014   SW RA, 20(SP)
9D001588  AFBE0010   SW S8, 16(SP)
9D00158C  03A0F021   ADDU S8, SP, ZERO
1807:                    /*
1808:                     * PKTDIS bit is set when a Setup Transaction is received.
1809:                     * Clear to resume packet processing.
1810:                     */
1811:                    USBPacketDisable = 0;
9D001590  3C03BF88   LUI V1, -16504
9D001594  8C625250   LW V0, 21072(V1)
9D001598  7C022944   INS V0, ZERO, 5, 1
9D00159C  AC625250   SW V0, 21072(V1)
1812:                
1813:                	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1814:                	//control transfer is currently in progress.  We need to know the type of control
1815:                	//transfer that is currently pending, in order to know how to properly arm the 
1816:                	//EP0 IN and EP0 OUT endpoints.
1817:                    if(inPipes[0].info.bits.busy == 0)
9D0015A0  3C02A000   LUI V0, -24576
9D0015A4  244202C0   ADDIU V0, V0, 704
9D0015A8  8C420004   LW V0, 4(V0)
9D0015AC  30420080   ANDI V0, V0, 128
9D0015B0  1440004C   BNE V0, ZERO, 0x9D0016E4
9D0015B4  00000000   NOP
1818:                    {
1819:                        if(outPipes[0].info.bits.busy == 1)
9D0015B8  3C02A000   LUI V0, -24576
9D0015BC  24420310   ADDIU V0, V0, 784
9D0015C0  90430004   LBU V1, 4(V0)
9D0015C4  2402FF80   ADDIU V0, ZERO, -128
9D0015C8  00621024   AND V0, V1, V0
9D0015CC  304200FF   ANDI V0, V0, 255
9D0015D0  1040000C   BEQ V0, ZERO, 0x9D001604
9D0015D4  00000000   NOP
1820:                        {
1821:                            controlTransferState = CTRL_TRF_RX;
9D0015D8  24020002   ADDIU V0, ZERO, 2
9D0015DC  A382803C   SB V0, -32708(GP)
1822:                            /*
1823:                             * Control Write:
1824:                             * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1825:                             */
1826:                
1827:                            //1. Prepare OUT EP to receive data, unless a USB class request handler
1828:                            //   function decided to defer the data stage (ex: because the intended
1829:                            //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1830:                            //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1831:                            //   once it is ready to begin receiving the data.
1832:                            if(USBDeferOUTDataStagePackets == FALSE)
9D0015E0  8F828034   LW V0, -32716(GP)
9D0015E4  14400003   BNE V0, ZERO, 0x9D0015F4
9D0015E8  00000000   NOP
1833:                            {
1834:                                USBCtrlEPAllowDataStage();
9D0015EC  0F4004B8   JAL USBCtrlEPAllowDataStage
9D0015F0  00000000   NOP
1835:                            }
1836:                            
1837:                            //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
1838:                            //after all of the OUT data has been received and consumed, or if a timeout occurs.
1839:                            USBStatusStageEnabledFlag2 = FALSE;
9D0015F4  AF808050   SW ZERO, -32688(GP)
1840:                            USBStatusStageEnabledFlag1 = FALSE;
9D0015F8  AF80804C   SW ZERO, -32692(GP)
9D0015FC  0B400605   J 0x9D001814
9D001600  00000000   NOP
1841:                        }
1842:                        else
1843:                        {
1844:                            /*
1845:                             * If no one knows how to service this request then stall.
1846:                             * Must also prepare EP0 to receive the next SETUP transaction.
1847:                             */
1848:                            pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9D001604  8F828060   LW V0, -32672(GP)
9D001608  90430002   LBU V1, 2(V0)
9D00160C  30630000   ANDI V1, V1, 0
9D001610  34630040   ORI V1, V1, 64
9D001614  A0430002   SB V1, 2(V0)
9D001618  90440003   LBU A0, 3(V0)
9D00161C  2403FFFC   ADDIU V1, ZERO, -4
9D001620  00831824   AND V1, A0, V1
9D001624  A0430003   SB V1, 3(V0)
1849:                            pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
9D001628  8F828060   LW V0, -32672(GP)
9D00162C  2783806C   ADDIU V1, GP, -32660
9D001630  7C63E000   EXT V1, V1, 0, 29
9D001634  306400FF   ANDI A0, V1, 255
9D001638  90450004   LBU A1, 4(V0)
9D00163C  30A50000   ANDI A1, A1, 0
9D001640  00A42025   OR A0, A1, A0
9D001644  A0440004   SB A0, 4(V0)
9D001648  00032202   SRL A0, V1, 8
9D00164C  308400FF   ANDI A0, A0, 255
9D001650  90450005   LBU A1, 5(V0)
9D001654  30A50000   ANDI A1, A1, 0
9D001658  00A42025   OR A0, A1, A0
9D00165C  A0440005   SB A0, 5(V0)
9D001660  00032402   SRL A0, V1, 16
9D001664  308400FF   ANDI A0, A0, 255
9D001668  90450006   LBU A1, 6(V0)
9D00166C  30A50000   ANDI A1, A1, 0
9D001670  00A42025   OR A0, A1, A0
9D001674  A0440006   SB A0, 6(V0)
9D001678  00031E02   SRL V1, V1, 24
9D00167C  90440007   LBU A0, 7(V0)
9D001680  30840000   ANDI A0, A0, 0
9D001684  00831825   OR V1, A0, V1
9D001688  A0430007   SB V1, 7(V0)
1850:                            pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
9D00168C  8F828060   LW V0, -32672(GP)
9D001690  90430000   LBU V1, 0(V0)
9D001694  30630000   ANDI V1, V1, 0
9D001698  00602021   ADDU A0, V1, ZERO
9D00169C  2403FF8C   ADDIU V1, ZERO, -116
9D0016A0  00831825   OR V1, A0, V1
9D0016A4  A0430000   SB V1, 0(V0)
9D0016A8  90430001   LBU V1, 1(V0)
9D0016AC  30630000   ANDI V1, V1, 0
9D0016B0  A0430001   SB V1, 1(V0)
1851:                            pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
9D0016B4  8F828040   LW V0, -32704(GP)
9D0016B8  90430000   LBU V1, 0(V0)
9D0016BC  30630000   ANDI V1, V1, 0
9D0016C0  00602021   ADDU A0, V1, ZERO
9D0016C4  2403FF84   ADDIU V1, ZERO, -124
9D0016C8  00831825   OR V1, A0, V1
9D0016CC  A0430000   SB V1, 0(V0)
9D0016D0  90430001   LBU V1, 1(V0)
9D0016D4  30630000   ANDI V1, V1, 0
9D0016D8  A0430001   SB V1, 1(V0)
9D0016DC  0B400605   J 0x9D001814
9D0016E0  00000000   NOP
1852:                        }
1853:                    }
1854:                    else    // A module has claimed ownership of the control transfer session.
1855:                    {
1856:                		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
9D0016E4  9382806C   LBU V0, -32660(GP)
9D0016E8  304300FF   ANDI V1, V0, 255
9D0016EC  2402FF80   ADDIU V0, ZERO, -128
9D0016F0  00621024   AND V0, V1, V0
9D0016F4  304200FF   ANDI V0, V0, 255
9D0016F8  10400011   BEQ V0, ZERO, 0x9D001740
9D0016FC  00000000   NOP
1857:                		{
1858:                			controlTransferState = CTRL_TRF_TX;
9D001700  24020001   ADDIU V0, ZERO, 1
9D001704  A382803C   SB V0, -32708(GP)
1859:                			/*
1860:                			 * Control Read:
1861:                			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1862:                			 *
1863:                			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1864:                			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1865:                			 *    some slow/currently unavailable resource, such as an external I2C EEPROM),
1866:                			 *    Then the class request handler reponsible should call the USBDeferDataStage()
1867:                			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1868:                			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1869:                			 *    is ready to begin sending the data, it should then call the 
1870:                			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1871:                			 */
1872:                			if(USBDeferINDataStagePackets == FALSE)
9D001708  8F828030   LW V0, -32720(GP)
9D00170C  14400003   BNE V0, ZERO, 0x9D00171C
9D001710  00000000   NOP
1873:                            {
1874:                                USBCtrlEPAllowDataStage();
9D001714  0F4004B8   JAL USBCtrlEPAllowDataStage
9D001718  00000000   NOP
1875:                			}
1876:                
1877:                            // 2. (Optionally) allow the status stage now, to prepare for early termination.
1878:                            //    Note: If a class request handler decided to set USBDeferStatusStagePacket == TRUE,
1879:                            //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1880:                            //    is ready.  If the class request handler does this, it needs to be careful to
1881:                            //    be written so that it can handle the early termination scenario.
1882:                            //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1883:                            //    1.  The desired total number of bytes were sent to the host.
1884:                            //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
1885:                            //        started the control transfer) has been reached.
1886:                            //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
1887:                            //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1888:                            //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1889:                            //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1890:                            //        option can take care of this for you.
1891:                            //    Note: For this type of control transfer, there is normally no harm in simply arming the
1892:                            //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1893:                            //    immediate early termination, without adding unecessary delay.  Therefore, it is generally not
1894:                            //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
1895:                            //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1896:                            //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1897:                            USBStatusStageEnabledFlag2 = FALSE;
9D00171C  AF808050   SW ZERO, -32688(GP)
1898:                            USBStatusStageEnabledFlag1 = FALSE;
9D001720  AF80804C   SW ZERO, -32692(GP)
1899:                            if(USBDeferStatusStagePacket == FALSE)
9D001724  8F82808C   LW V0, -32628(GP)
9D001728  1440003A   BNE V0, ZERO, 0x9D001814
9D00172C  00000000   NOP
1900:                            {
1901:                                USBCtrlEPAllowStatusStage();
9D001730  0F40042F   JAL USBCtrlEPAllowStatusStage
9D001734  00000000   NOP
9D001738  0B400605   J 0x9D001814
9D00173C  00000000   NOP
1902:                            } 
1903:                		}
1904:                		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1905:                		{
1906:                			//This situation occurs for special types of control transfers,
1907:                			//such as that which occurs when the host sends a SET_ADDRESS
1908:                			//control transfer.  Ex:
1909:                			//
1910:                			//<SETUP[0]><IN[1]> | <SETUP[0]>
1911:                				
1912:                			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1913:                			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1914:                			//an IN status stage.
1915:                
1916:                			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
9D001740  24020002   ADDIU V0, ZERO, 2
9D001744  A382803C   SB V0, -32708(GP)
1917:                			
1918:                			//1. Prepare OUT EP to receive the next SETUP packet.
1919:                			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9D001748  8F828060   LW V0, -32672(GP)
9D00174C  90430002   LBU V1, 2(V0)
9D001750  30630000   ANDI V1, V1, 0
9D001754  34630040   ORI V1, V1, 64
9D001758  A0430002   SB V1, 2(V0)
9D00175C  90440003   LBU A0, 3(V0)
9D001760  2403FFFC   ADDIU V1, ZERO, -4
9D001764  00831824   AND V1, A0, V1
9D001768  A0430003   SB V1, 3(V0)
1920:                			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
9D00176C  8F828060   LW V0, -32672(GP)
9D001770  2783806C   ADDIU V1, GP, -32660
9D001774  7C63E000   EXT V1, V1, 0, 29
9D001778  306400FF   ANDI A0, V1, 255
9D00177C  90450004   LBU A1, 4(V0)
9D001780  30A50000   ANDI A1, A1, 0
9D001784  00A42025   OR A0, A1, A0
9D001788  A0440004   SB A0, 4(V0)
9D00178C  00032202   SRL A0, V1, 8
9D001790  308400FF   ANDI A0, A0, 255
9D001794  90450005   LBU A1, 5(V0)
9D001798  30A50000   ANDI A1, A1, 0
9D00179C  00A42025   OR A0, A1, A0
9D0017A0  A0440005   SB A0, 5(V0)
9D0017A4  00032402   SRL A0, V1, 16
9D0017A8  308400FF   ANDI A0, A0, 255
9D0017AC  90450006   LBU A1, 6(V0)
9D0017B0  30A50000   ANDI A1, A1, 0
9D0017B4  00A42025   OR A0, A1, A0
9D0017B8  A0440006   SB A0, 6(V0)
9D0017BC  00031E02   SRL V1, V1, 24
9D0017C0  90440007   LBU A0, 7(V0)
9D0017C4  30840000   ANDI A0, A0, 0
9D0017C8  00831825   OR V1, A0, V1
9D0017CC  A0430007   SB V1, 7(V0)
1921:                			pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
9D0017D0  8F828060   LW V0, -32672(GP)
9D0017D4  90430000   LBU V1, 0(V0)
9D0017D8  30630000   ANDI V1, V1, 0
9D0017DC  00602021   ADDU A0, V1, ZERO
9D0017E0  2403FF84   ADDIU V1, ZERO, -124
9D0017E4  00831825   OR V1, A0, V1
9D0017E8  A0430000   SB V1, 0(V0)
9D0017EC  90430001   LBU V1, 1(V0)
9D0017F0  30630000   ANDI V1, V1, 0
9D0017F4  A0430001   SB V1, 1(V0)
1922:                				
1923:                			//2. Prepare for IN status stage of the control transfer
1924:                            USBStatusStageEnabledFlag2 = FALSE;
9D0017F8  AF808050   SW ZERO, -32688(GP)
1925:                            USBStatusStageEnabledFlag1 = FALSE;
9D0017FC  AF80804C   SW ZERO, -32692(GP)
1926:                			if(USBDeferStatusStagePacket == FALSE)
9D001800  8F82808C   LW V0, -32628(GP)
9D001804  14400003   BNE V0, ZERO, 0x9D001814
9D001808  00000000   NOP
1927:                            {
1928:                                USBCtrlEPAllowStatusStage();
9D00180C  0F40042F   JAL USBCtrlEPAllowStatusStage
9D001810  00000000   NOP
1929:                            } 
1930:                		}
1931:                
1932:                    }//end if(ctrl_trf_session_owner == MUID_NULL)
1933:                
1934:                }//end USBCtrlEPServiceComplete
9D001814  03C0E821   ADDU SP, S8, ZERO
9D001818  8FBF0014   LW RA, 20(SP)
9D00181C  8FBE0010   LW S8, 16(SP)
9D001820  27BD0018   ADDIU SP, SP, 24
9D001824  03E00008   JR RA
9D001828  00000000   NOP
1935:                
1936:                
1937:                /******************************************************************************
1938:                 * Function:        void USBCtrlTrfTxService(void)
1939:                 *
1940:                 * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1941:                 *
1942:                 * Input:           None
1943:                 *
1944:                 * Output:          None
1945:                 *
1946:                 * Side Effects:    None
1947:                 *
1948:                 * Overview:        This routine is used for device to host control transfers 
1949:                 *					(IN transactions).  This function takes care of managing a
1950:                 *                  transfer over multiple USB transactions.
1951:                 *					This routine should be called from only two places.
1952:                 *                  One from USBCtrlEPServiceComplete() and one from
1953:                 *                  USBCtrlTrfInHandler().
1954:                 *
1955:                 * Note:            
1956:                 *****************************************************************************/
1957:                static void USBCtrlTrfTxService(void)
1958:                {
9D00182C  27BDFFF0   ADDIU SP, SP, -16
9D001830  AFBE000C   SW S8, 12(SP)
9D001834  03A0F021   ADDU S8, SP, ZERO
1959:                    BYTE byteToSend;
1960:                
1961:                    //Figure out how many bytes of data to send in the next IN transaction.
1962:                    //Assume a full size packet, unless otherwise determined below.
1963:                    byteToSend = USB_EP0_BUFF_SIZE;         
9D001838  24020040   ADDIU V0, ZERO, 64
9D00183C  A3C20000   SB V0, 0(S8)
1964:                    if(inPipes[0].wCount.Val < (BYTE)USB_EP0_BUFF_SIZE)
9D001840  3C02A000   LUI V0, -24576
9D001844  244202C0   ADDIU V0, V0, 704
9D001848  94420008   LHU V0, 8(V0)
9D00184C  2C420040   SLTIU V0, V0, 64
9D001850  10400012   BEQ V0, ZERO, 0x9D00189C
9D001854  00000000   NOP
1965:                    {
1966:                        byteToSend = inPipes[0].wCount.Val;
9D001858  3C02A000   LUI V0, -24576
9D00185C  244202C0   ADDIU V0, V0, 704
9D001860  94420008   LHU V0, 8(V0)
9D001864  A3C20000   SB V0, 0(S8)
1967:                
1968:                        //Keep track of whether or not we have sent a "short packet" yet.
1969:                        //This is useful so that later on, we can configure EP0 IN to STALL,
1970:                        //after we have sent all of the intended data.  This makes sure the
1971:                        //hardware STALLs if the host erroneously tries to send more IN token 
1972:                        //packets, requesting more data than intended in the control transfer.
1973:                        if(shortPacketStatus == SHORT_PKT_NOT_USED)
9D001868  93828076   LBU V0, -32650(GP)
9D00186C  14400005   BNE V0, ZERO, 0x9D001884
9D001870  00000000   NOP
1974:                        {
1975:                            shortPacketStatus = SHORT_PKT_PENDING;
9D001874  24020001   ADDIU V0, ZERO, 1
9D001878  A3828076   SB V0, -32650(GP)
9D00187C  0B400627   J 0x9D00189C
9D001880  00000000   NOP
1976:                        }
1977:                        else if(shortPacketStatus == SHORT_PKT_PENDING)
9D001884  93838076   LBU V1, -32650(GP)
9D001888  24020001   ADDIU V0, ZERO, 1
9D00188C  14620003   BNE V1, V0, 0x9D00189C
9D001890  00000000   NOP
1978:                        {
1979:                            shortPacketStatus = SHORT_PKT_SENT;
9D001894  24020002   ADDIU V0, ZERO, 2
9D001898  A3828076   SB V0, -32650(GP)
1980:                        }
1981:                    }
1982:                
1983:                    //Keep track of how many bytes remain to be sent in the transfer, by
1984:                    //subtracting the number of bytes about to be sent from the total.
1985:                    inPipes[0].wCount.Val = inPipes[0].wCount.Val - byteToSend;
9D00189C  3C02A000   LUI V0, -24576
9D0018A0  244202C0   ADDIU V0, V0, 704
9D0018A4  94430008   LHU V1, 8(V0)
9D0018A8  93C20000   LBU V0, 0(S8)
9D0018AC  3042FFFF   ANDI V0, V0, -1
9D0018B0  00621023   SUBU V0, V1, V0
9D0018B4  3043FFFF   ANDI V1, V0, -1
9D0018B8  3C02A000   LUI V0, -24576
9D0018BC  244202C0   ADDIU V0, V0, 704
9D0018C0  A4430008   SH V1, 8(V0)
1986:                    
1987:                    //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1988:                    //Note: Control endpoints may never have a max packet size of > 64 bytes.
1989:                    //Therefore, the BC8 and BC9 bits should always be maintained clear.
1990:                    pBDTEntryIn[0]->CNT = byteToSend;
9D0018C4  8F828040   LW V0, -32704(GP)
9D0018C8  93C30000   LBU V1, 0(S8)
9D0018CC  306303FF   ANDI V1, V1, 1023
9D0018D0  3063FFFF   ANDI V1, V1, -1
9D0018D4  306400FF   ANDI A0, V1, 255
9D0018D8  90450002   LBU A1, 2(V0)
9D0018DC  30A50000   ANDI A1, A1, 0
9D0018E0  00A42025   OR A0, A1, A0
9D0018E4  A0440002   SB A0, 2(V0)
9D0018E8  00031A02   SRL V1, V1, 8
9D0018EC  3063FFFF   ANDI V1, V1, -1
9D0018F0  30630003   ANDI V1, V1, 3
9D0018F4  30630003   ANDI V1, V1, 3
9D0018F8  90450003   LBU A1, 3(V0)
9D0018FC  2404FFFC   ADDIU A0, ZERO, -4
9D001900  00A42024   AND A0, A1, A0
9D001904  00831825   OR V1, A0, V1
9D001908  A0430003   SB V1, 3(V0)
1991:                
1992:                    //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1993:                    //which we will send to the host.
1994:                    pDst = (USB_VOLATILE BYTE*)CtrlTrfData;                // Set destination pointer
9D00190C  3C02A000   LUI V0, -24576
9D001910  24420240   ADDIU V0, V0, 576
9D001914  AF82802C   SW V0, -32724(GP)
1995:                    if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
9D001918  3C02A000   LUI V0, -24576
9D00191C  244202C0   ADDIU V0, V0, 704
9D001920  8C420004   LW V0, 4(V0)
9D001924  30420001   ANDI V0, V0, 1
9D001928  14400022   BNE V0, ZERO, 0x9D0019B4
9D00192C  00000000   NOP
1996:                    {
1997:                        while(byteToSend)
9D001930  0B40065B   J 0x9D00196C
9D001934  00000000   NOP
9D00196C  93C20000   LBU V0, 0(S8)
9D001970  1440FFF1   BNE V0, ZERO, 0x9D001938
9D001974  00000000   NOP
9D001978  0B400670   J 0x9D0019C0
9D00197C  00000000   NOP
1998:                        {
1999:                            *pDst++ = *inPipes[0].pSrc.bRom++;
9D001938  8F83802C   LW V1, -32724(GP)
9D00193C  3C02A000   LUI V0, -24576
9D001940  8C4202C0   LW V0, 704(V0)
9D001944  90440000   LBU A0, 0(V0)
9D001948  A0640000   SB A0, 0(V1)
9D00194C  24630001   ADDIU V1, V1, 1
9D001950  AF83802C   SW V1, -32724(GP)
9D001954  24430001   ADDIU V1, V0, 1
9D001958  3C02A000   LUI V0, -24576
9D00195C  AC4302C0   SW V1, 704(V0)
2000:                            byteToSend--;
9D001960  93C20000   LBU V0, 0(S8)
9D001964  2442FFFF   ADDIU V0, V0, -1
9D001968  A3C20000   SB V0, 0(S8)
2001:                        }//end while(byte_to_send.Val)
2002:                    }
2003:                    else  // RAM
2004:                    {
2005:                        while(byteToSend)
9D0019B4  93C20000   LBU V0, 0(S8)
9D0019B8  1440FFF1   BNE V0, ZERO, 0x9D001980
9D0019BC  00000000   NOP
2006:                        {
2007:                            *pDst++ = *inPipes[0].pSrc.bRam++;
9D001980  8F83802C   LW V1, -32724(GP)
9D001984  3C02A000   LUI V0, -24576
9D001988  8C4202C0   LW V0, 704(V0)
9D00198C  90440000   LBU A0, 0(V0)
9D001990  A0640000   SB A0, 0(V1)
9D001994  24630001   ADDIU V1, V1, 1
9D001998  AF83802C   SW V1, -32724(GP)
9D00199C  24430001   ADDIU V1, V0, 1
9D0019A0  3C02A000   LUI V0, -24576
9D0019A4  AC4302C0   SW V1, 704(V0)
2008:                            byteToSend--;
9D0019A8  93C20000   LBU V0, 0(S8)
9D0019AC  2442FFFF   ADDIU V0, V0, -1
9D0019B0  A3C20000   SB V0, 0(S8)
2009:                        }//end while(byte_to_send.Val)
2010:                    }//end if(usb_stat.ctrl_trf_mem == _ROM)
2011:                }//end USBCtrlTrfTxService
9D0019C0  03C0E821   ADDU SP, S8, ZERO
9D0019C4  8FBE000C   LW S8, 12(SP)
9D0019C8  27BD0010   ADDIU SP, SP, 16
9D0019CC  03E00008   JR RA
9D0019D0  00000000   NOP
2012:                
2013:                /******************************************************************************
2014:                 * Function:        void USBCtrlTrfRxService(void)
2015:                 *
2016:                 * PreCondition:    pDst and wCount are setup properly.
2017:                 *                  pSrc is always &CtrlTrfData
2018:                 *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
2019:                 *                  wCount should be set to 0 at the start of each control
2020:                 *                  transfer.
2021:                 *
2022:                 * Input:           None
2023:                 *
2024:                 * Output:          None
2025:                 *
2026:                 * Side Effects:    None
2027:                 *
2028:                 * Overview:        This routine is used for host to device control transfers
2029:                 *					(uses OUT transactions).  This function receives the data that arrives
2030:                 *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
2031:                 *					buffer.  Once the host has sent all the data it was intending
2032:                 *					to send, this function will call the appropriate outPipes[0].pFunc()
2033:                 *					handler (unless it is NULL), so that it can be used by the
2034:                 *					intended target firmware.
2035:                 *
2036:                 * Note:            None
2037:                 *****************************************************************************/
2038:                static void USBCtrlTrfRxService(void)
2039:                {
9D0019D4  27BDFFE0   ADDIU SP, SP, -32
9D0019D8  AFBF001C   SW RA, 28(SP)
9D0019DC  AFBE0018   SW S8, 24(SP)
9D0019E0  03A0F021   ADDU S8, SP, ZERO
2040:                    BYTE byteToRead;
2041:                    BYTE i;
2042:                
2043:                    //Load byteToRead with the number of bytes the host just sent us in the 
2044:                    //last OUT transaction.
2045:                    byteToRead = pBDTEntryEP0OutCurrent->CNT;   
9D0019E4  8F828078   LW V0, -32648(GP)
9D0019E8  90430002   LBU V1, 2(V0)
9D0019EC  306300FF   ANDI V1, V1, 255
9D0019F0  90420003   LBU V0, 3(V0)
9D0019F4  304200FF   ANDI V0, V0, 255
9D0019F8  30420003   ANDI V0, V0, 3
9D0019FC  00021200   SLL V0, V0, 8
9D001A00  00431025   OR V0, V0, V1
9D001A04  3042FFFF   ANDI V0, V0, -1
9D001A08  A3C20010   SB V0, 16(S8)
2046:                
2047:                    //Update the "outPipes[0].wCount.Val", which keeps track of the total number
2048:                    //of remaining bytes expected to be received from the host, in the control
2049:                    //transfer.  First check to see if the host sent us more bytes than the
2050:                    //application firmware was expecting to receive.
2051:                    if(byteToRead > outPipes[0].wCount.Val)
9D001A0C  93C20010   LBU V0, 16(S8)
9D001A10  3043FFFF   ANDI V1, V0, -1
9D001A14  3C02A000   LUI V0, -24576
9D001A18  24420310   ADDIU V0, V0, 784
9D001A1C  8C420004   LW V0, 4(V0)
9D001A20  7C427A00   EXT V0, V0, 8, 16
9D001A24  3042FFFF   ANDI V0, V0, -1
9D001A28  0043102B   SLTU V0, V0, V1
9D001A2C  10400007   BEQ V0, ZERO, 0x9D001A4C
9D001A30  00000000   NOP
2052:                    {
2053:                        byteToRead = outPipes[0].wCount.Val;
9D001A34  3C02A000   LUI V0, -24576
9D001A38  24420310   ADDIU V0, V0, 784
9D001A3C  8C420004   LW V0, 4(V0)
9D001A40  7C427A00   EXT V0, V0, 8, 16
9D001A44  3042FFFF   ANDI V0, V0, -1
9D001A48  A3C20010   SB V0, 16(S8)
2054:                    }	
2055:                    //Reduce the number of remaining bytes by the number we just received.
2056:                	outPipes[0].wCount.Val = outPipes[0].wCount.Val - byteToRead;   
9D001A4C  3C02A000   LUI V0, -24576
9D001A50  24420310   ADDIU V0, V0, 784
9D001A54  8C420004   LW V0, 4(V0)
9D001A58  7C427A00   EXT V0, V0, 8, 16
9D001A5C  3043FFFF   ANDI V1, V0, -1
9D001A60  93C20010   LBU V0, 16(S8)
9D001A64  3042FFFF   ANDI V0, V0, -1
9D001A68  00621023   SUBU V0, V1, V0
9D001A6C  3044FFFF   ANDI A0, V0, -1
9D001A70  3C02A000   LUI V0, -24576
9D001A74  24430310   ADDIU V1, V0, 784
9D001A78  8C620004   LW V0, 4(V1)
9D001A7C  7C82BA04   INS V0, A0, 8, 16
9D001A80  AC620004   SW V0, 4(V1)
2057:                
2058:                    //Copy the OUT DATAx packet bytes that we just received from the host,
2059:                    //into the user application buffer space.
2060:                    for(i=0;i<byteToRead;i++)
9D001A84  A3C00011   SB ZERO, 17(S8)
9D001A88  0B4006B3   J 0x9D001ACC
9D001A8C  00000000   NOP
9D001AC0  93C20011   LBU V0, 17(S8)
9D001AC4  24420001   ADDIU V0, V0, 1
9D001AC8  A3C20011   SB V0, 17(S8)
9D001ACC  93C30011   LBU V1, 17(S8)
9D001AD0  93C20010   LBU V0, 16(S8)
9D001AD4  0062102B   SLTU V0, V1, V0
9D001AD8  1440FFED   BNE V0, ZERO, 0x9D001A90
9D001ADC  00000000   NOP
2061:                    {
2062:                        *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
9D001A90  3C02A000   LUI V0, -24576
9D001A94  8C420310   LW V0, 784(V0)
9D001A98  93C40011   LBU A0, 17(S8)
9D001A9C  3C03A000   LUI V1, -24576
9D001AA0  24630240   ADDIU V1, V1, 576
9D001AA4  00831821   ADDU V1, A0, V1
9D001AA8  90630000   LBU V1, 0(V1)
9D001AAC  306300FF   ANDI V1, V1, 255
9D001AB0  A0430000   SB V1, 0(V0)
9D001AB4  24430001   ADDIU V1, V0, 1
9D001AB8  3C02A000   LUI V0, -24576
9D001ABC  AC430310   SW V1, 784(V0)
2063:                    }//end while(byteToRead.Val)
2064:                
2065:                    //If there is more data to receive, prepare EP0 OUT so that it can receive 
2066:                	//the next packet in the sequence.
2067:                    if(outPipes[0].wCount.Val > 0)
9D001AE0  3C02A000   LUI V0, -24576
9D001AE4  24420310   ADDIU V0, V0, 784
9D001AE8  8C420004   LW V0, 4(V0)
9D001AEC  7C427A00   EXT V0, V0, 8, 16
9D001AF0  3042FFFF   ANDI V0, V0, -1
9D001AF4  10400043   BEQ V0, ZERO, 0x9D001C04
9D001AF8  00000000   NOP
2068:                    {
2069:                        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9D001AFC  8F828060   LW V0, -32672(GP)
9D001B00  90430002   LBU V1, 2(V0)
9D001B04  30630000   ANDI V1, V1, 0
9D001B08  34630040   ORI V1, V1, 64
9D001B0C  A0430002   SB V1, 2(V0)
9D001B10  90440003   LBU A0, 3(V0)
9D001B14  2403FFFC   ADDIU V1, ZERO, -4
9D001B18  00831824   AND V1, A0, V1
9D001B1C  A0430003   SB V1, 3(V0)
2070:                        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
9D001B20  8F828060   LW V0, -32672(GP)
9D001B24  3C03A000   LUI V1, -24576
9D001B28  24630240   ADDIU V1, V1, 576
9D001B2C  7C63E000   EXT V1, V1, 0, 29
9D001B30  306400FF   ANDI A0, V1, 255
9D001B34  90450004   LBU A1, 4(V0)
9D001B38  30A50000   ANDI A1, A1, 0
9D001B3C  00A42025   OR A0, A1, A0
9D001B40  A0440004   SB A0, 4(V0)
9D001B44  00032202   SRL A0, V1, 8
9D001B48  308400FF   ANDI A0, A0, 255
9D001B4C  90450005   LBU A1, 5(V0)
9D001B50  30A50000   ANDI A1, A1, 0
9D001B54  00A42025   OR A0, A1, A0
9D001B58  A0440005   SB A0, 5(V0)
9D001B5C  00032402   SRL A0, V1, 16
9D001B60  308400FF   ANDI A0, A0, 255
9D001B64  90450006   LBU A1, 6(V0)
9D001B68  30A50000   ANDI A1, A1, 0
9D001B6C  00A42025   OR A0, A1, A0
9D001B70  A0440006   SB A0, 6(V0)
9D001B74  00031E02   SRL V1, V1, 24
9D001B78  90440007   LBU A0, 7(V0)
9D001B7C  30840000   ANDI A0, A0, 0
9D001B80  00831825   OR V1, A0, V1
9D001B84  A0430007   SB V1, 7(V0)
2071:                        if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
9D001B88  8F828078   LW V0, -32648(GP)
9D001B8C  90420000   LBU V0, 0(V0)
9D001B90  304200FF   ANDI V0, V0, 255
9D001B94  30420040   ANDI V0, V0, 64
9D001B98  304200FF   ANDI V0, V0, 255
9D001B9C  1440000D   BNE V0, ZERO, 0x9D001BD4
9D001BA0  00000000   NOP
2072:                        {
2073:                            pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
9D001BA4  8F828060   LW V0, -32672(GP)
9D001BA8  90430000   LBU V1, 0(V0)
9D001BAC  30630000   ANDI V1, V1, 0
9D001BB0  00602021   ADDU A0, V1, ZERO
9D001BB4  2403FFC8   ADDIU V1, ZERO, -56
9D001BB8  00831825   OR V1, A0, V1
9D001BBC  A0430000   SB V1, 0(V0)
9D001BC0  90430001   LBU V1, 1(V0)
9D001BC4  30630000   ANDI V1, V1, 0
9D001BC8  A0430001   SB V1, 1(V0)
9D001BCC  0B400747   J 0x9D001D1C
9D001BD0  00000000   NOP
2074:                        }
2075:                        else
2076:                        {
2077:                            pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
9D001BD4  8F828060   LW V0, -32672(GP)
9D001BD8  90430000   LBU V1, 0(V0)
9D001BDC  30630000   ANDI V1, V1, 0
9D001BE0  00602021   ADDU A0, V1, ZERO
9D001BE4  2403FF88   ADDIU V1, ZERO, -120
9D001BE8  00831825   OR V1, A0, V1
9D001BEC  A0430000   SB V1, 0(V0)
9D001BF0  90430001   LBU V1, 1(V0)
9D001BF4  30630000   ANDI V1, V1, 0
9D001BF8  A0430001   SB V1, 1(V0)
9D001BFC  0B400747   J 0x9D001D1C
9D001C00  00000000   NOP
2078:                        }
2079:                    }
2080:                    else
2081:                    {
2082:                	    //We have received all OUT packets that we were expecting to
2083:                	    //receive for the control transfer.  Prepare EP0 OUT to receive
2084:                		//the next SETUP transaction that may arrive.
2085:                        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9D001C04  8F828060   LW V0, -32672(GP)
9D001C08  90430002   LBU V1, 2(V0)
9D001C0C  30630000   ANDI V1, V1, 0
9D001C10  34630040   ORI V1, V1, 64
9D001C14  A0430002   SB V1, 2(V0)
9D001C18  90440003   LBU A0, 3(V0)
9D001C1C  2403FFFC   ADDIU V1, ZERO, -4
9D001C20  00831824   AND V1, A0, V1
9D001C24  A0430003   SB V1, 3(V0)
2086:                        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
9D001C28  8F828060   LW V0, -32672(GP)
9D001C2C  2783806C   ADDIU V1, GP, -32660
9D001C30  7C63E000   EXT V1, V1, 0, 29
9D001C34  306400FF   ANDI A0, V1, 255
9D001C38  90450004   LBU A1, 4(V0)
9D001C3C  30A50000   ANDI A1, A1, 0
9D001C40  00A42025   OR A0, A1, A0
9D001C44  A0440004   SB A0, 4(V0)
9D001C48  00032202   SRL A0, V1, 8
9D001C4C  308400FF   ANDI A0, A0, 255
9D001C50  90450005   LBU A1, 5(V0)
9D001C54  30A50000   ANDI A1, A1, 0
9D001C58  00A42025   OR A0, A1, A0
9D001C5C  A0440005   SB A0, 5(V0)
9D001C60  00032402   SRL A0, V1, 16
9D001C64  308400FF   ANDI A0, A0, 255
9D001C68  90450006   LBU A1, 6(V0)
9D001C6C  30A50000   ANDI A1, A1, 0
9D001C70  00A42025   OR A0, A1, A0
9D001C74  A0440006   SB A0, 6(V0)
9D001C78  00031E02   SRL V1, V1, 24
9D001C7C  90440007   LBU A0, 7(V0)
9D001C80  30840000   ANDI A0, A0, 0
9D001C84  00831825   OR V1, A0, V1
9D001C88  A0430007   SB V1, 7(V0)
2087:                        //Configure EP0 OUT to receive the next SETUP transaction for any future
2088:                        //control transfers.  However, set BSTALL in case the host tries to send
2089:                        //more data than it claims it was going to send.
2090:                        pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
9D001C8C  8F828060   LW V0, -32672(GP)
9D001C90  90430000   LBU V1, 0(V0)
9D001C94  30630000   ANDI V1, V1, 0
9D001C98  00602021   ADDU A0, V1, ZERO
9D001C9C  2403FF84   ADDIU V1, ZERO, -124
9D001CA0  00831825   OR V1, A0, V1
9D001CA4  A0430000   SB V1, 0(V0)
9D001CA8  90430001   LBU V1, 1(V0)
9D001CAC  30630000   ANDI V1, V1, 0
9D001CB0  A0430001   SB V1, 1(V0)
2091:                
2092:                		//All data bytes for the host to device control write (OUT) have now been
2093:                		//received successfully.
2094:                		//Go ahead and call the user specified callback function, to use/consume
2095:                		//the control transfer data (ex: if the "void (*function)" parameter 
2096:                		//was non-NULL when USBEP0Receive() was called).
2097:                        if(outPipes[0].pFunc != NULL)
9D001CB4  3C02A000   LUI V0, -24576
9D001CB8  24420310   ADDIU V0, V0, 784
9D001CBC  8843000A   LWL V1, 10(V0)
9D001CC0  00602021   ADDU A0, V1, ZERO
9D001CC4  98440007   LWR A0, 7(V0)
9D001CC8  00801021   ADDU V0, A0, ZERO
9D001CCC  10400009   BEQ V0, ZERO, 0x9D001CF4
9D001CD0  00000000   NOP
2098:                        {
2099:                            outPipes[0].pFunc();
9D001CD4  3C02A000   LUI V0, -24576
9D001CD8  24420310   ADDIU V0, V0, 784
9D001CDC  8843000A   LWL V1, 10(V0)
9D001CE0  00602021   ADDU A0, V1, ZERO
9D001CE4  98440007   LWR A0, 7(V0)
9D001CE8  00801021   ADDU V0, A0, ZERO
9D001CEC  0040F809   JALR V0
9D001CF0  00000000   NOP
2100:                        }
2101:                        outPipes[0].info.bits.busy = 0;    
9D001CF4  3C02A000   LUI V0, -24576
9D001CF8  24430310   ADDIU V1, V0, 784
9D001CFC  8C620004   LW V0, 4(V1)
9D001D00  7C0239C4   INS V0, ZERO, 7, 1
9D001D04  AC620004   SW V0, 4(V1)
2102:                
2103:                        //Ready to arm status stage IN transaction now, if the application
2104:                        //firmware has completed processing the request.  If it is still busy
2105:                        //and needs more time to finish handling the request, then the user
2106:                        //callback (the one called by the outPipes[0].pFunc();) should set the
2107:                        //USBDeferStatusStagePacket to TRUE (by calling USBDeferStatusStage()).  In 
2108:                        //this case, it is the application's firmware responsibility to call 
2109:                        //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
2110:                        //Note: The application firmware must process the request and call
2111:                        //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
2112:                        //means either 50ms, 500ms, or 5 seconds, depending on the type of
2113:                        //control transfer.  See the USB 2.0 specification section 9.2.6 for
2114:                        //more details.
2115:                        if(USBDeferStatusStagePacket == FALSE)
9D001D08  8F82808C   LW V0, -32628(GP)
9D001D0C  14400003   BNE V0, ZERO, 0x9D001D1C
9D001D10  00000000   NOP
2116:                        {
2117:                            USBCtrlEPAllowStatusStage();
9D001D14  0F40042F   JAL USBCtrlEPAllowStatusStage
9D001D18  00000000   NOP
2118:                        }            
2119:                    }    
2120:                
2121:                }//end USBCtrlTrfRxService
9D001D1C  03C0E821   ADDU SP, S8, ZERO
9D001D20  8FBF001C   LW RA, 28(SP)
9D001D24  8FBE0018   LW S8, 24(SP)
9D001D28  27BD0020   ADDIU SP, SP, 32
9D001D2C  03E00008   JR RA
9D001D30  00000000   NOP
2122:                
2123:                
2124:                /********************************************************************
2125:                 * Function:        void USBStdSetCfgHandler(void)
2126:                 *
2127:                 * PreCondition:    None
2128:                 *
2129:                 * Input:           None
2130:                 *
2131:                 * Output:          None
2132:                 *
2133:                 * Side Effects:    None
2134:                 *
2135:                 * Overview:        This routine first disables all endpoints by
2136:                 *                  clearing UEP registers. It then configures
2137:                 *                  (initializes) endpoints by calling the callback
2138:                 *                  function USBCBInitEP().
2139:                 *
2140:                 * Note:            None
2141:                 *******************************************************************/
2142:                void USBStdSetCfgHandler(void)
2143:                {
9D001D34  27BDFFE0   ADDIU SP, SP, -32
9D001D38  AFBF001C   SW RA, 28(SP)
9D001D3C  AFBE0018   SW S8, 24(SP)
9D001D40  03A0F021   ADDU S8, SP, ZERO
2144:                    BYTE i;
2145:                
2146:                    // This will generate a zero length packet
2147:                    inPipes[0].info.bits.busy = 1;            
9D001D44  3C02A000   LUI V0, -24576
9D001D48  244302C0   ADDIU V1, V0, 704
9D001D4C  8C620004   LW V0, 4(V1)
9D001D50  24040001   ADDIU A0, ZERO, 1
9D001D54  7C8239C4   INS V0, A0, 7, 1
9D001D58  AC620004   SW V0, 4(V1)
2148:                
2149:                    //Clear all of the endpoint control registers
2150:                    DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
9D001D5C  3C02BF88   LUI V0, -16504
9D001D60  24425310   ADDIU V0, V0, 21264
9D001D64  AFC20014   SW V0, 20(S8)
9D001D68  A3C00011   SB ZERO, 17(S8)
9D001D6C  0B400765   J 0x9D001D94
9D001D70  00000000   NOP
9D001D74  8FC20014   LW V0, 20(S8)
9D001D78  AC400000   SW ZERO, 0(V0)
9D001D7C  8FC20014   LW V0, 20(S8)
9D001D80  24420010   ADDIU V0, V0, 16
9D001D84  AFC20014   SW V0, 20(S8)
9D001D88  93C20011   LBU V0, 17(S8)
9D001D8C  24420001   ADDIU V0, V0, 1
9D001D90  A3C20011   SB V0, 17(S8)
9D001D94  93C20011   LBU V0, 17(S8)
9D001D98  1040FFF6   BEQ V0, ZERO, 0x9D001D74
9D001D9C  00000000   NOP
2151:                
2152:                    //Clear all of the BDT entries
2153:                    for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
9D001DA0  A3C00010   SB ZERO, 16(S8)
9D001DA4  0B400777   J 0x9D001DDC
9D001DA8  00000000   NOP
9D001DD0  93C20010   LBU V0, 16(S8)
9D001DD4  24420001   ADDIU V0, V0, 1
9D001DD8  A3C20010   SB V0, 16(S8)
9D001DDC  93C20010   LBU V0, 16(S8)
9D001DE0  2C420008   SLTIU V0, V0, 8
9D001DE4  1440FFF1   BNE V0, ZERO, 0x9D001DAC
9D001DE8  00000000   NOP
2154:                    {
2155:                        BDT[i].Val = 0x00;
9D001DAC  93C30010   LBU V1, 16(S8)
9D001DB0  3C02A000   LUI V0, -24576
9D001DB4  000318C0   SLL V1, V1, 3
9D001DB8  24420200   ADDIU V0, V0, 512
9D001DBC  00621021   ADDU V0, V1, V0
9D001DC0  00002021   ADDU A0, ZERO, ZERO
9D001DC4  00002821   ADDU A1, ZERO, ZERO
9D001DC8  AC440000   SW A0, 0(V0)
9D001DCC  AC450004   SW A1, 4(V0)
2156:                    }
2157:                
2158:                    // Assert reset request to all of the Ping Pong buffer pointers
2159:                    USBPingPongBufferReset = 1;                                   
9D001DEC  3C03BF88   LUI V1, -16504
9D001DF0  8C625250   LW V0, 21072(V1)
9D001DF4  24040001   ADDIU A0, ZERO, 1
9D001DF8  7C820844   INS V0, A0, 1, 1
9D001DFC  AC625250   SW V0, 21072(V1)
2160:                
2161:                	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
2162:                	//the EVEN buffer being the next one that will be used), since we are also 
2163:                	//doing a hardware ping pong pointer reset above.
2164:                	for(i = 0; i < (BYTE)(USB_MAX_EP_NUMBER+1u); i++)
9D001E00  A3C00010   SB ZERO, 16(S8)
9D001E04  0B40078E   J 0x9D001E38
9D001E08  00000000   NOP
9D001E2C  93C20010   LBU V0, 16(S8)
9D001E30  24420001   ADDIU V0, V0, 1
9D001E34  A3C20010   SB V0, 16(S8)
9D001E38  93C20010   LBU V0, 16(S8)
9D001E3C  2C420002   SLTIU V0, V0, 2
9D001E40  1440FFF2   BNE V0, ZERO, 0x9D001E0C
9D001E44  00000000   NOP
2165:                	{
2166:                		ep_data_in[i].Val = 0u;
9D001E0C  93C30010   LBU V1, 16(S8)
9D001E10  27828074   ADDIU V0, GP, -32652
9D001E14  00621021   ADDU V0, V1, V0
9D001E18  A0400000   SB ZERO, 0(V0)
2167:                        ep_data_out[i].Val = 0u;
9D001E1C  93C30010   LBU V1, 16(S8)
9D001E20  27828048   ADDIU V0, GP, -32696
9D001E24  00621021   ADDU V0, V1, V0
9D001E28  A0400000   SB ZERO, 0(V0)
2168:                	}
2169:                
2170:                    //clear the alternate interface settings
2171:                    memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
9D001E48  27848088   ADDIU A0, GP, -32632
9D001E4C  00002821   ADDU A1, ZERO, ZERO
9D001E50  24060001   ADDIU A2, ZERO, 1
9D001E54  7740161E   JALX memset
9D001E58  00000000   NOP
2172:                
2173:                    //Stop trying to reset ping pong buffer pointers
2174:                    USBPingPongBufferReset = 0;
9D001E5C  3C03BF88   LUI V1, -16504
9D001E60  8C625250   LW V0, 21072(V1)
9D001E64  7C020844   INS V0, ZERO, 1, 1
9D001E68  AC625250   SW V0, 21072(V1)
2175:                
2176:                    pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
9D001E6C  3C02A000   LUI V0, -24576
9D001E70  24420210   ADDIU V0, V0, 528
9D001E74  AF828040   SW V0, -32704(GP)
2177:                
2178:                	//Set the next out to the current out packet
2179:                    pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
9D001E78  3C02A000   LUI V0, -24576
9D001E7C  24420200   ADDIU V0, V0, 512
9D001E80  AF828078   SW V0, -32648(GP)
2180:                    pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
9D001E84  8F828078   LW V0, -32648(GP)
9D001E88  AF828060   SW V0, -32672(GP)
2181:                
2182:                    //set the current configuration
2183:                    USBActiveConfiguration = SetupPkt.bConfigurationValue;
9D001E8C  9382806E   LBU V0, -32658(GP)
9D001E90  304200FF   ANDI V0, V0, 255
9D001E94  A382807C   SB V0, -32644(GP)
2184:                
2185:                    //if the configuration value == 0
2186:                    if(USBActiveConfiguration == 0)
9D001E98  9382807C   LBU V0, -32644(GP)
9D001E9C  14400005   BNE V0, ZERO, 0x9D001EB4
9D001EA0  00000000   NOP
2187:                    {
2188:                        //Go back to the addressed state
2189:                        USBDeviceState = ADDRESS_STATE;
9D001EA4  24020010   ADDIU V0, ZERO, 16
9D001EA8  AF828038   SW V0, -32712(GP)
9D001EAC  0B4007B4   J 0x9D001ED0
9D001EB0  00000000   NOP
2190:                    }
2191:                    else
2192:                    {
2193:                        //initialize the required endpoints
2194:                        USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
9D001EB4  24040001   ADDIU A0, ZERO, 1
9D001EB8  2785807C   ADDIU A1, GP, -32644
9D001EBC  24060001   ADDIU A2, ZERO, 1
9D001EC0  0F401375   JAL USER_USB_CALLBACK_EVENT_HANDLER
9D001EC4  00000000   NOP
2195:                
2196:                        //Otherwise go to the configured state.  Update the state variable last,
2197:                        //after performing all of the set configuration related initialization
2198:                        //tasks.
2199:                        USBDeviceState = CONFIGURED_STATE;		
9D001EC8  24020020   ADDIU V0, ZERO, 32
9D001ECC  AF828038   SW V0, -32712(GP)
2200:                    }//end if(SetupPkt.bConfigurationValue == 0)
2201:                }//end USBStdSetCfgHandler
9D001ED0  03C0E821   ADDU SP, S8, ZERO
9D001ED4  8FBF001C   LW RA, 28(SP)
9D001ED8  8FBE0018   LW S8, 24(SP)
9D001EDC  27BD0020   ADDIU SP, SP, 32
9D001EE0  03E00008   JR RA
9D001EE4  00000000   NOP
2202:                
2203:                
2204:                /********************************************************************
2205:                 * Function:        void USBStdGetDscHandler(void)
2206:                 *
2207:                 * PreCondition:    None
2208:                 *
2209:                 * Input:           None
2210:                 *
2211:                 * Output:          None
2212:                 *
2213:                 * Side Effects:    None
2214:                 *
2215:                 * Overview:        This routine handles the standard GET_DESCRIPTOR
2216:                 *                  request.
2217:                 *
2218:                 * Note:            None
2219:                 *******************************************************************/
2220:                static void USBStdGetDscHandler(void)
2221:                {
9D001EE8  27BDFFF8   ADDIU SP, SP, -8
9D001EEC  AFBE0004   SW S8, 4(SP)
9D001EF0  03A0F021   ADDU S8, SP, ZERO
2222:                    if(SetupPkt.bmRequestType == 0x80)
9D001EF4  9382806C   LBU V0, -32660(GP)
9D001EF8  304300FF   ANDI V1, V0, 255
9D001EFC  24020080   ADDIU V0, ZERO, 128
9D001F00  14620053   BNE V1, V0, 0x9D002050
9D001F04  00000000   NOP
2223:                    {
2224:                        inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
9D001F08  3C02A000   LUI V0, -24576
9D001F0C  244202C0   ADDIU V0, V0, 704
9D001F10  2403FFC0   ADDIU V1, ZERO, -64
9D001F14  A0430004   SB V1, 4(V0)
2225:                
2226:                        switch(SetupPkt.bDescriptorType)
9D001F18  9382806F   LBU V0, -32657(GP)
9D001F1C  304200FF   ANDI V0, V0, 255
9D001F20  24030002   ADDIU V1, ZERO, 2
9D001F24  10430011   BEQ V0, V1, 0x9D001F6C
9D001F28  00000000   NOP
9D001F2C  24030003   ADDIU V1, ZERO, 3
9D001F30  10430027   BEQ V0, V1, 0x9D001FD0
9D001F34  00000000   NOP
9D001F38  24030001   ADDIU V1, ZERO, 1
9D001F3C  14430040   BNE V0, V1, 0x9D002040
9D001F40  00000000   NOP
2227:                        {
2228:                            case USB_DESCRIPTOR_DEVICE:
2229:                                #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2230:                                    inPipes[0].pSrc.bRom = (ROM BYTE*)&device_dsc;
2231:                                #else
2232:                                    inPipes[0].pSrc.bRom = (ROM BYTE*)USB_USER_DEVICE_DESCRIPTOR;
9D001F44  3C02A000   LUI V0, -24576
9D001F48  3C039D00   LUI V1, -25344
9D001F4C  2463550C   ADDIU V1, V1, 21772
9D001F50  AC4302C0   SW V1, 704(V0)
2233:                                #endif
2234:                                inPipes[0].wCount.Val = sizeof(device_dsc);
9D001F54  3C02A000   LUI V0, -24576
9D001F58  244202C0   ADDIU V0, V0, 704
9D001F5C  24030012   ADDIU V1, ZERO, 18
9D001F60  A4430008   SH V1, 8(V0)
2235:                                break;
9D001F64  0B400814   J 0x9D002050
9D001F68  00000000   NOP
2236:                            case USB_DESCRIPTOR_CONFIGURATION:
2237:                                #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2238:                                    inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2239:                                #else
2240:                                    inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
9D001F6C  9382806E   LBU V0, -32658(GP)
9D001F70  304200FF   ANDI V0, V0, 255
9D001F74  00021880   SLL V1, V0, 2
9D001F78  3C029D00   LUI V0, -25344
9D001F7C  244255CC   ADDIU V0, V0, 21964
9D001F80  00621021   ADDU V0, V1, V0
9D001F84  8C430000   LW V1, 0(V0)
9D001F88  3C02A000   LUI V0, -24576
9D001F8C  AC4302C0   SW V1, 704(V0)
2241:                                #endif
2242:                
2243:                                //This must be loaded using byte addressing.  The source pointer
2244:                                //  may not be word aligned for the 16 or 32 bit machines resulting
2245:                                //  in an address error on the dereference.
2246:                                inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
9D001F90  3C02A000   LUI V0, -24576
9D001F94  8C4202C0   LW V0, 704(V0)
9D001F98  24420002   ADDIU V0, V0, 2
9D001F9C  90430000   LBU V1, 0(V0)
9D001FA0  3C02A000   LUI V0, -24576
9D001FA4  244202C0   ADDIU V0, V0, 704
9D001FA8  A0430008   SB V1, 8(V0)
2247:                                inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
9D001FAC  3C02A000   LUI V0, -24576
9D001FB0  8C4202C0   LW V0, 704(V0)
9D001FB4  24420003   ADDIU V0, V0, 3
9D001FB8  90430000   LBU V1, 0(V0)
9D001FBC  3C02A000   LUI V0, -24576
9D001FC0  244202C0   ADDIU V0, V0, 704
9D001FC4  A0430009   SB V1, 9(V0)
2248:                                break;
9D001FC8  0B400814   J 0x9D002050
9D001FCC  00000000   NOP
2249:                            case USB_DESCRIPTOR_STRING:
2250:                                //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2251:                                //  later it is now manditory.  This should be defined in usb_config.h and should
2252:                                //  indicate the number of string descriptors.
2253:                                if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
9D001FD0  9382806E   LBU V0, -32658(GP)
9D001FD4  304200FF   ANDI V0, V0, 255
9D001FD8  2C420003   SLTIU V0, V0, 3
9D001FDC  10400013   BEQ V0, ZERO, 0x9D00202C
9D001FE0  00000000   NOP
2254:                                {
2255:                                    //Get a pointer to the String descriptor requested
2256:                                    inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
9D001FE4  9382806E   LBU V0, -32658(GP)
9D001FE8  304200FF   ANDI V0, V0, 255
9D001FEC  00021880   SLL V1, V0, 2
9D001FF0  3C029D00   LUI V0, -25344
9D001FF4  244255D0   ADDIU V0, V0, 21968
9D001FF8  00621021   ADDU V0, V1, V0
9D001FFC  8C430000   LW V1, 0(V0)
9D002000  3C02A000   LUI V0, -24576
9D002004  AC4302C0   SW V1, 704(V0)
2257:                                    // Set data count
2258:                                    inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
9D002008  3C02A000   LUI V0, -24576
9D00200C  8C4202C0   LW V0, 704(V0)
9D002010  90420000   LBU V0, 0(V0)
9D002014  00401821   ADDU V1, V0, ZERO
9D002018  3C02A000   LUI V0, -24576
9D00201C  244202C0   ADDIU V0, V0, 704
9D002020  A4430008   SH V1, 8(V0)
2259:                                }
2260:                                else
2261:                                {
2262:                                    inPipes[0].info.Val = 0;
9D00202C  3C02A000   LUI V0, -24576
9D002030  244202C0   ADDIU V0, V0, 704
9D002034  A0400004   SB ZERO, 4(V0)
2263:                                }
2264:                                break;
9D002024  0B400814   J 0x9D002050
9D002028  00000000   NOP
9D002038  0B400814   J 0x9D002050
9D00203C  00000000   NOP
2265:                            default:
2266:                                inPipes[0].info.Val = 0;
9D002040  3C02A000   LUI V0, -24576
9D002044  244202C0   ADDIU V0, V0, 704
9D002048  A0400004   SB ZERO, 4(V0)
2267:                                break;
9D00204C  00000000   NOP
2268:                        }//end switch
2269:                    }//end if
2270:                }//end USBStdGetDscHandler
9D002050  03C0E821   ADDU SP, S8, ZERO
9D002054  8FBE0004   LW S8, 4(SP)
9D002058  27BD0008   ADDIU SP, SP, 8
9D00205C  03E00008   JR RA
9D002060  00000000   NOP
2271:                
2272:                /********************************************************************
2273:                 * Function:        void USBStdGetStatusHandler(void)
2274:                 *
2275:                 * PreCondition:    None
2276:                 *
2277:                 * Input:           None
2278:                 *
2279:                 * Output:          None
2280:                 *
2281:                 * Side Effects:    None
2282:                 *
2283:                 * Overview:        This routine handles the standard GET_STATUS request
2284:                 *
2285:                 * Note:            None
2286:                 *******************************************************************/
2287:                void USBStdGetStatusHandler(void)
2288:                {
9D002064  27BDFFF0   ADDIU SP, SP, -16
9D002068  AFBE000C   SW S8, 12(SP)
9D00206C  03A0F021   ADDU S8, SP, ZERO
2289:                    CtrlTrfData[0] = 0;                 // Initialize content
9D002070  3C02A000   LUI V0, -24576
9D002074  A0400240   SB ZERO, 576(V0)
2290:                    CtrlTrfData[1] = 0;
9D002078  3C02A000   LUI V0, -24576
9D00207C  24420240   ADDIU V0, V0, 576
9D002080  A0400001   SB ZERO, 1(V0)
2291:                
2292:                    switch(SetupPkt.Recipient)
9D002084  8F82806C   LW V0, -32660(GP)
9D002088  7C422000   EXT V0, V0, 0, 5
9D00208C  304200FF   ANDI V0, V0, 255
9D002090  24030001   ADDIU V1, ZERO, 1
9D002094  10430020   BEQ V0, V1, 0x9D002118
9D002098  00000000   NOP
9D00209C  24030002   ADDIU V1, ZERO, 2
9D0020A0  10430025   BEQ V0, V1, 0x9D002138
9D0020A4  00000000   NOP
9D0020A8  1440005B   BNE V0, ZERO, 0x9D002218
9D0020AC  00000000   NOP
2293:                    {
2294:                        case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2295:                            inPipes[0].info.bits.busy = 1;
9D0020B0  3C02A000   LUI V0, -24576
9D0020B4  244302C0   ADDIU V1, V0, 704
9D0020B8  8C620004   LW V0, 4(V1)
9D0020BC  24040001   ADDIU A0, ZERO, 1
9D0020C0  7C8239C4   INS V0, A0, 7, 1
9D0020C4  AC620004   SW V0, 4(V1)
2296:                            /*
2297:                             * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2298:                             *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2299:                             */
2300:                            if(self_power == 1) // self_power is defined in HardwareProfile.h
2301:                            {
2302:                                CtrlTrfData[0]|=0x01;
9D0020C8  3C02A000   LUI V0, -24576
9D0020CC  90420240   LBU V0, 576(V0)
9D0020D0  304200FF   ANDI V0, V0, 255
9D0020D4  34420001   ORI V0, V0, 1
9D0020D8  304300FF   ANDI V1, V0, 255
9D0020DC  3C02A000   LUI V0, -24576
9D0020E0  A0430240   SB V1, 576(V0)
2303:                            }
2304:                
2305:                            if(RemoteWakeup == TRUE)
9D0020E4  8F838080   LW V1, -32640(GP)
9D0020E8  24020001   ADDIU V0, ZERO, 1
9D0020EC  14620043   BNE V1, V0, 0x9D0021FC
9D0020F0  00000000   NOP
2306:                            {
2307:                                CtrlTrfData[0]|=0x02;
9D0020F4  3C02A000   LUI V0, -24576
9D0020F8  90420240   LBU V0, 576(V0)
9D0020FC  304200FF   ANDI V0, V0, 255
9D002100  34420002   ORI V0, V0, 2
9D002104  304300FF   ANDI V1, V0, 255
9D002108  3C02A000   LUI V0, -24576
9D00210C  A0430240   SB V1, 576(V0)
2308:                            }
2309:                            break;
9D002110  0B400886   J 0x9D002218
9D002114  00000000   NOP
9D0021FC  00000000   NOP
9D002200  0B400886   J 0x9D002218
9D002204  00000000   NOP
2310:                        case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2311:                            inPipes[0].info.bits.busy = 1;     // No data to update
9D002118  3C02A000   LUI V0, -24576
9D00211C  244302C0   ADDIU V1, V0, 704
9D002120  8C620004   LW V0, 4(V1)
9D002124  24040001   ADDIU A0, ZERO, 1
9D002128  7C8239C4   INS V0, A0, 7, 1
9D00212C  AC620004   SW V0, 4(V1)
2312:                            break;
9D002130  0B400886   J 0x9D002218
9D002134  00000000   NOP
2313:                        case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2314:                            inPipes[0].info.bits.busy = 1;
9D002138  3C02A000   LUI V0, -24576
9D00213C  244302C0   ADDIU V1, V0, 704
9D002140  8C620004   LW V0, 4(V1)
9D002144  24040001   ADDIU A0, ZERO, 1
9D002148  7C8239C4   INS V0, A0, 7, 1
9D00214C  AC620004   SW V0, 4(V1)
2315:                            /*
2316:                             * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2317:                             */
2318:                            {
2319:                                BDT_ENTRY *p;
2320:                
2321:                                if(SetupPkt.EPDir == 0)
9D002150  93828070   LBU V0, -32656(GP)
9D002154  304300FF   ANDI V1, V0, 255
9D002158  2402FF80   ADDIU V0, ZERO, -128
9D00215C  00621024   AND V0, V1, V0
9D002160  304200FF   ANDI V0, V0, 255
9D002164  1440000B   BNE V0, ZERO, 0x9D002194
9D002168  00000000   NOP
2322:                                {
2323:                                    p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
9D00216C  8F828070   LW V0, -32656(GP)
9D002170  7C421800   EXT V0, V0, 0, 4
9D002174  304200FF   ANDI V0, V0, 255
9D002178  00021880   SLL V1, V0, 2
9D00217C  27828054   ADDIU V0, GP, -32684
9D002180  00621021   ADDU V0, V1, V0
9D002184  8C420000   LW V0, 0(V0)
9D002188  AFC20000   SW V0, 0(S8)
9D00218C  0B40086D   J 0x9D0021B4
9D002190  00000000   NOP
2324:                                }
2325:                                else
2326:                                {
2327:                                    p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
9D002194  8F828070   LW V0, -32656(GP)
9D002198  7C421800   EXT V0, V0, 0, 4
9D00219C  304200FF   ANDI V0, V0, 255
9D0021A0  00021880   SLL V1, V0, 2
9D0021A4  27828040   ADDIU V0, GP, -32704
9D0021A8  00621021   ADDU V0, V1, V0
9D0021AC  8C420000   LW V0, 0(V0)
9D0021B0  AFC20000   SW V0, 0(S8)
2328:                                }
2329:                
2330:                                if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
9D0021B4  8FC20000   LW V0, 0(S8)
9D0021B8  90430000   LBU V1, 0(V0)
9D0021BC  2402FF80   ADDIU V0, ZERO, -128
9D0021C0  00621024   AND V0, V1, V0
9D0021C4  304200FF   ANDI V0, V0, 255
9D0021C8  1040000F   BEQ V0, ZERO, 0x9D002208
9D0021CC  00000000   NOP
9D0021D0  8FC20000   LW V0, 0(S8)
9D0021D4  90420000   LBU V0, 0(V0)
9D0021D8  30420004   ANDI V0, V0, 4
9D0021DC  304200FF   ANDI V0, V0, 255
9D0021E0  1040000C   BEQ V0, ZERO, 0x9D002214
9D0021E4  00000000   NOP
2331:                                    CtrlTrfData[0]=0x01;    // Set bit0
9D0021E8  3C02A000   LUI V0, -24576
9D0021EC  24030001   ADDIU V1, ZERO, 1
9D0021F0  A0430240   SB V1, 576(V0)
2332:                                break;
9D0021F4  0B400886   J 0x9D002218
9D0021F8  00000000   NOP
9D002208  00000000   NOP
9D00220C  0B400886   J 0x9D002218
9D002210  00000000   NOP
9D002214  00000000   NOP
2333:                            }
2334:                    }//end switch
2335:                
2336:                    if(inPipes[0].info.bits.busy == 1)
9D002218  3C02A000   LUI V0, -24576
9D00221C  244202C0   ADDIU V0, V0, 704
9D002220  8C420004   LW V0, 4(V0)
9D002224  30420080   ANDI V0, V0, 128
9D002228  1040000F   BEQ V0, ZERO, 0x9D002268
9D00222C  00000000   NOP
2337:                    {
2338:                        inPipes[0].pSrc.bRam = (BYTE*)&CtrlTrfData;            // Set Source
9D002230  3C02A000   LUI V0, -24576
9D002234  3C03A000   LUI V1, -24576
9D002238  24630240   ADDIU V1, V1, 576
9D00223C  AC4302C0   SW V1, 704(V0)
2339:                        inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
9D002240  3C02A000   LUI V0, -24576
9D002244  244302C0   ADDIU V1, V0, 704
9D002248  8C620004   LW V0, 4(V1)
9D00224C  24040001   ADDIU A0, ZERO, 1
9D002250  7C820004   INS V0, A0, 0, 1
9D002254  AC620004   SW V0, 4(V1)
2340:                        inPipes[0].wCount.v[0] = 2;                         // Set data count
9D002258  3C02A000   LUI V0, -24576
9D00225C  244202C0   ADDIU V0, V0, 704
9D002260  24030002   ADDIU V1, ZERO, 2
9D002264  A0430008   SB V1, 8(V0)
2341:                    }//end if(...)
2342:                }//end USBStdGetStatusHandler
9D002268  03C0E821   ADDU SP, S8, ZERO
9D00226C  8FBE000C   LW S8, 12(SP)
9D002270  27BD0010   ADDIU SP, SP, 16
9D002274  03E00008   JR RA
9D002278  00000000   NOP
2343:                
2344:                /********************************************************************
2345:                 * Function:        void USBStallHandler(void)
2346:                 *
2347:                 * PreCondition:    None
2348:                 *
2349:                 * Input:           None
2350:                 *
2351:                 * Output:          None
2352:                 *
2353:                 * Side Effects:    
2354:                 *
2355:                 * Overview:        This function handles the event of a STALL 
2356:                 *                  occuring on the bus
2357:                 *
2358:                 * Note:            None
2359:                 *******************************************************************/
2360:                static void USBStallHandler(void)
2361:                {
9D00227C  27BDFFF8   ADDIU SP, SP, -8
9D002280  AFBE0004   SW S8, 4(SP)
9D002284  03A0F021   ADDU S8, SP, ZERO
2362:                    /*
2363:                     * Does not really have to do anything here,
2364:                     * even for the control endpoint.
2365:                     * All BDs of Endpoint 0 are owned by SIE right now,
2366:                     * but once a Setup Transaction is received, the ownership
2367:                     * for EP0_OUT will be returned to CPU.
2368:                     * When the Setup Transaction is serviced, the ownership
2369:                     * for EP0_IN will then be forced back to CPU by firmware.
2370:                     */
2371:                
2372:                    /* v2b fix */
2373:                    if(U1EP0bits.EPSTALL == 1)
9D002288  3C02BF88   LUI V0, -16504
9D00228C  8C425300   LW V0, 21248(V0)
9D002290  30420002   ANDI V0, V0, 2
9D002294  10400025   BEQ V0, ZERO, 0x9D00232C
9D002298  00000000   NOP
2374:                    {
2375:                        // UOWN - if 0, owned by CPU, if 1, owned by SIE
2376:                        if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
9D00229C  8F828078   LW V0, -32648(GP)
9D0022A0  90430000   LBU V1, 0(V0)
9D0022A4  306300FF   ANDI V1, V1, 255
9D0022A8  90420001   LBU V0, 1(V0)
9D0022AC  304200FF   ANDI V0, V0, 255
9D0022B0  00021200   SLL V0, V0, 8
9D0022B4  00431025   OR V0, V0, V1
9D0022B8  3043FFFF   ANDI V1, V0, -1
9D0022BC  24020080   ADDIU V0, ZERO, 128
9D0022C0  14620016   BNE V1, V0, 0x9D00231C
9D0022C4  00000000   NOP
9D0022C8  8F828040   LW V0, -32704(GP)
9D0022CC  90430000   LBU V1, 0(V0)
9D0022D0  306300FF   ANDI V1, V1, 255
9D0022D4  90420001   LBU V0, 1(V0)
9D0022D8  304200FF   ANDI V0, V0, 255
9D0022DC  00021200   SLL V0, V0, 8
9D0022E0  00431025   OR V0, V0, V1
9D0022E4  3043FFFF   ANDI V1, V0, -1
9D0022E8  24020084   ADDIU V0, ZERO, 132
9D0022EC  1462000B   BNE V1, V0, 0x9D00231C
9D0022F0  00000000   NOP
2377:                        {
2378:                            // Set ep0Bo to stall also
2379:                            pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
9D0022F4  8F828078   LW V0, -32648(GP)
9D0022F8  90430000   LBU V1, 0(V0)
9D0022FC  30630000   ANDI V1, V1, 0
9D002300  00602021   ADDU A0, V1, ZERO
9D002304  2403FF8C   ADDIU V1, ZERO, -116
9D002308  00831825   OR V1, A0, V1
9D00230C  A0430000   SB V1, 0(V0)
9D002310  90430001   LBU V1, 1(V0)
9D002314  30630000   ANDI V1, V1, 0
9D002318  A0430001   SB V1, 1(V0)
2380:                        }//end if
2381:                        U1EP0bits.EPSTALL = 0;               // Clear stall status
9D00231C  3C03BF88   LUI V1, -16504
9D002320  8C625300   LW V0, 21248(V1)
9D002324  7C020844   INS V0, ZERO, 1, 1
9D002328  AC625300   SW V0, 21248(V1)
2382:                    }//end if
2383:                
2384:                    USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
9D00232C  3C02BF88   LUI V0, -16504
9D002330  24030080   ADDIU V1, ZERO, 128
9D002334  AC435200   SW V1, 20992(V0)
2385:                }
9D002338  03C0E821   ADDU SP, S8, ZERO
9D00233C  8FBE0004   LW S8, 4(SP)
9D002340  27BD0008   ADDIU SP, SP, 8
9D002344  03E00008   JR RA
9D002348  00000000   NOP
2386:                
2387:                /********************************************************************
2388:                 * Function:        void USBSuspend(void)
2389:                 *
2390:                 * PreCondition:    None
2391:                 *
2392:                 * Input:           None
2393:                 *
2394:                 * Output:          None
2395:                 *
2396:                 * Side Effects:    
2397:                 *
2398:                 * Overview:        This function handles if the host tries to 
2399:                 *                  suspend the device
2400:                 *
2401:                 * Note:            None
2402:                 *******************************************************************/
2403:                static void USBSuspend(void)
2404:                {
9D00234C  27BDFFE8   ADDIU SP, SP, -24
9D002350  AFBF0014   SW RA, 20(SP)
9D002354  AFBE0010   SW S8, 16(SP)
9D002358  03A0F021   ADDU S8, SP, ZERO
2405:                    /*
2406:                     * NOTE: Do not clear UIRbits.ACTVIF here!
2407:                     * Reason:
2408:                     * ACTVIF is only generated once an IDLEIF has been generated.
2409:                     * This is a 1:1 ratio interrupt generation.
2410:                     * For every IDLEIF, there will be only one ACTVIF regardless of
2411:                     * the number of subsequent bus transitions.
2412:                     *
2413:                     * If the ACTIF is cleared here, a problem could occur when:
2414:                     * [       IDLE       ][bus activity ->
2415:                     * <--- 3 ms ----->     ^
2416:                     *                ^     ACTVIF=1
2417:                     *                IDLEIF=1
2418:                     *  #           #           #           #   (#=Program polling flags)
2419:                     *                          ^
2420:                     *                          This polling loop will see both
2421:                     *                          IDLEIF=1 and ACTVIF=1.
2422:                     *                          However, the program services IDLEIF first
2423:                     *                          because ACTIVIE=0.
2424:                     *                          If this routine clears the only ACTIVIF,
2425:                     *                          then it can never get out of the suspend
2426:                     *                          mode.
2427:                     */
2428:                    USBActivityIE = 1;                     // Enable bus activity interrupt
9D00235C  3C03BF88   LUI V1, -16504
9D002360  8C625050   LW V0, 20560(V1)
9D002364  24040001   ADDIU A0, ZERO, 1
9D002368  7C822104   INS V0, A0, 4, 1
9D00236C  AC625050   SW V0, 20560(V1)
2429:                    USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
9D002370  3C02BF88   LUI V0, -16504
9D002374  24030010   ADDIU V1, ZERO, 16
9D002378  AC435200   SW V1, 20992(V0)
2430:                
2431:                #if defined(__18CXX)
2432:                    U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
2433:                                                            // mode, SIE clock inactive
2434:                #endif
2435:                    USBBusIsSuspended = TRUE;
9D00237C  24020001   ADDIU V0, ZERO, 1
9D002380  AF828064   SW V0, -32668(GP)
2436:                 
2437:                    /*
2438:                     * At this point the PIC can go into sleep,idle, or
2439:                     * switch to a slower clock, etc.  This should be done in the
2440:                     * USBCBSuspend() if necessary.
2441:                     */
2442:                    USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
9D002384  24040075   ADDIU A0, ZERO, 117
9D002388  00002821   ADDU A1, ZERO, ZERO
9D00238C  00003021   ADDU A2, ZERO, ZERO
9D002390  0F401375   JAL USER_USB_CALLBACK_EVENT_HANDLER
9D002394  00000000   NOP
2443:                }
9D002398  03C0E821   ADDU SP, S8, ZERO
9D00239C  8FBF0014   LW RA, 20(SP)
9D0023A0  8FBE0010   LW S8, 16(SP)
9D0023A4  27BD0018   ADDIU SP, SP, 24
9D0023A8  03E00008   JR RA
9D0023AC  00000000   NOP
2444:                
2445:                /********************************************************************
2446:                 * Function:        void USBWakeFromSuspend(void)
2447:                 *
2448:                 * PreCondition:    None
2449:                 *
2450:                 * Input:           None
2451:                 *
2452:                 * Output:          None
2453:                 *
2454:                 * Side Effects:    None
2455:                 *
2456:                 * Overview:
2457:                 *
2458:                 * Note:            None
2459:                 *******************************************************************/
2460:                static void USBWakeFromSuspend(void)
2461:                {
9D0023B0  27BDFFE8   ADDIU SP, SP, -24
9D0023B4  AFBF0014   SW RA, 20(SP)
9D0023B8  AFBE0010   SW S8, 16(SP)
9D0023BC  03A0F021   ADDU S8, SP, ZERO
2462:                    USBBusIsSuspended = FALSE;
9D0023C0  AF808064   SW ZERO, -32668(GP)
2463:                
2464:                    /*
2465:                     * If using clock switching, the place to restore the original
2466:                     * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2467:                     */
2468:                    USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
9D0023C4  24040074   ADDIU A0, ZERO, 116
9D0023C8  00002821   ADDU A1, ZERO, ZERO
9D0023CC  00003021   ADDU A2, ZERO, ZERO
9D0023D0  0F401375   JAL USER_USB_CALLBACK_EVENT_HANDLER
9D0023D4  00000000   NOP
2469:                
2470:                    #if defined(__18CXX)
2471:                        //To avoid improperly clocking the USB module, make sure the oscillator
2472:                        //settings are consistant with USB operation before clearing the SUSPND bit.
2473:                        //Make sure the correct oscillator settings are selected in the 
2474:                        //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2475:                        U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
2476:                                                // mode.
2477:                    #endif
2478:                
2479:                
2480:                    USBActivityIE = 0;
9D0023D8  3C03BF88   LUI V1, -16504
9D0023DC  8C625050   LW V0, 20560(V1)
9D0023E0  7C022104   INS V0, ZERO, 4, 1
9D0023E4  AC625050   SW V0, 20560(V1)
2481:                
2482:                    /********************************************************************
2483:                    Bug Fix: Feb 26, 2007 v2.1
2484:                    *********************************************************************
2485:                    The ACTVIF bit cannot be cleared immediately after the USB module wakes
2486:                    up from Suspend or while the USB module is suspended. A few clock cycles
2487:                    are required to synchronize the internal hardware state machine before
2488:                    the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2489:                    before the internal hardware is synchronized may not have an effect on
2490:                    the value of ACTVIF. Additonally, if the USB module uses the clock from
2491:                    the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2492:                    module may not be immediately operational while waiting for the 96 MHz
2493:                    PLL to lock.
2494:                    ********************************************************************/
2495:                
2496:                    // UIRbits.ACTVIF = 0;                      // Removed
2497:                    #if defined(__18CXX)
2498:                    while(USBActivityIF)
2499:                    #endif
2500:                    {
2501:                        USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
9D0023E8  3C02BF88   LUI V0, -16504
9D0023EC  24030010   ADDIU V1, ZERO, 16
9D0023F0  AC435040   SW V1, 20544(V0)
2502:                    }  // Added
2503:                
2504:                }//end USBWakeFromSuspend
9D0023F4  03C0E821   ADDU SP, S8, ZERO
9D0023F8  8FBF0014   LW RA, 20(SP)
9D0023FC  8FBE0010   LW S8, 16(SP)
9D002400  27BD0018   ADDIU SP, SP, 24
9D002404  03E00008   JR RA
9D002408  00000000   NOP
2505:                
2506:                /********************************************************************
2507:                 * Function:        void USBCtrlEPService(void)
2508:                 *
2509:                 * PreCondition:    USTAT is loaded with a valid endpoint address.
2510:                 *
2511:                 * Input:           None
2512:                 *
2513:                 * Output:          None
2514:                 *
2515:                 * Side Effects:    None
2516:                 *
2517:                 * Overview:        USBCtrlEPService checks for three transaction
2518:                 *                  types that it knows how to service and services
2519:                 *                  them:
2520:                 *                  1. EP0 SETUP
2521:                 *                  2. EP0 OUT
2522:                 *                  3. EP0 IN
2523:                 *                  It ignores all other types (i.e. EP1, EP2, etc.)
2524:                 *
2525:                 * Note:            None
2526:                 *******************************************************************/
2527:                static void USBCtrlEPService(void)
2528:                {
9D00240C  27BDFFE0   ADDIU SP, SP, -32
9D002410  AFBF001C   SW RA, 28(SP)
9D002414  AFBE0018   SW S8, 24(SP)
9D002418  03A0F021   ADDU S8, SP, ZERO
2529:                    //If we get to here, that means a successful transaction has just occurred 
2530:                    //on EP0.  This means "progress" has occurred in the currently pending 
2531:                    //control transfer, so we should re-initialize our timeout counter.
2532:                    #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2533:                        USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
9D00241C  2402002D   ADDIU V0, ZERO, 45
9D002420  A3828068   SB V0, -32664(GP)
2534:                    #endif
2535:                	
2536:                	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2537:                    if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
9D002424  93828084   LBU V0, -32636(GP)
9D002428  00401821   ADDU V1, V0, ZERO
9D00242C  2402FFFB   ADDIU V0, ZERO, -5
9D002430  00621024   AND V0, V1, V0
9D002434  14400081   BNE V0, ZERO, 0x9D00263C
9D002438  00000000   NOP
2538:                    {
2539:                		//Point to the EP0 OUT buffer of the buffer that arrived
2540:                        #if defined(__18CXX)
2541:                            pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
2542:                        #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2543:                            pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
9D00243C  93828084   LBU V0, -32636(GP)
9D002440  00021082   SRL V0, V0, 2
9D002444  304200FF   ANDI V0, V0, 255
9D002448  000218C0   SLL V1, V0, 3
9D00244C  3C02A000   LUI V0, -24576
9D002450  24420200   ADDIU V0, V0, 512
9D002454  00621021   ADDU V0, V1, V0
9D002458  AF828078   SW V0, -32648(GP)
2544:                        #else
2545:                            #error "unimplemented"
2546:                        #endif
2547:                
2548:                		//Set the next out to the current out packet
2549:                        pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
9D00245C  8F828078   LW V0, -32648(GP)
9D002460  AF828060   SW V0, -32672(GP)
2550:                		//Toggle it to the next ping pong buffer (if applicable)
2551:                        ((BYTE_VAL*)&pBDTEntryEP0OutNext)->Val ^= USB_NEXT_EP0_OUT_PING_PONG;
9D002464  27828060   ADDIU V0, GP, -32672
9D002468  27838060   ADDIU V1, GP, -32672
9D00246C  90630000   LBU V1, 0(V1)
9D002470  38630008   XORI V1, V1, 8
9D002474  306300FF   ANDI V1, V1, 255
9D002478  A0430000   SB V1, 0(V0)
2552:                
2553:                		//If the current EP0 OUT buffer has a SETUP packet
2554:                        if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
9D00247C  8F828078   LW V0, -32648(GP)
9D002480  90420000   LBU V0, 0(V0)
9D002484  304200FF   ANDI V0, V0, 255
9D002488  3042003C   ANDI V0, V0, 60
9D00248C  304300FF   ANDI V1, V0, 255
9D002490  24020034   ADDIU V0, ZERO, 52
9D002494  14620065   BNE V1, V0, 0x9D00262C
9D002498  00000000   NOP
2555:                        {
2556:                            unsigned char setup_cnt;
2557:                
2558:                	        //The SETUP transaction data may have gone into the the CtrlTrfData 
2559:                	        //buffer, or elsewhere, depending upon how the BDT was prepared
2560:                	        //before the transaction.  Therefore, we should copy the data to the 
2561:                	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
2562:                            for(setup_cnt = 0; setup_cnt < 8u; setup_cnt++) //SETUP data packets always contain exactly 8 bytes.
9D00249C  A3C00010   SB ZERO, 16(S8)
9D0024A0  0B40096A   J 0x9D0025A8
9D0024A4  00000000   NOP
9D00259C  93C20010   LBU V0, 16(S8)
9D0025A0  24420001   ADDIU V0, V0, 1
9D0025A4  A3C20010   SB V0, 16(S8)
9D0025A8  93C20010   LBU V0, 16(S8)
9D0025AC  2C420008   SLTIU V0, V0, 8
9D0025B0  1440FFBD   BNE V0, ZERO, 0x9D0024A8
9D0025B4  00000000   NOP
2563:                            {
2564:                                *(BYTE*)((BYTE*)&SetupPkt + setup_cnt) = *(BYTE*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR);
9D0024A8  93C30010   LBU V1, 16(S8)
9D0024AC  2782806C   ADDIU V0, GP, -32660
9D0024B0  00621821   ADDU V1, V1, V0
9D0024B4  8F828078   LW V0, -32648(GP)
9D0024B8  90440004   LBU A0, 4(V0)
9D0024BC  308400FF   ANDI A0, A0, 255
9D0024C0  90450005   LBU A1, 5(V0)
9D0024C4  30A500FF   ANDI A1, A1, 255
9D0024C8  00052A00   SLL A1, A1, 8
9D0024CC  00A42025   OR A0, A1, A0
9D0024D0  90450006   LBU A1, 6(V0)
9D0024D4  30A500FF   ANDI A1, A1, 255
9D0024D8  00052C00   SLL A1, A1, 16
9D0024DC  00A42025   OR A0, A1, A0
9D0024E0  90420007   LBU V0, 7(V0)
9D0024E4  304200FF   ANDI V0, V0, 255
9D0024E8  00021600   SLL V0, V0, 24
9D0024EC  00441025   OR V0, V0, A0
9D0024F0  00402021   ADDU A0, V0, ZERO
9D0024F4  3C02A000   LUI V0, -24576
9D0024F8  00821025   OR V0, A0, V0
9D0024FC  90420000   LBU V0, 0(V0)
9D002500  A0620000   SB V0, 0(V1)
2565:                                pBDTEntryEP0OutCurrent->ADR++;
9D002504  8F828078   LW V0, -32648(GP)
9D002508  90430004   LBU V1, 4(V0)
9D00250C  306300FF   ANDI V1, V1, 255
9D002510  90440005   LBU A0, 5(V0)
9D002514  308400FF   ANDI A0, A0, 255
9D002518  00042200   SLL A0, A0, 8
9D00251C  00831825   OR V1, A0, V1
9D002520  90440006   LBU A0, 6(V0)
9D002524  308400FF   ANDI A0, A0, 255
9D002528  00042400   SLL A0, A0, 16
9D00252C  00831825   OR V1, A0, V1
9D002530  90440007   LBU A0, 7(V0)
9D002534  308400FF   ANDI A0, A0, 255
9D002538  00042600   SLL A0, A0, 24
9D00253C  00831825   OR V1, A0, V1
9D002540  24630001   ADDIU V1, V1, 1
9D002544  306400FF   ANDI A0, V1, 255
9D002548  90450004   LBU A1, 4(V0)
9D00254C  30A50000   ANDI A1, A1, 0
9D002550  00A42025   OR A0, A1, A0
9D002554  A0440004   SB A0, 4(V0)
9D002558  00032202   SRL A0, V1, 8
9D00255C  308400FF   ANDI A0, A0, 255
9D002560  90450005   LBU A1, 5(V0)
9D002564  30A50000   ANDI A1, A1, 0
9D002568  00A42025   OR A0, A1, A0
9D00256C  A0440005   SB A0, 5(V0)
9D002570  00032402   SRL A0, V1, 16
9D002574  308400FF   ANDI A0, A0, 255
9D002578  90450006   LBU A1, 6(V0)
9D00257C  30A50000   ANDI A1, A1, 0
9D002580  00A42025   OR A0, A1, A0
9D002584  A0440006   SB A0, 6(V0)
9D002588  00031E02   SRL V1, V1, 24
9D00258C  90440007   LBU A0, 7(V0)
9D002590  30840000   ANDI A0, A0, 0
9D002594  00831825   OR V1, A0, V1
9D002598  A0430007   SB V1, 7(V0)
2566:                            }    
2567:                            pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
9D0025B8  8F828078   LW V0, -32648(GP)
9D0025BC  2783806C   ADDIU V1, GP, -32660
9D0025C0  7C63E000   EXT V1, V1, 0, 29
9D0025C4  306400FF   ANDI A0, V1, 255
9D0025C8  90450004   LBU A1, 4(V0)
9D0025CC  30A50000   ANDI A1, A1, 0
9D0025D0  00A42025   OR A0, A1, A0
9D0025D4  A0440004   SB A0, 4(V0)
9D0025D8  00032202   SRL A0, V1, 8
9D0025DC  308400FF   ANDI A0, A0, 255
9D0025E0  90450005   LBU A1, 5(V0)
9D0025E4  30A50000   ANDI A1, A1, 0
9D0025E8  00A42025   OR A0, A1, A0
9D0025EC  A0440005   SB A0, 5(V0)
9D0025F0  00032402   SRL A0, V1, 16
9D0025F4  308400FF   ANDI A0, A0, 255
9D0025F8  90450006   LBU A1, 6(V0)
9D0025FC  30A50000   ANDI A1, A1, 0
9D002600  00A42025   OR A0, A1, A0
9D002604  A0440006   SB A0, 6(V0)
9D002608  00031E02   SRL V1, V1, 24
9D00260C  90440007   LBU A0, 7(V0)
9D002610  30840000   ANDI A0, A0, 0
9D002614  00831825   OR V1, A0, V1
9D002618  A0430007   SB V1, 7(V0)
2568:                
2569:                			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2570:                            USBCtrlTrfSetupHandler();
9D00261C  0F40099E   JAL 0x9D002678
9D002620  00000000   NOP
9D002624  0B400998   J 0x9D002660
9D002628  00000000   NOP
2571:                        }
2572:                        else
2573:                        {
2574:                			//Handle the DATA transfer
2575:                            USBCtrlTrfOutHandler();
9D00262C  0F400A16   JAL 0x9D002858
9D002630  00000000   NOP
9D002634  0B400998   J 0x9D002660
9D002638  00000000   NOP
2576:                        }
2577:                    }
2578:                    else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
9D00263C  93828084   LBU V0, -32636(GP)
9D002640  00401821   ADDU V1, V0, ZERO
9D002644  2402FFFB   ADDIU V0, ZERO, -5
9D002648  00621824   AND V1, V1, V0
9D00264C  24020008   ADDIU V0, ZERO, 8
9D002650  14620003   BNE V1, V0, 0x9D002660
9D002654  00000000   NOP
2579:                    {
2580:                		//Otherwise the transmission was and EP0 IN
2581:                		//  so take care of the IN transfer
2582:                        USBCtrlTrfInHandler();
9D002658  0F400A5B   JAL 0x9D00296C
9D00265C  00000000   NOP
2583:                    }
2584:                
2585:                }//end USBCtrlEPService
9D002660  03C0E821   ADDU SP, S8, ZERO
9D002664  8FBF001C   LW RA, 28(SP)
9D002668  8FBE0018   LW S8, 24(SP)
9D00266C  27BD0020   ADDIU SP, SP, 32
9D002670  03E00008   JR RA
9D002674  00000000   NOP
2586:                
2587:                /********************************************************************
2588:                 * Function:        void USBCtrlTrfSetupHandler(void)
2589:                 *
2590:                 * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2591:                 *
2592:                 * Input:           None
2593:                 *
2594:                 * Output:          None
2595:                 *
2596:                 * Side Effects:    None
2597:                 *
2598:                 * Overview:        This routine is a task dispatcher and has 3 stages.
2599:                 *                  1. It initializes the control transfer state machine.
2600:                 *                  2. It calls on each of the module that may know how to
2601:                 *                     service the Setup Request from the host.
2602:                 *                     Module Example: USBD, HID, CDC, MSD, ...
2603:                 *                     A callback function, USBCBCheckOtherReq(),
2604:                 *                     is required to call other module handlers.
2605:                 *                  3. Once each of the modules has had a chance to check if
2606:                 *                     it is responsible for servicing the request, stage 3
2607:                 *                     then checks direction of the transfer to determine how
2608:                 *                     to prepare EP0 for the control transfer.
2609:                 *                     Refer to USBCtrlEPServiceComplete() for more details.
2610:                 *
2611:                 * Note:            Microchip USB Firmware has three different states for
2612:                 *                  the control transfer state machine:
2613:                 *                  1. WAIT_SETUP
2614:                 *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2615:                 *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2616:                 *                  Refer to firmware manual to find out how one state
2617:                 *                  is transitioned to another.
2618:                 *
2619:                 *                  A Control Transfer is composed of many USB transactions.
2620:                 *                  When transferring data over multiple transactions,
2621:                 *                  it is important to keep track of data source, data
2622:                 *                  destination, and data count. These three parameters are
2623:                 *                  stored in pSrc,pDst, and wCount. A flag is used to
2624:                 *                  note if the data source is from ROM or RAM.
2625:                 *
2626:                 *******************************************************************/
2627:                static void USBCtrlTrfSetupHandler(void)
2628:                {
9D002678  27BDFFE8   ADDIU SP, SP, -24
9D00267C  AFBF0014   SW RA, 20(SP)
9D002680  AFBE0010   SW S8, 16(SP)
9D002684  03A0F021   ADDU S8, SP, ZERO
2629:                    //--------------------------------------------------------------------------
2630:                    //1. Re-initialize state tracking variables related to control transfers.
2631:                    //--------------------------------------------------------------------------
2632:                    shortPacketStatus = SHORT_PKT_NOT_USED;  
9D002688  A3808076   SB ZERO, -32650(GP)
2633:                    USBDeferStatusStagePacket = FALSE;
9D00268C  AF80808C   SW ZERO, -32628(GP)
2634:                    USBDeferINDataStagePackets = FALSE;
9D002690  AF808030   SW ZERO, -32720(GP)
2635:                    USBDeferOUTDataStagePackets = FALSE;
9D002694  AF808034   SW ZERO, -32716(GP)
2636:                    BothEP0OutUOWNsSet = FALSE;    
9D002698  AF80805C   SW ZERO, -32676(GP)
2637:                    controlTransferState = WAIT_SETUP;
9D00269C  A380803C   SB ZERO, -32708(GP)
2638:                
2639:                    //Abandon any previous control transfers that might have been using EP0.
2640:                    //Ordinarily, nothing actually needs abandoning, since the previous control
2641:                    //transfer would have completed successfully prior to the host sending the next
2642:                    //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2643:                    //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2644:                    //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2645:                    //by the class request handler that will be called next.
2646:                    pBDTEntryIn[0]->STAT.Val &= ~(_USIE);     
9D0026A0  8F828040   LW V0, -32704(GP)
9D0026A4  8F838040   LW V1, -32704(GP)
9D0026A8  90640000   LBU A0, 0(V1)
9D0026AC  308400FF   ANDI A0, A0, 255
9D0026B0  90630001   LBU V1, 1(V1)
9D0026B4  306300FF   ANDI V1, V1, 255
9D0026B8  00031A00   SLL V1, V1, 8
9D0026BC  00641825   OR V1, V1, A0
9D0026C0  3064FFFF   ANDI A0, V1, -1
9D0026C4  2403FF7F   ADDIU V1, ZERO, -129
9D0026C8  00831824   AND V1, A0, V1
9D0026CC  3063FFFF   ANDI V1, V1, -1
9D0026D0  306400FF   ANDI A0, V1, 255
9D0026D4  90450000   LBU A1, 0(V0)
9D0026D8  30A50000   ANDI A1, A1, 0
9D0026DC  00A42025   OR A0, A1, A0
9D0026E0  A0440000   SB A0, 0(V0)
9D0026E4  00031A02   SRL V1, V1, 8
9D0026E8  3063FFFF   ANDI V1, V1, -1
9D0026EC  90440001   LBU A0, 1(V0)
9D0026F0  30840000   ANDI A0, A0, 0
9D0026F4  00831825   OR V1, A0, V1
9D0026F8  A0430001   SB V1, 1(V0)
2647:                    ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
9D0026FC  27828040   ADDIU V0, GP, -32704
9D002700  27838040   ADDIU V1, GP, -32704
9D002704  90630000   LBU V1, 0(V1)
9D002708  38630008   XORI V1, V1, 8
9D00270C  306300FF   ANDI V1, V1, 255
9D002710  A0430000   SB V1, 0(V0)
2648:                    pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
9D002714  8F828040   LW V0, -32704(GP)
9D002718  8F838040   LW V1, -32704(GP)
9D00271C  90640000   LBU A0, 0(V1)
9D002720  308400FF   ANDI A0, A0, 255
9D002724  90630001   LBU V1, 1(V1)
9D002728  306300FF   ANDI V1, V1, 255
9D00272C  00031A00   SLL V1, V1, 8
9D002730  00641825   OR V1, V1, A0
9D002734  3064FFFF   ANDI A0, V1, -1
9D002738  2403FF7F   ADDIU V1, ZERO, -129
9D00273C  00831824   AND V1, A0, V1
9D002740  3063FFFF   ANDI V1, V1, -1
9D002744  306400FF   ANDI A0, V1, 255
9D002748  90450000   LBU A1, 0(V0)
9D00274C  30A50000   ANDI A1, A1, 0
9D002750  00A42025   OR A0, A1, A0
9D002754  A0440000   SB A0, 0(V0)
9D002758  00031A02   SRL V1, V1, 8
9D00275C  3063FFFF   ANDI V1, V1, -1
9D002760  90440001   LBU A0, 1(V0)
9D002764  30840000   ANDI A0, A0, 0
9D002768  00831825   OR V1, A0, V1
9D00276C  A0430001   SB V1, 1(V0)
2649:                    ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
9D002770  27828040   ADDIU V0, GP, -32704
9D002774  27838040   ADDIU V1, GP, -32704
9D002778  90630000   LBU V1, 0(V1)
9D00277C  38630008   XORI V1, V1, 8
9D002780  306300FF   ANDI V1, V1, 255
9D002784  A0430000   SB V1, 0(V0)
2650:                    pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
9D002788  8F828060   LW V0, -32672(GP)
9D00278C  8F838060   LW V1, -32672(GP)
9D002790  90640000   LBU A0, 0(V1)
9D002794  308400FF   ANDI A0, A0, 255
9D002798  90630001   LBU V1, 1(V1)
9D00279C  306300FF   ANDI V1, V1, 255
9D0027A0  00031A00   SLL V1, V1, 8
9D0027A4  00641825   OR V1, V1, A0
9D0027A8  3064FFFF   ANDI A0, V1, -1
9D0027AC  2403FF7F   ADDIU V1, ZERO, -129
9D0027B0  00831824   AND V1, A0, V1
9D0027B4  3063FFFF   ANDI V1, V1, -1
9D0027B8  306400FF   ANDI A0, V1, 255
9D0027BC  90450000   LBU A1, 0(V0)
9D0027C0  30A50000   ANDI A1, A1, 0
9D0027C4  00A42025   OR A0, A1, A0
9D0027C8  A0440000   SB A0, 0(V0)
9D0027CC  00031A02   SRL V1, V1, 8
9D0027D0  3063FFFF   ANDI V1, V1, -1
9D0027D4  90440001   LBU A0, 1(V0)
9D0027D8  30840000   ANDI A0, A0, 0
9D0027DC  00831825   OR V1, A0, V1
9D0027E0  A0430001   SB V1, 1(V0)
2651:                
2652:                    inPipes[0].info.Val = 0;
9D0027E4  3C02A000   LUI V0, -24576
9D0027E8  244202C0   ADDIU V0, V0, 704
9D0027EC  A0400004   SB ZERO, 4(V0)
2653:                    inPipes[0].wCount.Val = 0;
9D0027F0  3C02A000   LUI V0, -24576
9D0027F4  244202C0   ADDIU V0, V0, 704
9D0027F8  A4400008   SH ZERO, 8(V0)
2654:                    outPipes[0].info.Val = 0;
9D0027FC  3C02A000   LUI V0, -24576
9D002800  24420310   ADDIU V0, V0, 784
9D002804  A0400004   SB ZERO, 4(V0)
2655:                    outPipes[0].wCount.Val = 0;
9D002808  3C02A000   LUI V0, -24576
9D00280C  24430310   ADDIU V1, V0, 784
9D002810  8C620004   LW V0, 4(V1)
9D002814  7C02BA04   INS V0, ZERO, 8, 16
9D002818  AC620004   SW V0, 4(V1)
2656:                    
2657:                
2658:                    //--------------------------------------------------------------------------
2659:                    //2. Now find out what was in the SETUP packet, and begin handling the request.
2660:                    //--------------------------------------------------------------------------
2661:                    USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
9D00281C  0F400AEC   JAL 0x9D002BB0
9D002820  00000000   NOP
2662:                    USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
9D002824  24040003   ADDIU A0, ZERO, 3
9D002828  00002821   ADDU A1, ZERO, ZERO
9D00282C  00003021   ADDU A2, ZERO, ZERO
9D002830  0F401375   JAL USER_USB_CALLBACK_EVENT_HANDLER
9D002834  00000000   NOP
2663:                
2664:                
2665:                    //--------------------------------------------------------------------------
2666:                    //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
2667:                    //   progress.  If one of the above handlers (in step 2) knew how to process
2668:                    //   the request, it will have set one of the inPipes[0].info.bits.busy or
2669:                    //   outPipes[0].info.bits.busy flags = 1.  This lets the
2670:                    //   USBCtrlEPServiceComplete() function know how and which endpoints to 
2671:                    //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2672:                    //   process the request.  In this case, the default behavior will be to
2673:                    //   perform protocol STALL on EP0.
2674:                    //-------------------------------------------------------------------------- 
2675:                    USBCtrlEPServiceComplete();
9D002838  0F400560   JAL 0x9D001580
9D00283C  00000000   NOP
2676:                }//end USBCtrlTrfSetupHandler
9D002840  03C0E821   ADDU SP, S8, ZERO
9D002844  8FBF0014   LW RA, 20(SP)
9D002848  8FBE0010   LW S8, 16(SP)
9D00284C  27BD0018   ADDIU SP, SP, 24
9D002850  03E00008   JR RA
9D002854  00000000   NOP
2677:                
2678:                
2679:                /******************************************************************************
2680:                 * Function:        void USBCtrlTrfOutHandler(void)
2681:                 *
2682:                 * PreCondition:    None
2683:                 *
2684:                 * Input:           None
2685:                 *
2686:                 * Output:          None
2687:                 *
2688:                 * Side Effects:    None
2689:                 *
2690:                 * Overview:        This routine handles an OUT transaction according to
2691:                 *                  which control transfer state is currently active.
2692:                 *
2693:                 * Note:            Note that if the the control transfer was from
2694:                 *                  host to device, the session owner should be notified
2695:                 *                  at the end of each OUT transaction to service the
2696:                 *                  received data.
2697:                 *
2698:                 *****************************************************************************/
2699:                static void USBCtrlTrfOutHandler(void)
2700:                {
9D002858  27BDFFE8   ADDIU SP, SP, -24
9D00285C  AFBF0014   SW RA, 20(SP)
9D002860  AFBE0010   SW S8, 16(SP)
9D002864  03A0F021   ADDU S8, SP, ZERO
2701:                    if(controlTransferState == CTRL_TRF_RX)
9D002868  9383803C   LBU V1, -32708(GP)
9D00286C  24020002   ADDIU V0, ZERO, 2
9D002870  14620005   BNE V1, V0, 0x9D002888
9D002874  00000000   NOP
2702:                    {
2703:                        USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
9D002878  0F400675   JAL 0x9D0019D4
9D00287C  00000000   NOP
9D002880  0B400A55   J 0x9D002954
9D002884  00000000   NOP
2704:                    }
2705:                    else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2706:                    {
2707:                        //If the status stage is complete, this means we are done with the 
2708:                        //control transfer.  Go back to the idle "WAIT_SETUP" state.
2709:                        controlTransferState = WAIT_SETUP;
9D002888  A380803C   SB ZERO, -32708(GP)
2710:                
2711:                	    //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2712:                	    //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2713:                	    //and the last control transfer was of direction: device to host, see
2714:                	    //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2715:                	    //to do anything to the BDT.
2716:                		if(BothEP0OutUOWNsSet == FALSE)
9D00288C  8F82805C   LW V0, -32676(GP)
9D002890  1440002F   BNE V0, ZERO, 0x9D002950
9D002894  00000000   NOP
2717:                		{
2718:                	        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9D002898  8F828060   LW V0, -32672(GP)
9D00289C  90430002   LBU V1, 2(V0)
9D0028A0  30630000   ANDI V1, V1, 0
9D0028A4  34630040   ORI V1, V1, 64
9D0028A8  A0430002   SB V1, 2(V0)
9D0028AC  90440003   LBU A0, 3(V0)
9D0028B0  2403FFFC   ADDIU V1, ZERO, -4
9D0028B4  00831824   AND V1, A0, V1
9D0028B8  A0430003   SB V1, 3(V0)
2719:                	        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
9D0028BC  8F828060   LW V0, -32672(GP)
9D0028C0  2783806C   ADDIU V1, GP, -32660
9D0028C4  7C63E000   EXT V1, V1, 0, 29
9D0028C8  306400FF   ANDI A0, V1, 255
9D0028CC  90450004   LBU A1, 4(V0)
9D0028D0  30A50000   ANDI A1, A1, 0
9D0028D4  00A42025   OR A0, A1, A0
9D0028D8  A0440004   SB A0, 4(V0)
9D0028DC  00032202   SRL A0, V1, 8
9D0028E0  308400FF   ANDI A0, A0, 255
9D0028E4  90450005   LBU A1, 5(V0)
9D0028E8  30A50000   ANDI A1, A1, 0
9D0028EC  00A42025   OR A0, A1, A0
9D0028F0  A0440005   SB A0, 5(V0)
9D0028F4  00032402   SRL A0, V1, 16
9D0028F8  308400FF   ANDI A0, A0, 255
9D0028FC  90450006   LBU A1, 6(V0)
9D002900  30A50000   ANDI A1, A1, 0
9D002904  00A42025   OR A0, A1, A0
9D002908  A0440006   SB A0, 6(V0)
9D00290C  00031E02   SRL V1, V1, 24
9D002910  90440007   LBU A0, 7(V0)
9D002914  30840000   ANDI A0, A0, 0
9D002918  00831825   OR V1, A0, V1
9D00291C  A0430007   SB V1, 7(V0)
2720:                	        pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;			
9D002920  8F828060   LW V0, -32672(GP)
9D002924  90430000   LBU V1, 0(V0)
9D002928  30630000   ANDI V1, V1, 0
9D00292C  00602021   ADDU A0, V1, ZERO
9D002930  2403FF8C   ADDIU V1, ZERO, -116
9D002934  00831825   OR V1, A0, V1
9D002938  A0430000   SB V1, 0(V0)
9D00293C  90430001   LBU V1, 1(V0)
9D002940  30630000   ANDI V1, V1, 0
9D002944  A0430001   SB V1, 1(V0)
9D002948  0B400A55   J 0x9D002954
9D00294C  00000000   NOP
2721:                		}
2722:                		else
2723:                		{
2724:                			BothEP0OutUOWNsSet = FALSE;
9D002950  AF80805C   SW ZERO, -32676(GP)
2725:                		}
2726:                    }
2727:                }
9D002954  03C0E821   ADDU SP, S8, ZERO
9D002958  8FBF0014   LW RA, 20(SP)
9D00295C  8FBE0010   LW S8, 16(SP)
9D002960  27BD0018   ADDIU SP, SP, 24
9D002964  03E00008   JR RA
9D002968  00000000   NOP
2728:                
2729:                /******************************************************************************
2730:                 * Function:        void USBCtrlTrfInHandler(void)
2731:                 *
2732:                 * PreCondition:    None
2733:                 *
2734:                 * Input:           None
2735:                 *
2736:                 * Output:          None
2737:                 *
2738:                 * Side Effects:    None
2739:                 *
2740:                 * Overview:        This routine handles an IN transaction according to
2741:                 *                  which control transfer state is currently active.
2742:                 *
2743:                 * Note:            A Set Address Request must not change the acutal address
2744:                 *                  of the device until the completion of the control
2745:                 *                  transfer. The end of the control transfer for Set Address
2746:                 *                  Request is an IN transaction. Therefore it is necessary
2747:                 *                  to service this unique situation when the condition is
2748:                 *                  right. Macro mUSBCheckAdrPendingState is defined in
2749:                 *                  usb9.h and its function is to specifically service this
2750:                 *                  event.
2751:                 *****************************************************************************/
2752:                static void USBCtrlTrfInHandler(void)
2753:                {
9D00296C  27BDFFE0   ADDIU SP, SP, -32
9D002970  AFBF001C   SW RA, 28(SP)
9D002974  AFBE0018   SW S8, 24(SP)
9D002978  03A0F021   ADDU S8, SP, ZERO
2754:                    BYTE lastDTS;
2755:                
2756:                    lastDTS = pBDTEntryIn[0]->STAT.DTS;
9D00297C  8F828040   LW V0, -32704(GP)
9D002980  90420000   LBU V0, 0(V0)
9D002984  7C420180   EXT V0, V0, 6, 1
9D002988  304200FF   ANDI V0, V0, 255
9D00298C  A3C20010   SB V0, 16(S8)
2757:                
2758:                    //switch to the next ping pong buffer
2759:                    ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
9D002990  27828040   ADDIU V0, GP, -32704
9D002994  27838040   ADDIU V1, GP, -32704
9D002998  90630000   LBU V1, 0(V1)
9D00299C  38630008   XORI V1, V1, 8
9D0029A0  306300FF   ANDI V1, V1, 255
9D0029A4  A0430000   SB V1, 0(V0)
2760:                
2761:                    //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2762:                    //now, since the IN status stage of the (set address) control transfer has 
2763:                    //evidently completed successfully.
2764:                    if(USBDeviceState == ADR_PENDING_STATE)
9D0029A8  8F838038   LW V1, -32712(GP)
9D0029AC  24020008   ADDIU V0, ZERO, 8
9D0029B0  14620010   BNE V1, V0, 0x9D0029F4
9D0029B4  00000000   NOP
2765:                    {
2766:                        U1ADDR = SetupPkt.bDevADR.Val;
9D0029B8  9382806E   LBU V0, -32658(GP)
9D0029BC  304200FF   ANDI V0, V0, 255
9D0029C0  00401821   ADDU V1, V0, ZERO
9D0029C4  3C02BF88   LUI V0, -16504
9D0029C8  AC435260   SW V1, 21088(V0)
2767:                        if(U1ADDR != 0u)
9D0029CC  3C02BF88   LUI V0, -16504
9D0029D0  8C425260   LW V0, 21088(V0)
9D0029D4  10400005   BEQ V0, ZERO, 0x9D0029EC
9D0029D8  00000000   NOP
2768:                        {
2769:                            USBDeviceState=ADDRESS_STATE;
9D0029DC  24020010   ADDIU V0, ZERO, 16
9D0029E0  AF828038   SW V0, -32712(GP)
9D0029E4  0B400A7D   J 0x9D0029F4
9D0029E8  00000000   NOP
2770:                        }
2771:                        else
2772:                        {
2773:                            USBDeviceState=DEFAULT_STATE;
9D0029EC  24020004   ADDIU V0, ZERO, 4
9D0029F0  AF828038   SW V0, -32712(GP)
2774:                        }
2775:                    }//end if
2776:                
2777:                
2778:                    if(controlTransferState == CTRL_TRF_TX)
9D0029F4  9383803C   LBU V1, -32708(GP)
9D0029F8  24020001   ADDIU V0, ZERO, 1
9D0029FC  14620048   BNE V1, V0, 0x9D002B20
9D002A00  00000000   NOP
2779:                    {
2780:                        pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
9D002A04  8F828040   LW V0, -32704(GP)
9D002A08  3C03A000   LUI V1, -24576
9D002A0C  24630240   ADDIU V1, V1, 576
9D002A10  7C63E000   EXT V1, V1, 0, 29
9D002A14  306400FF   ANDI A0, V1, 255
9D002A18  90450004   LBU A1, 4(V0)
9D002A1C  30A50000   ANDI A1, A1, 0
9D002A20  00A42025   OR A0, A1, A0
9D002A24  A0440004   SB A0, 4(V0)
9D002A28  00032202   SRL A0, V1, 8
9D002A2C  308400FF   ANDI A0, A0, 255
9D002A30  90450005   LBU A1, 5(V0)
9D002A34  30A50000   ANDI A1, A1, 0
9D002A38  00A42025   OR A0, A1, A0
9D002A3C  A0440005   SB A0, 5(V0)
9D002A40  00032402   SRL A0, V1, 16
9D002A44  308400FF   ANDI A0, A0, 255
9D002A48  90450006   LBU A1, 6(V0)
9D002A4C  30A50000   ANDI A1, A1, 0
9D002A50  00A42025   OR A0, A1, A0
9D002A54  A0440006   SB A0, 6(V0)
9D002A58  00031E02   SRL V1, V1, 24
9D002A5C  90440007   LBU A0, 7(V0)
9D002A60  30840000   ANDI A0, A0, 0
9D002A64  00831825   OR V1, A0, V1
9D002A68  A0430007   SB V1, 7(V0)
2781:                        USBCtrlTrfTxService();
9D002A6C  0F40060B   JAL 0x9D00182C
9D002A70  00000000   NOP
2782:                
2783:                        //Check if we have already sent a short packet.  If so, configure
2784:                        //the endpoint to STALL in response to any further IN tokens (in the
2785:                        //case that the host erroneously tries to receive more data than it
2786:                        //should).
2787:                        if(shortPacketStatus == SHORT_PKT_SENT)
9D002A74  93838076   LBU V1, -32650(GP)
9D002A78  24020002   ADDIU V0, ZERO, 2
9D002A7C  1462000D   BNE V1, V0, 0x9D002AB4
9D002A80  00000000   NOP
2788:                        {
2789:                            // If a short packet has been sent, don't want to send any more,
2790:                            // stall next time if host is still trying to read.
2791:                            pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL;
9D002A84  8F828040   LW V0, -32704(GP)
9D002A88  90430000   LBU V1, 0(V0)
9D002A8C  30630000   ANDI V1, V1, 0
9D002A90  00602021   ADDU A0, V1, ZERO
9D002A94  2403FF84   ADDIU V1, ZERO, -124
9D002A98  00831825   OR V1, A0, V1
9D002A9C  A0430000   SB V1, 0(V0)
9D002AA0  90430001   LBU V1, 1(V0)
9D002AA4  30630000   ANDI V1, V1, 0
9D002AA8  A0430001   SB V1, 1(V0)
9D002AAC  0B400AE6   J 0x9D002B98
9D002AB0  00000000   NOP
2792:                        }
2793:                        else
2794:                        {
2795:                            if(lastDTS == 0)
9D002AB4  93C20010   LBU V0, 16(S8)
9D002AB8  1440000D   BNE V0, ZERO, 0x9D002AF0
9D002ABC  00000000   NOP
2796:                            {
2797:                                pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
9D002AC0  8F828040   LW V0, -32704(GP)
9D002AC4  90430000   LBU V1, 0(V0)
9D002AC8  30630000   ANDI V1, V1, 0
9D002ACC  00602021   ADDU A0, V1, ZERO
9D002AD0  2403FFC8   ADDIU V1, ZERO, -56
9D002AD4  00831825   OR V1, A0, V1
9D002AD8  A0430000   SB V1, 0(V0)
9D002ADC  90430001   LBU V1, 1(V0)
9D002AE0  30630000   ANDI V1, V1, 0
9D002AE4  A0430001   SB V1, 1(V0)
9D002AE8  0B400AE6   J 0x9D002B98
9D002AEC  00000000   NOP
2798:                            }
2799:                            else
2800:                            {
2801:                                pBDTEntryIn[0]->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
9D002AF0  8F828040   LW V0, -32704(GP)
9D002AF4  90430000   LBU V1, 0(V0)
9D002AF8  30630000   ANDI V1, V1, 0
9D002AFC  00602021   ADDU A0, V1, ZERO
9D002B00  2403FF88   ADDIU V1, ZERO, -120
9D002B04  00831825   OR V1, A0, V1
9D002B08  A0430000   SB V1, 0(V0)
9D002B0C  90430001   LBU V1, 1(V0)
9D002B10  30630000   ANDI V1, V1, 0
9D002B14  A0430001   SB V1, 1(V0)
9D002B18  0B400AE6   J 0x9D002B98
9D002B1C  00000000   NOP
2802:                            }
2803:                        }//end if(...)else
2804:                    }
2805:                	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2806:                	{
2807:                        //if someone is still expecting data from the control transfer
2808:                        //  then make sure to terminate that request and let them know that
2809:                        //  they are done
2810:                        if(outPipes[0].info.bits.busy == 1)
9D002B20  3C02A000   LUI V0, -24576
9D002B24  24420310   ADDIU V0, V0, 784
9D002B28  90430004   LBU V1, 4(V0)
9D002B2C  2402FF80   ADDIU V0, ZERO, -128
9D002B30  00621024   AND V0, V1, V0
9D002B34  304200FF   ANDI V0, V0, 255
9D002B38  10400016   BEQ V0, ZERO, 0x9D002B94
9D002B3C  00000000   NOP
2811:                        {
2812:                            if(outPipes[0].pFunc != NULL)
9D002B40  3C02A000   LUI V0, -24576
9D002B44  24420310   ADDIU V0, V0, 784
9D002B48  8843000A   LWL V1, 10(V0)
9D002B4C  00602021   ADDU A0, V1, ZERO
9D002B50  98440007   LWR A0, 7(V0)
9D002B54  00801021   ADDU V0, A0, ZERO
9D002B58  10400009   BEQ V0, ZERO, 0x9D002B80
9D002B5C  00000000   NOP
2813:                            {
2814:                                outPipes[0].pFunc();
9D002B60  3C02A000   LUI V0, -24576
9D002B64  24420310   ADDIU V0, V0, 784
9D002B68  8843000A   LWL V1, 10(V0)
9D002B6C  00602021   ADDU A0, V1, ZERO
9D002B70  98440007   LWR A0, 7(V0)
9D002B74  00801021   ADDU V0, A0, ZERO
9D002B78  0040F809   JALR V0
9D002B7C  00000000   NOP
2815:                            }
2816:                            outPipes[0].info.bits.busy = 0;
9D002B80  3C02A000   LUI V0, -24576
9D002B84  24430310   ADDIU V1, V0, 784
9D002B88  8C620004   LW V0, 4(V1)
9D002B8C  7C0239C4   INS V0, ZERO, 7, 1
9D002B90  AC620004   SW V0, 4(V1)
2817:                        }
2818:                    	
2819:                        controlTransferState = WAIT_SETUP;
9D002B94  A380803C   SB ZERO, -32708(GP)
2820:                        //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2821:                        //got processed by the USBCtrlTrfRxService() handler.
2822:                	}	
2823:                
2824:                }
9D002B98  03C0E821   ADDU SP, S8, ZERO
9D002B9C  8FBF001C   LW RA, 28(SP)
9D002BA0  8FBE0018   LW S8, 24(SP)
9D002BA4  27BD0020   ADDIU SP, SP, 32
9D002BA8  03E00008   JR RA
9D002BAC  00000000   NOP
2825:                
2826:                
2827:                /********************************************************************
2828:                 * Function:        void USBCheckStdRequest(void)
2829:                 *
2830:                 * PreCondition:    None
2831:                 *
2832:                 * Input:           None
2833:                 *
2834:                 * Output:          None
2835:                 *
2836:                 * Side Effects:    None
2837:                 *
2838:                 * Overview:        This routine checks the setup data packet to see
2839:                 *                  if it knows how to handle it
2840:                 *
2841:                 * Note:            None
2842:                 *******************************************************************/
2843:                static void USBCheckStdRequest(void)
2844:                {
9D002BB0  27BDFFE8   ADDIU SP, SP, -24
9D002BB4  AFBF0014   SW RA, 20(SP)
9D002BB8  AFBE0010   SW S8, 16(SP)
9D002BBC  03A0F021   ADDU S8, SP, ZERO
2845:                    if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
9D002BC0  9382806C   LBU V0, -32660(GP)
9D002BC4  304200FF   ANDI V0, V0, 255
9D002BC8  30420060   ANDI V0, V0, 96
9D002BCC  304200FF   ANDI V0, V0, 255
9D002BD0  14400078   BNE V0, ZERO, 0x9D002DB4
9D002BD4  00000000   NOP
9D002DB4  00000000   NOP
9D002DB8  0B400B74   J 0x9D002DD0
9D002DBC  00000000   NOP
2846:                
2847:                    switch(SetupPkt.bRequest)
9D002BD8  9382806D   LBU V0, -32659(GP)
9D002BDC  304200FF   ANDI V0, V0, 255
9D002BE0  2C43000C   SLTIU V1, V0, 12
9D002BE4  10600076   BEQ V1, ZERO, 0x9D002DC0
9D002BE8  00000000   NOP
9D002BEC  00021880   SLL V1, V0, 2
9D002BF0  3C029D00   LUI V0, -25344
9D002BF4  24422C08   ADDIU V0, V0, 11272
9D002BF8  00621021   ADDU V0, V1, V0
9D002BFC  8C420000   LW V0, 0(V0)
9D002C00  00400008   JR V0
9D002C04  00000000   NOP
2848:                    {
2849:                        case USB_REQUEST_SET_ADDRESS:
2850:                            inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
9D002C38  3C02A000   LUI V0, -24576
9D002C3C  244302C0   ADDIU V1, V0, 704
9D002C40  8C620004   LW V0, 4(V1)
9D002C44  24040001   ADDIU A0, ZERO, 1
9D002C48  7C8239C4   INS V0, A0, 7, 1
9D002C4C  AC620004   SW V0, 4(V1)
2851:                            USBDeviceState = ADR_PENDING_STATE;       // Update state only
9D002C50  24020008   ADDIU V0, ZERO, 8
9D002C54  AF828038   SW V0, -32712(GP)
2852:                            /* See USBCtrlTrfInHandler() for the next step */
2853:                            break;
9D002C58  0B400B74   J 0x9D002DD0
9D002C5C  00000000   NOP
2854:                        case USB_REQUEST_GET_DESCRIPTOR:
2855:                            USBStdGetDscHandler();
9D002C60  0F4007BA   JAL 0x9D001EE8
9D002C64  00000000   NOP
2856:                            break;
9D002C68  0B400B74   J 0x9D002DD0
9D002C6C  00000000   NOP
2857:                        case USB_REQUEST_SET_CONFIGURATION:
2858:                            USBStdSetCfgHandler();
9D002C70  0F40074D   JAL 0x9D001D34
9D002C74  00000000   NOP
2859:                            break;
9D002C78  0B400B74   J 0x9D002DD0
9D002C7C  00000000   NOP
2860:                        case USB_REQUEST_GET_CONFIGURATION:
2861:                            inPipes[0].pSrc.bRam = (BYTE*)&USBActiveConfiguration;         // Set Source
9D002C80  3C02A000   LUI V0, -24576
9D002C84  2783807C   ADDIU V1, GP, -32644
9D002C88  AC4302C0   SW V1, 704(V0)
2862:                            inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
9D002C8C  3C02A000   LUI V0, -24576
9D002C90  244302C0   ADDIU V1, V0, 704
9D002C94  8C620004   LW V0, 4(V1)
9D002C98  24040001   ADDIU A0, ZERO, 1
9D002C9C  7C820004   INS V0, A0, 0, 1
9D002CA0  AC620004   SW V0, 4(V1)
2863:                            inPipes[0].wCount.v[0] = 1;                         // Set data count
9D002CA4  3C02A000   LUI V0, -24576
9D002CA8  244202C0   ADDIU V0, V0, 704
9D002CAC  24030001   ADDIU V1, ZERO, 1
9D002CB0  A0430008   SB V1, 8(V0)
2864:                            inPipes[0].info.bits.busy = 1;
9D002CB4  3C02A000   LUI V0, -24576
9D002CB8  244302C0   ADDIU V1, V0, 704
9D002CBC  8C620004   LW V0, 4(V1)
9D002CC0  24040001   ADDIU A0, ZERO, 1
9D002CC4  7C8239C4   INS V0, A0, 7, 1
9D002CC8  AC620004   SW V0, 4(V1)
2865:                            break;
9D002CCC  0B400B74   J 0x9D002DD0
9D002CD0  00000000   NOP
2866:                        case USB_REQUEST_GET_STATUS:
2867:                            USBStdGetStatusHandler();
9D002CD4  0F400819   JAL 0x9D002064
9D002CD8  00000000   NOP
2868:                            break;
9D002CDC  0B400B74   J 0x9D002DD0
9D002CE0  00000000   NOP
2869:                        case USB_REQUEST_CLEAR_FEATURE:
2870:                        case USB_REQUEST_SET_FEATURE:
2871:                            USBStdFeatureReqHandler();
9D002CE4  0F400B7A   JAL 0x9D002DE8
9D002CE8  00000000   NOP
2872:                            break;
9D002CEC  0B400B74   J 0x9D002DD0
9D002CF0  00000000   NOP
2873:                        case USB_REQUEST_GET_INTERFACE:
2874:                            inPipes[0].pSrc.bRam = (BYTE*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
9D002CF4  93828070   LBU V0, -32656(GP)
9D002CF8  304200FF   ANDI V0, V0, 255
9D002CFC  00401821   ADDU V1, V0, ZERO
9D002D00  27828088   ADDIU V0, GP, -32632
9D002D04  00621821   ADDU V1, V1, V0
9D002D08  3C02A000   LUI V0, -24576
9D002D0C  AC4302C0   SW V1, 704(V0)
2875:                            inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
9D002D10  3C02A000   LUI V0, -24576
9D002D14  244302C0   ADDIU V1, V0, 704
9D002D18  8C620004   LW V0, 4(V1)
9D002D1C  24040001   ADDIU A0, ZERO, 1
9D002D20  7C820004   INS V0, A0, 0, 1
9D002D24  AC620004   SW V0, 4(V1)
2876:                            inPipes[0].wCount.v[0] = 1;                         // Set data count
9D002D28  3C02A000   LUI V0, -24576
9D002D2C  244202C0   ADDIU V0, V0, 704
9D002D30  24030001   ADDIU V1, ZERO, 1
9D002D34  A0430008   SB V1, 8(V0)
2877:                            inPipes[0].info.bits.busy = 1;
9D002D38  3C02A000   LUI V0, -24576
9D002D3C  244302C0   ADDIU V1, V0, 704
9D002D40  8C620004   LW V0, 4(V1)
9D002D44  24040001   ADDIU A0, ZERO, 1
9D002D48  7C8239C4   INS V0, A0, 7, 1
9D002D4C  AC620004   SW V0, 4(V1)
2878:                            break;
9D002D50  0B400B74   J 0x9D002DD0
9D002D54  00000000   NOP
2879:                        case USB_REQUEST_SET_INTERFACE:
2880:                            inPipes[0].info.bits.busy = 1;
9D002D58  3C02A000   LUI V0, -24576
9D002D5C  244302C0   ADDIU V1, V0, 704
9D002D60  8C620004   LW V0, 4(V1)
9D002D64  24040001   ADDIU A0, ZERO, 1
9D002D68  7C8239C4   INS V0, A0, 7, 1
9D002D6C  AC620004   SW V0, 4(V1)
2881:                            USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
9D002D70  93828070   LBU V0, -32656(GP)
9D002D74  304200FF   ANDI V0, V0, 255
9D002D78  00402021   ADDU A0, V0, ZERO
9D002D7C  9382806E   LBU V0, -32658(GP)
9D002D80  304300FF   ANDI V1, V0, 255
9D002D84  27828088   ADDIU V0, GP, -32632
9D002D88  00821021   ADDU V0, A0, V0
9D002D8C  A0430000   SB V1, 0(V0)
2882:                            break;
9D002D90  0B400B74   J 0x9D002DD0
9D002D94  00000000   NOP
2883:                        case USB_REQUEST_SET_DESCRIPTOR:
2884:                            USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
9D002D98  24040002   ADDIU A0, ZERO, 2
9D002D9C  00002821   ADDU A1, ZERO, ZERO
9D002DA0  00003021   ADDU A2, ZERO, ZERO
9D002DA4  0F401375   JAL USER_USB_CALLBACK_EVENT_HANDLER
9D002DA8  00000000   NOP
2885:                            break;
9D002DAC  0B400B74   J 0x9D002DD0
9D002DB0  00000000   NOP
2886:                        case USB_REQUEST_SYNCH_FRAME:
2887:                        default:
2888:                            break;
9D002DC0  00000000   NOP
9D002DC4  0B400B74   J 0x9D002DD0
9D002DC8  00000000   NOP
9D002DCC  00000000   NOP
2889:                    }//end switch
2890:                }//end USBCheckStdRequest
9D002DD0  03C0E821   ADDU SP, S8, ZERO
9D002DD4  8FBF0014   LW RA, 20(SP)
9D002DD8  8FBE0010   LW S8, 16(SP)
9D002DDC  27BD0018   ADDIU SP, SP, 24
9D002DE0  03E00008   JR RA
9D002DE4  00000000   NOP
2891:                
2892:                /********************************************************************
2893:                 * Function:        void USBStdFeatureReqHandler(void)
2894:                 *
2895:                 * PreCondition:    None
2896:                 *
2897:                 * Input:           None
2898:                 *
2899:                 * Output:          Can alter BDT entries.  Can also modify USB stack
2900:                 *                  Maintained variables.
2901:                 *
2902:                 * Side Effects:    None
2903:                 *
2904:                 * Overview:        This routine handles the standard SET & CLEAR
2905:                 *                  FEATURES requests
2906:                 *
2907:                 * Note:            This is a private function, intended for internal 
2908:                 *                  use by the USB stack, when processing SET/CLEAR
2909:                 *                  feature requests.  
2910:                 *******************************************************************/
2911:                static void USBStdFeatureReqHandler(void)
2912:                {
9D002DE8  27BDFFD8   ADDIU SP, SP, -40
9D002DEC  AFBF0024   SW RA, 36(SP)
9D002DF0  AFBE0020   SW S8, 32(SP)
9D002DF4  03A0F021   ADDU S8, SP, ZERO
2913:                    BDT_ENTRY *p;
2914:                    EP_STATUS current_ep_data;
2915:                    #if defined(__C32__)
2916:                        DWORD* pUEP;
2917:                    #else
2918:                        unsigned char* pUEP;             
2919:                    #endif
2920:                    
2921:                
2922:                    #ifdef	USB_SUPPORT_OTG
2923:                    //Check for USB On-The-Go (OTG) specific requests
2924:                    if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
2925:                        (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2926:                    {  
2927:                        inPipes[0].info.bits.busy = 1;
2928:                        if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2929:                            USBOTGEnableHnp();
2930:                        else
2931:                            USBOTGDisableHnp();
2932:                    }
2933:                
2934:                    if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
2935:                        (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2936:                    {
2937:                        inPipes[0].info.bits.busy = 1;
2938:                        if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2939:                            USBOTGEnableSupportHnp();
2940:                        else
2941:                            USBOTGDisableSupportHnp();
2942:                    }
2943:                
2944:                    if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
2945:                        (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2946:                    {
2947:                        inPipes[0].info.bits.busy = 1;
2948:                        if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2949:                            USBOTGEnableAltHnp();
2950:                        else
2951:                            USBOTGDisableAltHnp();
2952:                    }
2953:                    #endif   //#ifdef USB_SUPPORT_OTG 
2954:                
2955:                    //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2956:                    if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
9D002DF8  9382806E   LBU V0, -32658(GP)
9D002DFC  304300FF   ANDI V1, V0, 255
9D002E00  24020001   ADDIU V0, ZERO, 1
9D002E04  14620017   BNE V1, V0, 0x9D002E64
9D002E08  00000000   NOP
9D002E1C  14400011   BNE V0, ZERO, 0x9D002E64
9D002E20  00000000   NOP
2957:                       (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
9D002E0C  9382806C   LBU V0, -32660(GP)
9D002E10  304200FF   ANDI V0, V0, 255
9D002E14  3042001F   ANDI V0, V0, 31
9D002E18  304200FF   ANDI V0, V0, 255
2958:                    {
2959:                        inPipes[0].info.bits.busy = 1;
9D002E24  3C02A000   LUI V0, -24576
9D002E28  244302C0   ADDIU V1, V0, 704
9D002E2C  8C620004   LW V0, 4(V1)
9D002E30  24040001   ADDIU A0, ZERO, 1
9D002E34  7C8239C4   INS V0, A0, 7, 1
9D002E38  AC620004   SW V0, 4(V1)
2960:                        if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
9D002E3C  9382806D   LBU V0, -32659(GP)
9D002E40  304300FF   ANDI V1, V0, 255
9D002E44  24020003   ADDIU V0, ZERO, 3
9D002E48  14620005   BNE V1, V0, 0x9D002E60
9D002E4C  00000000   NOP
2961:                            RemoteWakeup = TRUE;
9D002E50  24020001   ADDIU V0, ZERO, 1
9D002E54  AF828080   SW V0, -32640(GP)
9D002E58  0B400B99   J 0x9D002E64
9D002E5C  00000000   NOP
2962:                        else
2963:                            RemoteWakeup = FALSE;
9D002E60  AF808080   SW ZERO, -32640(GP)
2964:                    }//end if
2965:                
2966:                    //Check if the host sent a valid SET or CLEAR endpoint halt request.
2967:                    if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
9D002E64  9382806E   LBU V0, -32658(GP)
9D002E68  304200FF   ANDI V0, V0, 255
9D002E6C  14400174   BNE V0, ZERO, 0x9D003440
9D002E70  00000000   NOP
9D002E84  24020002   ADDIU V0, ZERO, 2
9D002E88  1462016D   BNE V1, V0, 0x9D003440
9D002E8C  00000000   NOP
2968:                       (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
9D002E74  9382806C   LBU V0, -32660(GP)
9D002E78  304200FF   ANDI V0, V0, 255
9D002E7C  3042001F   ANDI V0, V0, 31
9D002E80  304300FF   ANDI V1, V0, 255
9D002EA0  10400167   BEQ V0, ZERO, 0x9D003440
9D002EA4  00000000   NOP
2969:                       (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
9D002E90  93828070   LBU V0, -32656(GP)
9D002E94  304200FF   ANDI V0, V0, 255
9D002E98  3042000F   ANDI V0, V0, 15
9D002E9C  304200FF   ANDI V0, V0, 255
9D002EA8  8F828070   LW V0, -32656(GP)
9D002EAC  7C421800   EXT V0, V0, 0, 4
9D002EB0  304200FF   ANDI V0, V0, 255
9D002EB4  28420002   SLTI V0, V0, 2
9D002EB8  10400161   BEQ V0, ZERO, 0x9D003440
9D002EBC  00000000   NOP
9D002EC4  24020020   ADDIU V0, ZERO, 32
9D002EC8  1462015D   BNE V1, V0, 0x9D003440
9D002ECC  00000000   NOP
2970:                       (USBDeviceState == CONFIGURED_STATE))
9D002EC0  8F838038   LW V1, -32712(GP)
2971:                    {
2972:                		//The request was valid.  Take control of the control transfer and
2973:                		//perform the host requested action.
2974:                		inPipes[0].info.bits.busy = 1;
9D002ED0  3C02A000   LUI V0, -24576
9D002ED4  244302C0   ADDIU V1, V0, 704
9D002ED8  8C620004   LW V0, 4(V1)
9D002EDC  24040001   ADDIU A0, ZERO, 1
9D002EE0  7C8239C4   INS V0, A0, 7, 1
9D002EE4  AC620004   SW V0, 4(V1)
2975:                
2976:                        //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2977:                        if(SetupPkt.EPDir == OUT_FROM_HOST)
9D002EE8  93828070   LBU V0, -32656(GP)
9D002EEC  304300FF   ANDI V1, V0, 255
9D002EF0  2402FF80   ADDIU V0, ZERO, -128
9D002EF4  00621024   AND V0, V1, V0
9D002EF8  304200FF   ANDI V0, V0, 255
9D002EFC  14400013   BNE V0, ZERO, 0x9D002F4C
9D002F00  00000000   NOP
2978:                        {
2979:                            p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
9D002F04  8F828070   LW V0, -32656(GP)
9D002F08  7C421800   EXT V0, V0, 0, 4
9D002F0C  304200FF   ANDI V0, V0, 255
9D002F10  00021880   SLL V1, V0, 2
9D002F14  27828054   ADDIU V0, GP, -32684
9D002F18  00621021   ADDU V0, V1, V0
9D002F1C  8C420000   LW V0, 0(V0)
9D002F20  AFC20014   SW V0, 20(S8)
2980:                            current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
9D002F24  8F828070   LW V0, -32656(GP)
9D002F28  7C421800   EXT V0, V0, 0, 4
9D002F2C  304200FF   ANDI V0, V0, 255
9D002F30  00401821   ADDU V1, V0, ZERO
9D002F34  27828048   ADDIU V0, GP, -32696
9D002F38  00621021   ADDU V0, V1, V0
9D002F3C  90420000   LBU V0, 0(V0)
9D002F40  A3C20018   SB V0, 24(S8)
9D002F44  0B400BE3   J 0x9D002F8C
9D002F48  00000000   NOP
2981:                        }
2982:                        else
2983:                        {
2984:                            p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
9D002F4C  8F828070   LW V0, -32656(GP)
9D002F50  7C421800   EXT V0, V0, 0, 4
9D002F54  304200FF   ANDI V0, V0, 255
9D002F58  00021880   SLL V1, V0, 2
9D002F5C  27828040   ADDIU V0, GP, -32704
9D002F60  00621021   ADDU V0, V1, V0
9D002F64  8C420000   LW V0, 0(V0)
9D002F68  AFC20014   SW V0, 20(S8)
2985:                            current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
9D002F6C  8F828070   LW V0, -32656(GP)
9D002F70  7C421800   EXT V0, V0, 0, 4
9D002F74  304200FF   ANDI V0, V0, 255
9D002F78  00401821   ADDU V1, V0, ZERO
9D002F7C  27828074   ADDIU V0, GP, -32652
9D002F80  00621021   ADDU V0, V1, V0
9D002F84  90420000   LBU V0, 0(V0)
9D002F88  A3C20018   SB V0, 24(S8)
2986:                        }
2987:                
2988:                        //If ping pong buffering is enabled on the requested endpoint, need 
2989:                        //to point to the one that is the active BDT entry which the SIE will 
2990:                        //use for the next attempted transaction on that EP number.
2991:                        #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2992:                            if(current_ep_data.bits.ping_pong_state == 0) //Check if even
9D002F8C  93C20018   LBU V0, 24(S8)
9D002F90  30420001   ANDI V0, V0, 1
9D002F94  304200FF   ANDI V0, V0, 255
9D002F98  1440000A   BNE V0, ZERO, 0x9D002FC4
9D002F9C  00000000   NOP
2993:                            {
2994:                                USBHALPingPongSetToEven(&p);
9D002FA0  27C20014   ADDIU V0, S8, 20
9D002FA4  27C30014   ADDIU V1, S8, 20
9D002FA8  90640000   LBU A0, 0(V1)
9D002FAC  2403FFF7   ADDIU V1, ZERO, -9
9D002FB0  00831824   AND V1, A0, V1
9D002FB4  306300FF   ANDI V1, V1, 255
9D002FB8  A0430000   SB V1, 0(V0)
9D002FBC  0B400BF7   J 0x9D002FDC
9D002FC0  00000000   NOP
2995:                            }
2996:                            else //else must have been odd
2997:                            {
2998:                                USBHALPingPongSetToOdd(&p);
9D002FC4  27C20014   ADDIU V0, S8, 20
9D002FC8  27C30014   ADDIU V1, S8, 20
9D002FCC  90630000   LBU V1, 0(V1)
9D002FD0  34630008   ORI V1, V1, 8
9D002FD4  306300FF   ANDI V1, V1, 255
9D002FD8  A0430000   SB V1, 0(V0)
2999:                            }
3000:                        #endif
3001:                        
3002:                        //Update the BDT pointers with the new, next entry based on the feature
3003:                        //  request
3004:                        if(SetupPkt.EPDir == OUT_FROM_HOST)
9D002FDC  93828070   LBU V0, -32656(GP)
9D002FE0  304300FF   ANDI V1, V0, 255
9D002FE4  2402FF80   ADDIU V0, ZERO, -128
9D002FE8  00621024   AND V0, V1, V0
9D002FEC  304200FF   ANDI V0, V0, 255
9D002FF0  1440000B   BNE V0, ZERO, 0x9D003020
9D002FF4  00000000   NOP
3005:                        {
3006:                            pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
9D002FF8  8F828070   LW V0, -32656(GP)
9D002FFC  7C421800   EXT V0, V0, 0, 4
9D003000  304200FF   ANDI V0, V0, 255
9D003004  8FC30014   LW V1, 20(S8)
9D003008  00022080   SLL A0, V0, 2
9D00300C  27828054   ADDIU V0, GP, -32684
9D003010  00821021   ADDU V0, A0, V0
9D003014  AC430000   SW V1, 0(V0)
9D003018  0B400C10   J 0x9D003040
9D00301C  00000000   NOP
3007:                        }
3008:                        else
3009:                        {
3010:                            pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
9D003020  8F828070   LW V0, -32656(GP)
9D003024  7C421800   EXT V0, V0, 0, 4
9D003028  304200FF   ANDI V0, V0, 255
9D00302C  8FC30014   LW V1, 20(S8)
9D003030  00022080   SLL A0, V0, 2
9D003034  27828040   ADDIU V0, GP, -32704
9D003038  00821021   ADDU V0, A0, V0
9D00303C  AC430000   SW V1, 0(V0)
3011:                        }
3012:                
3013:                		//Check if it was a SET_FEATURE endpoint halt request
3014:                        if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
9D003040  9382806D   LBU V0, -32659(GP)
9D003044  304300FF   ANDI V1, V0, 255
9D003048  24020003   ADDIU V0, ZERO, 3
9D00304C  1462003B   BNE V1, V0, 0x9D00313C
9D003050  00000000   NOP
3015:                        {
3016:                            if(p->STAT.UOWN == 1)
9D003054  8FC20014   LW V0, 20(S8)
9D003058  90430000   LBU V1, 0(V0)
9D00305C  2402FF80   ADDIU V0, ZERO, -128
9D003060  00621024   AND V0, V1, V0
9D003064  304200FF   ANDI V0, V0, 255
9D003068  1040001E   BEQ V0, ZERO, 0x9D0030E4
9D00306C  00000000   NOP
3017:                            {
3018:                                //Mark that we are terminating this transfer and that the user
3019:                                //  needs to be notified later
3020:                                if(SetupPkt.EPDir == OUT_FROM_HOST)
9D003070  93828070   LBU V0, -32656(GP)
9D003074  304300FF   ANDI V1, V0, 255
9D003078  2402FF80   ADDIU V0, ZERO, -128
9D00307C  00621024   AND V0, V1, V0
9D003080  304200FF   ANDI V0, V0, 255
9D003084  1440000D   BNE V0, ZERO, 0x9D0030BC
9D003088  00000000   NOP
3021:                                {
3022:                                    ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
9D00308C  8F828070   LW V0, -32656(GP)
9D003090  7C421800   EXT V0, V0, 0, 4
9D003094  304200FF   ANDI V0, V0, 255
9D003098  00401821   ADDU V1, V0, ZERO
9D00309C  27828048   ADDIU V0, GP, -32696
9D0030A0  00621821   ADDU V1, V1, V0
9D0030A4  90620000   LBU V0, 0(V1)
9D0030A8  24040001   ADDIU A0, ZERO, 1
9D0030AC  7C820844   INS V0, A0, 1, 1
9D0030B0  A0620000   SB V0, 0(V1)
9D0030B4  0B400C39   J 0x9D0030E4
9D0030B8  00000000   NOP
3023:                                }
3024:                                else
3025:                                {
3026:                                    ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
9D0030BC  8F828070   LW V0, -32656(GP)
9D0030C0  7C421800   EXT V0, V0, 0, 4
9D0030C4  304200FF   ANDI V0, V0, 255
9D0030C8  00401821   ADDU V1, V0, ZERO
9D0030CC  27828074   ADDIU V0, GP, -32652
9D0030D0  00621821   ADDU V1, V1, V0
9D0030D4  90620000   LBU V0, 0(V1)
9D0030D8  24040001   ADDIU A0, ZERO, 1
9D0030DC  7C820844   INS V0, A0, 1, 1
9D0030E0  A0620000   SB V0, 0(V1)
3027:                                }
3028:                            }
3029:                
3030:                			//Then STALL the endpoint
3031:                            p->STAT.Val |= _USIE|_BSTALL;
9D0030E4  8FC20014   LW V0, 20(S8)
9D0030E8  8FC30014   LW V1, 20(S8)
9D0030EC  90640000   LBU A0, 0(V1)
9D0030F0  90630001   LBU V1, 1(V1)
9D0030F4  00031A00   SLL V1, V1, 8
9D0030F8  00641825   OR V1, V1, A0
9D0030FC  3063FFFF   ANDI V1, V1, -1
9D003100  34630084   ORI V1, V1, 132
9D003104  3063FFFF   ANDI V1, V1, -1
9D003108  306400FF   ANDI A0, V1, 255
9D00310C  90450000   LBU A1, 0(V0)
9D003110  30A50000   ANDI A1, A1, 0
9D003114  00A42025   OR A0, A1, A0
9D003118  A0440000   SB A0, 0(V0)
9D00311C  00031A02   SRL V1, V1, 8
9D003120  3063FFFF   ANDI V1, V1, -1
9D003124  90440001   LBU A0, 1(V0)
9D003128  30840000   ANDI A0, A0, 0
9D00312C  00831825   OR V1, A0, V1
9D003130  A0430001   SB V1, 1(V0)
9D003134  0B400D10   J 0x9D003440
9D003138  00000000   NOP
3032:                        }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
3033:                        else
3034:                        {
3035:                			//Else the request must have been a CLEAR_FEATURE endpoint halt.
3036:                            #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
3037:                                //toggle over the to the non-active BDT
3038:                                USBAdvancePingPongBuffer(&p);  
9D00313C  27C20014   ADDIU V0, S8, 20
9D003140  27C30014   ADDIU V1, S8, 20
9D003144  90630000   LBU V1, 0(V1)
9D003148  38630008   XORI V1, V1, 8
9D00314C  306300FF   ANDI V1, V1, 255
9D003150  A0430000   SB V1, 0(V0)
3039:                
3040:                                if(p->STAT.UOWN == 1)
9D003154  8FC20014   LW V0, 20(S8)
9D003158  90430000   LBU V1, 0(V0)
9D00315C  2402FF80   ADDIU V0, ZERO, -128
9D003160  00621024   AND V0, V1, V0
9D003164  304200FF   ANDI V0, V0, 255
9D003168  10400032   BEQ V0, ZERO, 0x9D003234
9D00316C  00000000   NOP
3041:                                {
3042:                                    //Clear UOWN and set DTS state so it will be correct the next time
3043:                                    //the application firmware uses USBTransferOnePacket() on the EP.
3044:                                    p->STAT.Val &= (~_USIE);    //Clear UOWN bit
9D003170  8FC20014   LW V0, 20(S8)
9D003174  8FC30014   LW V1, 20(S8)
9D003178  90640000   LBU A0, 0(V1)
9D00317C  90630001   LBU V1, 1(V1)
9D003180  00031A00   SLL V1, V1, 8
9D003184  00641825   OR V1, V1, A0
9D003188  3064FFFF   ANDI A0, V1, -1
9D00318C  2403FF7F   ADDIU V1, ZERO, -129
9D003190  00831824   AND V1, A0, V1
9D003194  3063FFFF   ANDI V1, V1, -1
9D003198  306400FF   ANDI A0, V1, 255
9D00319C  90450000   LBU A1, 0(V0)
9D0031A0  30A50000   ANDI A1, A1, 0
9D0031A4  00A42025   OR A0, A1, A0
9D0031A8  A0440000   SB A0, 0(V0)
9D0031AC  00031A02   SRL V1, V1, 8
9D0031B0  3063FFFF   ANDI V1, V1, -1
9D0031B4  90440001   LBU A0, 1(V0)
9D0031B8  30840000   ANDI A0, A0, 0
9D0031BC  00831825   OR V1, A0, V1
9D0031C0  A0430001   SB V1, 1(V0)
3045:                                    p->STAT.Val |= _DAT1;       //Set DTS to DATA1
9D0031C4  8FC20014   LW V0, 20(S8)
9D0031C8  8FC30014   LW V1, 20(S8)
9D0031CC  90640000   LBU A0, 0(V1)
9D0031D0  90630001   LBU V1, 1(V1)
9D0031D4  00031A00   SLL V1, V1, 8
9D0031D8  00641825   OR V1, V1, A0
9D0031DC  3063FFFF   ANDI V1, V1, -1
9D0031E0  34630040   ORI V1, V1, 64
9D0031E4  3063FFFF   ANDI V1, V1, -1
9D0031E8  306400FF   ANDI A0, V1, 255
9D0031EC  90450000   LBU A1, 0(V0)
9D0031F0  30A50000   ANDI A1, A1, 0
9D0031F4  00A42025   OR A0, A1, A0
9D0031F8  A0440000   SB A0, 0(V0)
9D0031FC  00031A02   SRL V1, V1, 8
9D003200  3063FFFF   ANDI V1, V1, -1
9D003204  90440001   LBU A0, 1(V0)
9D003208  30840000   ANDI A0, A0, 0
9D00320C  00831825   OR V1, A0, V1
9D003210  A0430001   SB V1, 1(V0)
3046:                                    USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
9D003214  8FC20014   LW V0, 20(S8)
9D003218  24040005   ADDIU A0, ZERO, 5
9D00321C  00402821   ADDU A1, V0, ZERO
9D003220  24060004   ADDIU A2, ZERO, 4
9D003224  0F401375   JAL USER_USB_CALLBACK_EVENT_HANDLER
9D003228  00000000   NOP
9D00322C  0B400CA1   J 0x9D003284
9D003230  00000000   NOP
3047:                                }
3048:                                else
3049:                                {
3050:                                    //UOWN already clear, but still need to set DTS to DATA1     
3051:                					p->STAT.Val |= _DAT1;
9D003234  8FC20014   LW V0, 20(S8)
9D003238  8FC30014   LW V1, 20(S8)
9D00323C  90640000   LBU A0, 0(V1)
9D003240  90630001   LBU V1, 1(V1)
9D003244  00031A00   SLL V1, V1, 8
9D003248  00641825   OR V1, V1, A0
9D00324C  3063FFFF   ANDI V1, V1, -1
9D003250  34630040   ORI V1, V1, 64
9D003254  3063FFFF   ANDI V1, V1, -1
9D003258  306400FF   ANDI A0, V1, 255
9D00325C  90450000   LBU A1, 0(V0)
9D003260  30A50000   ANDI A1, A1, 0
9D003264  00A42025   OR A0, A1, A0
9D003268  A0440000   SB A0, 0(V0)
9D00326C  00031A02   SRL V1, V1, 8
9D003270  3063FFFF   ANDI V1, V1, -1
9D003274  90440001   LBU A0, 1(V0)
9D003278  30840000   ANDI A0, A0, 0
9D00327C  00831825   OR V1, A0, V1
9D003280  A0430001   SB V1, 1(V0)
3052:                                }
3053:                
3054:                                //toggle back to the active BDT (the one the SIE is currently looking at
3055:                                //and will use for the next successful transaction to take place on the EP
3056:                                USBAdvancePingPongBuffer(&p);    
9D003284  27C20014   ADDIU V0, S8, 20
9D003288  27C30014   ADDIU V1, S8, 20
9D00328C  90630000   LBU V1, 0(V1)
9D003290  38630008   XORI V1, V1, 8
9D003294  306300FF   ANDI V1, V1, 255
9D003298  A0430000   SB V1, 0(V0)
3057:                                
3058:                                //Check if we are currently terminating, or have previously terminated
3059:                                //a transaction on the given endpoint.  If so, need to clear UOWN,
3060:                                //set DTS to the proper state, and call the application callback
3061:                                //function.
3062:                                if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
9D00329C  93C20018   LBU V0, 24(S8)
9D0032A0  30420002   ANDI V0, V0, 2
9D0032A4  304200FF   ANDI V0, V0, 255
9D0032A8  14400008   BNE V0, ZERO, 0x9D0032CC
9D0032AC  00000000   NOP
9D0032B0  8FC20014   LW V0, 20(S8)
9D0032B4  90430000   LBU V1, 0(V0)
9D0032B8  2402FF80   ADDIU V0, ZERO, -128
9D0032BC  00621024   AND V0, V1, V0
9D0032C0  304200FF   ANDI V0, V0, 255
9D0032C4  10400039   BEQ V0, ZERO, 0x9D0033AC
9D0032C8  00000000   NOP
3063:                                {
3064:                                    if(SetupPkt.EPDir == OUT_FROM_HOST)
9D0032CC  93828070   LBU V0, -32656(GP)
9D0032D0  304300FF   ANDI V1, V0, 255
9D0032D4  2402FF80   ADDIU V0, ZERO, -128
9D0032D8  00621024   AND V0, V1, V0
9D0032DC  304200FF   ANDI V0, V0, 255
9D0032E0  1440000C   BNE V0, ZERO, 0x9D003314
9D0032E4  00000000   NOP
3065:                                    {
3066:                                        ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
9D0032E8  8F828070   LW V0, -32656(GP)
9D0032EC  7C421800   EXT V0, V0, 0, 4
9D0032F0  304200FF   ANDI V0, V0, 255
9D0032F4  00401821   ADDU V1, V0, ZERO
9D0032F8  27828048   ADDIU V0, GP, -32696
9D0032FC  00621821   ADDU V1, V1, V0
9D003300  90620000   LBU V0, 0(V1)
9D003304  7C020844   INS V0, ZERO, 1, 1
9D003308  A0620000   SB V0, 0(V1)
9D00330C  0B400CCE   J 0x9D003338
9D003310  00000000   NOP
3067:                                    }
3068:                                    else
3069:                                    {
3070:                                        ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
9D003314  8F828070   LW V0, -32656(GP)
9D003318  7C421800   EXT V0, V0, 0, 4
9D00331C  304200FF   ANDI V0, V0, 255
9D003320  00401821   ADDU V1, V0, ZERO
9D003324  27828074   ADDIU V0, GP, -32652
9D003328  00621821   ADDU V1, V1, V0
9D00332C  90620000   LBU V0, 0(V1)
9D003330  7C020844   INS V0, ZERO, 1, 1
9D003334  A0620000   SB V0, 0(V1)
3071:                                    }
3072:                                    //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
3073:                                    p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
9D003338  8FC20014   LW V0, 20(S8)
9D00333C  8FC30014   LW V1, 20(S8)
9D003340  90640000   LBU A0, 0(V1)
9D003344  90630001   LBU V1, 1(V1)
9D003348  00031A00   SLL V1, V1, 8
9D00334C  00641825   OR V1, V1, A0
9D003350  3064FFFF   ANDI A0, V1, -1
9D003354  2403FF3B   ADDIU V1, ZERO, -197
9D003358  00831824   AND V1, A0, V1
9D00335C  3063FFFF   ANDI V1, V1, -1
9D003360  306400FF   ANDI A0, V1, 255
9D003364  90450000   LBU A1, 0(V0)
9D003368  30A50000   ANDI A1, A1, 0
9D00336C  00A42025   OR A0, A1, A0
9D003370  A0440000   SB A0, 0(V0)
9D003374  00031A02   SRL V1, V1, 8
9D003378  3063FFFF   ANDI V1, V1, -1
9D00337C  90440001   LBU A0, 1(V0)
9D003380  30840000   ANDI A0, A0, 0
9D003384  00831825   OR V1, A0, V1
9D003388  A0430001   SB V1, 1(V0)
3074:                                    //Call the application event handler callback function, so it can 
3075:                					//decide if the endpoint should get re-armed again or not.
3076:                                    USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
9D00338C  8FC20014   LW V0, 20(S8)
9D003390  24040005   ADDIU A0, ZERO, 5
9D003394  00402821   ADDU A1, V0, ZERO
9D003398  24060004   ADDIU A2, ZERO, 4
9D00339C  0F401375   JAL USER_USB_CALLBACK_EVENT_HANDLER
9D0033A0  00000000   NOP
9D0033A4  0B400D00   J 0x9D003400
9D0033A8  00000000   NOP
3077:                                }
3078:                                else
3079:                                {
3080:                                    //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
3081:                                    p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
9D0033AC  8FC20014   LW V0, 20(S8)
9D0033B0  8FC30014   LW V1, 20(S8)
9D0033B4  90640000   LBU A0, 0(V1)
9D0033B8  90630001   LBU V1, 1(V1)
9D0033BC  00031A00   SLL V1, V1, 8
9D0033C0  00641825   OR V1, V1, A0
9D0033C4  3064FFFF   ANDI A0, V1, -1
9D0033C8  2403FF3B   ADDIU V1, ZERO, -197
9D0033CC  00831824   AND V1, A0, V1
9D0033D0  3063FFFF   ANDI V1, V1, -1
9D0033D4  306400FF   ANDI A0, V1, 255
9D0033D8  90450000   LBU A1, 0(V0)
9D0033DC  30A50000   ANDI A1, A1, 0
9D0033E0  00A42025   OR A0, A1, A0
9D0033E4  A0440000   SB A0, 0(V0)
9D0033E8  00031A02   SRL V1, V1, 8
9D0033EC  3063FFFF   ANDI V1, V1, -1
9D0033F0  90440001   LBU A0, 1(V0)
9D0033F4  30840000   ANDI A0, A0, 0
9D0033F8  00831825   OR V1, A0, V1
9D0033FC  A0430001   SB V1, 1(V0)
3082:                                } 
3083:                            #else //else we must not be using ping-pong buffering on the requested endpoint
3084:                                //Check if we need to call the user transfer terminated event callback function.
3085:                                //We should call the callback, if the endpoint was previously terminated,
3086:                                //or the endpoint is currently armed, and the host is performing clear
3087:                                //endpoint halt, even though the endpoint wasn't stalled.
3088:                                if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
3089:                                {
3090:                                    //We are going to call the user transfer terminated callback.
3091:                                    //Clear the flag so we know we took care of it and don't need
3092:                                    //to call it again later.
3093:                                    if(SetupPkt.EPDir == OUT_FROM_HOST)
3094:                                    {
3095:                                        ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
3096:                                    }
3097:                                    else
3098:                                    {
3099:                                        ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
3100:                                    }
3101:                 
3102:                                    //Clear UOWN and remove the STALL condition.   
3103:                                    //  In this case we also need to set the DTS bit to 1 so that
3104:                                    //  it toggles to DATA0 the next time the application firmware
3105:                                    //  calls USBTransferOnePacket() (or equivalent macro).  
3106:                                    p->STAT.Val &= ~(_USIE | _BSTALL);  
3107:                                    p->STAT.Val |= _DAT1;
3108:                                    //Let the application firmware know a transaction just
3109:                                    //got terminated by the host, and that it is now free to
3110:                                    //re-arm the endpoint or do other tasks if desired.                                        
3111:                                    USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
3112:                                }
3113:                                else
3114:                                {
3115:                                    //Clear UOWN and remove the STALL condition.   
3116:                                    //  In this case we also need to set the DTS bit to 1 so that
3117:                                    //  it toggles to DATA0 the next time the application firmware
3118:                                    //  calls USBTransferOnePacket() (or equivalent macro).  
3119:                                    p->STAT.Val &= ~(_USIE | _BSTALL);  
3120:                                    p->STAT.Val |= _DAT1;
3121:                                } 
3122:                            #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
3123:                            
3124:                			//Get a pointer to the appropriate UEPn register
3125:                            #if defined(__C32__)
3126:                                pUEP = (DWORD*)(&U1EP0);
9D003400  3C02BF88   LUI V0, -16504
9D003404  24425300   ADDIU V0, V0, 21248
9D003408  AFC20010   SW V0, 16(S8)
3127:                                pUEP += (SetupPkt.EPNum*4);
9D00340C  8F828070   LW V0, -32656(GP)
9D003410  7C421800   EXT V0, V0, 0, 4
9D003414  304200FF   ANDI V0, V0, 255
9D003418  00021100   SLL V0, V0, 4
9D00341C  8FC30010   LW V1, 16(S8)
9D003420  00621021   ADDU V0, V1, V0
9D003424  AFC20010   SW V0, 16(S8)
3128:                            #else
3129:                                pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
3130:                            #endif
3131:                
3132:                			//Clear the STALL bit in the UEP register
3133:                            *pUEP &= ~UEP_STALL;            
9D003428  8FC20010   LW V0, 16(S8)
9D00342C  8C430000   LW V1, 0(V0)
9D003430  2402FFFD   ADDIU V0, ZERO, -3
9D003434  00621824   AND V1, V1, V0
9D003438  8FC20010   LW V0, 16(S8)
9D00343C  AC430000   SW V1, 0(V0)
3134:                        }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
3135:                    }//end if (lots of checks for set/clear endpoint halt)
3136:                }//end USBStdFeatureReqHandler
9D003440  03C0E821   ADDU SP, S8, ZERO
9D003444  8FBF0024   LW RA, 36(SP)
9D003448  8FBE0020   LW S8, 32(SP)
9D00344C  27BD0028   ADDIU SP, SP, 40
9D003450  03E00008   JR RA
9D003454  00000000   NOP
3137:                
3138:                
3139:                /** EOF USBDevice.c *****************************************************/
---  /home/bekeband/MPLABXProjects/AN1388_Source_Code_2014_02_14/PIC32_Bootloaders/Firmware/Bootloader/Source/USB/Usb_HID_tasks.c
1:                    /*********************************************************************
2:                    *
3:                    *                  PIC32 Boot Loader
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Usb_Tasks.c
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   * Compiler:        MPLAB C32
11:                   *                  MPLAB IDE
12:                   * Company:         Microchip Technology, Inc.
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * The software supplied herewith by Microchip Technology Incorporated
17:                   * (the ï¿½Companyï¿½) for its PIC32 Microcontroller is intended
18:                   * and supplied to you, the Companyï¿½s customer, for use solely and
19:                   * exclusively on Microchip PIC32 Microcontroller products.
20:                   * The software is owned by the Company and/or its supplier, and is
21:                   * protected under applicable copyright laws. All rights are reserved.
22:                   * Any use in violation of the foregoing restrictions may subject the
23:                   * user to criminal sanctions under applicable laws, as well as to
24:                   * civil liability for the breach of the terms and conditions of this
25:                   * license.
26:                   *
27:                   * THIS SOFTWARE IS PROVIDED IN AN ï¿½AS ISï¿½ CONDITION. NO WARRANTIES,
28:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
29:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
30:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
31:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
32:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
33:                   *
34:                   *
35:                   * $Id:  $
36:                   * $Name: $
37:                   *
38:                   **********************************************************************/
39:                  #include <p32xxxx.h>
40:                  #include <stdlib.h>
41:                  #include <plib.h>
42:                  
43:                  
44:                  #include "./USB/usb.h"
45:                  #include "HardwareProfile.h"
46:                  #include "./USB/usb_function_hid.h"
47:                  
48:                  #include "Include/BootLoader.h"
49:                  #include "Include/Framework/Framework.h"
50:                  
51:                  
52:                  #define UsbTxBusy() 		(USBHandleBusy(USBInHandle))
53:                  #define UsbRxDataAvlbl() 	(!USBHandleBusy(USBOutHandle))
54:                  
55:                  
56:                  #define MaxUsbPacketSize 64
57:                  
58:                  
59:                  static UINT8 UsbRxData[MaxUsbPacketSize];
60:                  static UINT8 UsbTxData[FRAMEWORK_BUFF_SIZE];
61:                  
62:                  
63:                  
64:                  USB_HANDLE USBOutHandle = 0;
65:                  USB_HANDLE USBInHandle = 0;
66:                  
67:                  
68:                  /********************************************************************
69:                  * Function: 	UsbInit()
70:                  *
71:                  * Precondition: 
72:                  *
73:                  * Input: 		pbClk: Not used.
74:                  *
75:                  * Output:		None.
76:                  *
77:                  * Side Effects:	None.
78:                  *
79:                  * Overview: 	Initializes USB
80:                  *
81:                  *			
82:                  * Note:		 	None.
83:                  ********************************************************************/
84:                  void UsbInit(UINT pbClk)
85:                  {
9D004AFC  27BDFFE8   ADDIU SP, SP, -24
9D004B00  AFBF0014   SW RA, 20(SP)
9D004B04  AFBE0010   SW S8, 16(SP)
9D004B08  03A0F021   ADDU S8, SP, ZERO
9D004B0C  AFC40018   SW A0, 24(S8)
86:                  //	The USB specifications require that USB peripheral devices must never source
87:                  //	current onto the Vbus pin.  Additionally, USB peripherals should not source
88:                  //	current on D+ or D- when the host/hub is not actively powering the Vbus line.
89:                  //	When designing a self powered (as opposed to bus powered) USB peripheral
90:                  //	device, the firmware should make sure not to turn on the USB module and D+
91:                  //	or D- pull up resistor unless Vbus is actively powered.  Therefore, the
92:                  //	firmware needs some means to detect when Vbus is being powered by the host.
93:                  //	A 5V tolerant I/O pin can be connected to Vbus (through a resistor), and
94:                  // 	can be used to detect when Vbus is high (host actively powering), or low
95:                  //	(host is shut down or otherwise not supplying power).  The USB firmware
96:                  // 	can then periodically poll this I/O pin to know when it is okay to turn on
97:                  //	the USB module/D+/D- pull up resistor.  When designing a purely bus powered
98:                  //	peripheral device, it is not possible to source current on D+ or D- when the
99:                  //	host is not actively providing power on Vbus. Therefore, implementing this
100:                 //	bus sense feature is optional.  This firmware can be made to use this bus
101:                 //	sense feature by making sure "USE_USB_BUS_SENSE_IO" has been defined in the
102:                 //	HardwareProfile.h file.    
103:                     #if defined(USE_USB_BUS_SENSE_IO)
104:                     tris_usb_bus_sense = INPUT_PIN; // See HardwareProfile.h
105:                     #endif
106:                     
107:                 //	If the host PC sends a GetStatus (device) request, the firmware must respond
108:                 //	and let the host know if the USB peripheral device is currently bus powered
109:                 //	or self powered.  See chapter 9 in the official USB specifications for details
110:                 //	regarding this request.  If the peripheral device is capable of being both
111:                 //	self and bus powered, it should not return a hard coded value for this request.
112:                 //	Instead, firmware should check if it is currently self or bus powered, and
113:                 //	respond accordingly.  If the hardware has been configured like demonstrated
114:                 //	on the PICDEM FS USB Demo Board, an I/O pin can be polled to determine the
115:                 //	currently selected power source.  On the PICDEM FS USB Demo Board, "RA2" 
116:                 //	is used for	this purpose.  If using this feature, make sure "USE_SELF_POWER_SENSE_IO"
117:                 //	has been defined in HardwareProfile.h, and that an appropriate I/O pin has been mapped
118:                 //	to it in HardwareProfile.h.
119:                     #if defined(USE_SELF_POWER_SENSE_IO)
120:                     tris_self_power = INPUT_PIN;	// See HardwareProfile.h
121:                     #endif
122:                     
123:                    
124:                 	 // Call USB Stack function to initialize USB.
125:                 	 USBDeviceInit();
9D004B10  0F400008   JAL USBDeviceInit
9D004B14  00000000   NOP
126:                 	 
127:                 	 
128:                 	#if defined(USB_INTERRUPT)
129:                 	INTEnableSystemMultiVectoredInt();
130:                     USBDeviceAttach();
131:                     #endif
132:                 	
133:                 }	
9D004B18  03C0E821   ADDU SP, S8, ZERO
9D004B1C  8FBF0014   LW RA, 20(SP)
9D004B20  8FBE0010   LW S8, 16(SP)
9D004B24  27BD0018   ADDIU SP, SP, 24
9D004B28  03E00008   JR RA
9D004B2C  00000000   NOP
134:                 
135:                 
136:                 /********************************************************************
137:                 * Function: 	UsbClose()
138:                 *
139:                 * Precondition: 
140:                 *
141:                 * Input: 		None.
142:                 *
143:                 * Output:		None.
144:                 *
145:                 * Side Effects:	None.
146:                 *
147:                 * Overview: 	This function transmits frames and received frames to and from USB.
148:                 *
149:                 *			
150:                 * Note:		 	None.
151:                 ********************************************************************/
152:                 void UsbClose(void)
153:                 {
9D004B30  27BDFFF8   ADDIU SP, SP, -8
9D004B34  AFBE0004   SW S8, 4(SP)
9D004B38  03A0F021   ADDU S8, SP, ZERO
154:                     USBDisableInterrupts();
9D004B3C  3C02BF88   LUI V0, -16504
9D004B40  3C030200   LUI V1, 512
9D004B44  AC431074   SW V1, 4212(V0)
155:                 	
156:                 }	
9D004B48  03C0E821   ADDU SP, S8, ZERO
9D004B4C  8FBE0004   LW S8, 4(SP)
9D004B50  27BD0008   ADDIU SP, SP, 8
9D004B54  03E00008   JR RA
9D004B58  00000000   NOP
157:                 
158:                 /********************************************************************
159:                 * Function: 	UsbTasks()
160:                 *
161:                 * Precondition: 
162:                 *
163:                 * Input: 		None.
164:                 *
165:                 * Output:		None.
166:                 *
167:                 * Side Effects:	None.
168:                 *
169:                 * Overview: 	This function transmits frames and received frames to and from USB.
170:                 *
171:                 *			
172:                 * Note:		 	None.
173:                 ********************************************************************/	
174:                 void UsbTasks(void)
175:                 {
9D004B5C  27BDFFD8   ADDIU SP, SP, -40
9D004B60  AFBF0024   SW RA, 36(SP)
9D004B64  AFBE0020   SW S8, 32(SP)
9D004B68  03A0F021   ADDU S8, SP, ZERO
176:                 	UINT TxLen;
177:                 	UINT8 *TxPtr;
178:                 	volatile test;
179:                 	
180:                 	
181:                 	 #if defined(USB_POLLING)		
182:                 	//This function must be called everytime. This is a stack function.
183:                 	USBDeviceTasks();
9D004B6C  0F4000C3   JAL USBDeviceTasks
9D004B70  00000000   NOP
184:                 	 #endif
185:                 
186:                     if(USBGetDeviceState() == CONFIGURED_STATE)
9D004B74  8F838038   LW V1, -32712(GP)
9D004B78  24020020   ADDIU V0, ZERO, 32
9D004B7C  14620045   BNE V1, V0, 0x9D004C94
9D004B80  00000000   NOP
187:                 	{
188:                     	// Check if bootloader has something to send out to PC. 
189:                     	TxLen = FRAMEWORK_GetTransmitFrame(UsbTxData);
9D004B84  3C02A000   LUI V0, -24576
9D004B88  24440B50   ADDIU A0, V0, 2896
9D004B8C  0F400E5C   JAL GetTransmitFrame
9D004B90  00000000   NOP
9D004B94  AFC20010   SW V0, 16(S8)
190:                     
191:                     	// Initialize the transmit pointer.
192:                     	TxPtr = &UsbTxData[0];
9D004B98  3C02A000   LUI V0, -24576
9D004B9C  24420B50   ADDIU V0, V0, 2896
9D004BA0  AFC20014   SW V0, 20(S8)
193:                     	
194:                     	while(TxLen)	
9D004BA4  0B40130A   J 0x9D004C28
9D004BA8  00000000   NOP
9D004C28  8FC20010   LW V0, 16(S8)
9D004C2C  1440FFDF   BNE V0, ZERO, 0x9D004BAC
9D004C30  00000000   NOP
195:                     	{
196:                     	
197:                     		while(UsbTxBusy()); // Wait for USB transmit completion.	
9D004BAC  00000000   NOP
9D004BB0  8F828028   LW V0, -32728(GP)
9D004BB4  10400009   BEQ V0, ZERO, 0x9D004BDC
9D004BB8  00000000   NOP
9D004BBC  8F828028   LW V0, -32728(GP)
9D004BC0  90420000   LBU V0, 0(V0)
9D004BC4  304300FF   ANDI V1, V0, 255
9D004BC8  2402FF80   ADDIU V0, ZERO, -128
9D004BCC  00621024   AND V0, V1, V0
9D004BD0  304200FF   ANDI V0, V0, 255
9D004BD4  1440FFF6   BNE V0, ZERO, 0x9D004BB0
9D004BD8  00000000   NOP
198:                     		
199:                     		// Send the packet (USB endpoint size is always 64 bytes)
200:                     		USBTxOnePacket(HID_EP, TxPtr, MaxUsbPacketSize);	
9D004BDC  24040001   ADDIU A0, ZERO, 1
9D004BE0  24050001   ADDIU A1, ZERO, 1
9D004BE4  8FC60014   LW A2, 20(S8)
9D004BE8  24070040   ADDIU A3, ZERO, 64
9D004BEC  0F40020F   JAL USBTransferOnePacket
9D004BF0  00000000   NOP
201:                     		
202:                     		if(TxLen > MaxUsbPacketSize)
9D004BF4  8FC20010   LW V0, 16(S8)
9D004BF8  2C420041   SLTIU V0, V0, 65
9D004BFC  14400009   BNE V0, ZERO, 0x9D004C24
9D004C00  00000000   NOP
203:                     		{
204:                     			// Send pending bytes in next loop.
205:                     			TxLen -= MaxUsbPacketSize;
9D004C04  8FC20010   LW V0, 16(S8)
9D004C08  2442FFC0   ADDIU V0, V0, -64
9D004C0C  AFC20010   SW V0, 16(S8)
206:                     			// Point to next 64bytes.
207:                     			TxPtr += MaxUsbPacketSize;
9D004C10  8FC20014   LW V0, 20(S8)
9D004C14  24420040   ADDIU V0, V0, 64
9D004C18  AFC20014   SW V0, 20(S8)
9D004C1C  0B40130A   J 0x9D004C28
9D004C20  00000000   NOP
208:                     			// Probably a wait is needed here, otherwise PC app may miss frames.
209:                     			//Wait();			
210:                     		}	
211:                     		else
212:                     		{
213:                     			// No more bytes.
214:                     			TxLen = 0;
9D004C24  AFC00010   SW ZERO, 16(S8)
215:                     		}			
216:                     	}
217:                     	
218:                     	// Following part of the code checks if there is any data from USB.
219:                     	// If there are any data available, it just pushes the data to the frame work. 
220:                     	// Framework decodes the packet and takes necessary action like erasing/ programming etc.	
221:                     		
222:                     	if(UsbRxDataAvlbl())// Check if we have got any data from USB.	 		
9D004C34  8F828024   LW V0, -32732(GP)
9D004C38  10400009   BEQ V0, ZERO, 0x9D004C60
9D004C3C  00000000   NOP
9D004C40  8F828024   LW V0, -32732(GP)
9D004C44  90420000   LBU V0, 0(V0)
9D004C48  304300FF   ANDI V1, V0, 255
9D004C4C  2402FF80   ADDIU V0, ZERO, -128
9D004C50  00621024   AND V0, V1, V0
9D004C54  304200FF   ANDI V0, V0, 255
9D004C58  1440000E   BNE V0, ZERO, 0x9D004C94
9D004C5C  00000000   NOP
223:                         {
224:                     	    // Yes, we got a packet from HID End point.	    
225:                     	    // Pass the buffer to frame work. Framework decodes the packet and executes the Bootloder specific commands (Erasing/Programming etc).
226:                     		FRAMEWORK_BuildRxFrame(UsbRxData, MaxUsbPacketSize);
9D004C60  3C02A000   LUI V0, -24576
9D004C64  24440B10   ADDIU A0, V0, 2832
9D004C68  24050040   ADDIU A1, ZERO, 64
9D004C6C  0F400DB5   JAL BuildRxFrame
9D004C70  00000000   NOP
227:                     	    	    
228:                     	    // Re-arm the HID endpoint to receive next packet.(Remember! We have armed the HID endpoint for the first time in function USBCBInitEP())
229:                     	    USBOutHandle = HIDRxPacket(HID_EP,(BYTE*)UsbRxData,MaxUsbPacketSize);	    	    		
9D004C74  24040001   ADDIU A0, ZERO, 1
9D004C78  00002821   ADDU A1, ZERO, ZERO
9D004C7C  3C02A000   LUI V0, -24576
9D004C80  24460B10   ADDIU A2, V0, 2832
9D004C84  24070040   ADDIU A3, ZERO, 64
9D004C88  0F40020F   JAL USBTransferOnePacket
9D004C8C  00000000   NOP
9D004C90  AF828024   SW V0, -32732(GP)
230:                     	}
231:                     
232:                     }// if device configured.   
233:                        	
234:                 	
235:                 }	
9D004C94  03C0E821   ADDU SP, S8, ZERO
9D004C98  8FBF0024   LW RA, 36(SP)
9D004C9C  8FBE0020   LW S8, 32(SP)
9D004CA0  27BD0028   ADDIU SP, SP, 40
9D004CA4  03E00008   JR RA
9D004CA8  00000000   NOP
236:                 
237:                 
238:                 
239:                 
240:                 
241:                 // ******************************************************************************************************
242:                 // ************** USB Callback Functions ****************************************************************
243:                 // ******************************************************************************************************
244:                 // The USB firmware stack will call the callback functions USBCBxxx() in response to certain USB related
245:                 // events.  For example, if the host PC is powering down, it will stop sending out Start of Frame (SOF)
246:                 // packets to your device.  In response to this, all USB devices are supposed to decrease their power
247:                 // consumption from the USB Vbus to <2.5mA each.  The USB module detects this condition (which according
248:                 // to the USB specifications is 3+ms of no bus activity/SOF packets) and then calls the USBCBSuspend()
249:                 // function.  You should modify these callback functions to take appropriate actions for each of these
250:                 // conditions.  For example, in the USBCBSuspend(), you may wish to add code that will decrease power
251:                 // consumption from Vbus to <2.5mA (such as by clock switching, turning off LEDs, putting the
252:                 // microcontroller to sleep, etc.).  Then, in the USBCBWakeFromSuspend() function, you may then wish to
253:                 // add code that undoes the power saving things done in the USBCBSuspend() function.
254:                 
255:                 // The USBCBSendResume() function is special, in that the USB stack will not automatically call this
256:                 // function.  This function is meant to be called from the application firmware instead.  See the
257:                 // additional comments near the function.
258:                 
259:                 
260:                 /*******************************************************************
261:                  * Function:        void USBCBInitEP(void)
262:                  *
263:                  * PreCondition:    None
264:                  *
265:                  * Input:           None
266:                  *
267:                  * Output:          None
268:                  *
269:                  * Side Effects:    None
270:                  *
271:                  * Overview:        This function is called when the device becomes
272:                  *                  initialized, which occurs after the host sends a
273:                  * 					SET_CONFIGURATION (wValue not = 0) request.  This 
274:                  *					callback function should initialize the endpoints 
275:                  *					for the device's usage according to the current 
276:                  *					configuration.
277:                  *
278:                  * Note:            None
279:                  *******************************************************************/
280:                 void USBCBInitEP(void)
281:                 {
9D004CAC  27BDFFE8   ADDIU SP, SP, -24
9D004CB0  AFBF0014   SW RA, 20(SP)
9D004CB4  AFBE0010   SW S8, 16(SP)
9D004CB8  03A0F021   ADDU S8, SP, ZERO
282:                     //enable the HID endpoint
283:                     USBEnableEndpoint(HID_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
9D004CBC  24040001   ADDIU A0, ZERO, 1
9D004CC0  2405001D   ADDIU A1, ZERO, 29
9D004CC4  0F4001E6   JAL USBEnableEndpoint
9D004CC8  00000000   NOP
284:                     //Arm the OUT endpoint for the packet we will be receiving.
285:                     USBOutHandle = HIDRxPacket(HID_EP,(BYTE*)UsbRxData,MaxUsbPacketSize);
9D004CCC  24040001   ADDIU A0, ZERO, 1
9D004CD0  00002821   ADDU A1, ZERO, ZERO
9D004CD4  3C02A000   LUI V0, -24576
9D004CD8  24460B10   ADDIU A2, V0, 2832
9D004CDC  24070040   ADDIU A3, ZERO, 64
9D004CE0  0F40020F   JAL USBTransferOnePacket
9D004CE4  00000000   NOP
9D004CE8  AF828024   SW V0, -32732(GP)
286:                 }
9D004CEC  03C0E821   ADDU SP, S8, ZERO
9D004CF0  8FBF0014   LW RA, 20(SP)
9D004CF4  8FBE0010   LW S8, 16(SP)
9D004CF8  27BD0018   ADDIU SP, SP, 24
9D004CFC  03E00008   JR RA
9D004D00  00000000   NOP
287:                 
288:                 
289:                 /******************************************************************************
290:                  * Function:        void USBCBSuspend(void)
291:                  *
292:                  * PreCondition:    None
293:                  *
294:                  * Input:           None
295:                  *
296:                  * Output:          None
297:                  *
298:                  * Side Effects:    None
299:                  *
300:                  * Overview:        Call back that is invoked when a USB suspend is detected
301:                  *
302:                  * Note:            None
303:                  *****************************************************************************/
304:                 void USBCBSuspend(void)
305:                 {
9D004D04  27BDFFF8   ADDIU SP, SP, -8
9D004D08  AFBE0004   SW S8, 4(SP)
9D004D0C  03A0F021   ADDU S8, SP, ZERO
306:                 	//Example power saving code.  Insert appropriate code here for the desired
307:                 	//application behavior.  If the microcontroller will be put to sleep, a
308:                 	//process similar to that shown below may be used:
309:                 	
310:                 	//ConfigureIOPinsForLowPower();
311:                 	//SaveStateOfAllInterruptEnableBits();
312:                 	//DisableAllInterruptEnableBits();
313:                 	//EnableOnlyTheInterruptsWhichWillBeUsedToWakeTheMicro();	//should enable at least USBActivityIF as a wake source
314:                 	//Sleep();
315:                 	//RestoreStateOfAllPreviouslySavedInterruptEnableBits();	//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
316:                 	//RestoreIOPinsToNormal();									//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
317:                 
318:                 	//IMPORTANT NOTE: Do not clear the USBActivityIF (ACTVIF) bit here.  This bit is 
319:                 	//cleared inside the usb_device.c file.  Clearing USBActivityIF here will cause 
320:                 	//things to not work as intended.	    
321:                 }
9D004D10  03C0E821   ADDU SP, S8, ZERO
9D004D14  8FBE0004   LW S8, 4(SP)
9D004D18  27BD0008   ADDIU SP, SP, 8
9D004D1C  03E00008   JR RA
9D004D20  00000000   NOP
322:                 
323:                 
324:                 /********************************************************************
325:                  * Function:        void USBCB_SOF_Handler(void)
326:                  *
327:                  * PreCondition:    None
328:                  *
329:                  * Input:           None
330:                  *
331:                  * Output:          None
332:                  *
333:                  * Side Effects:    None
334:                  *
335:                  * Overview:        The USB host sends out a SOF packet to full-speed
336:                  *                  devices every 1 ms. This interrupt may be useful
337:                  *                  for isochronous pipes. End designers should
338:                  *                  implement callback routine as necessary.
339:                  *
340:                  * Note:            None
341:                  *******************************************************************/
342:                 void USBCB_SOF_Handler(void)
343:                 {
9D004D24  27BDFFF8   ADDIU SP, SP, -8
9D004D28  AFBE0004   SW S8, 4(SP)
9D004D2C  03A0F021   ADDU S8, SP, ZERO
344:                     // No need to clear UIRbits.SOFIF to 0 here.
345:                     // Callback caller is already doing that.
346:                 }
9D004D30  03C0E821   ADDU SP, S8, ZERO
9D004D34  8FBE0004   LW S8, 4(SP)
9D004D38  27BD0008   ADDIU SP, SP, 8
9D004D3C  03E00008   JR RA
9D004D40  00000000   NOP
347:                 
348:                 
349:                 /******************************************************************************
350:                  * Function:        void USBCBWakeFromSuspend(void)
351:                  *
352:                  * PreCondition:    None
353:                  *
354:                  * Input:           None
355:                  *
356:                  * Output:          None
357:                  *
358:                  * Side Effects:    None
359:                  *
360:                  * Overview:        The host may put USB peripheral devices in low power
361:                  *					suspend mode (by "sending" 3+ms of idle).  Once in suspend
362:                  *					mode, the host may wake the device back up by sending non-
363:                  *					idle state signalling.
364:                  *					
365:                  *					This call back is invoked when a wakeup from USB suspend 
366:                  *					is detected.
367:                  *
368:                  * Note:            None
369:                  *****************************************************************************/
370:                 void USBCBWakeFromSuspend(void)
371:                 {
9D004D44  27BDFFF8   ADDIU SP, SP, -8
9D004D48  AFBE0004   SW S8, 4(SP)
9D004D4C  03A0F021   ADDU S8, SP, ZERO
372:                 	// If clock switching or other power savings measures were taken when
373:                 	// executing the USBCBSuspend() function, now would be a good time to
374:                 	// switch back to normal full power run mode conditions.  The host allows
375:                 	// a few milliseconds of wakeup time, after which the device must be 
376:                 	// fully back to normal, and capable of receiving and processing USB
377:                 	// packets.  In order to do this, the USB module must receive proper
378:                 	// clocking (IE: 48MHz clock must be available to SIE for full speed USB
379:                 	// operation).
380:                 }
9D004D50  03C0E821   ADDU SP, S8, ZERO
9D004D54  8FBE0004   LW S8, 4(SP)
9D004D58  27BD0008   ADDIU SP, SP, 8
9D004D5C  03E00008   JR RA
9D004D60  00000000   NOP
381:                 
382:                 
383:                 /*******************************************************************
384:                  * Function:        void USBCBStdSetDscHandler(void)
385:                  *
386:                  * PreCondition:    None
387:                  *
388:                  * Input:           None
389:                  *
390:                  * Output:          None
391:                  *
392:                  * Side Effects:    None
393:                  *
394:                  * Overview:        The USBCBStdSetDscHandler() callback function is
395:                  *					called when a SETUP, bRequest: SET_DESCRIPTOR request
396:                  *					arrives.  Typically SET_DESCRIPTOR requests are
397:                  *					not used in most applications, and it is
398:                  *					optional to support this type of request.
399:                  *
400:                  * Note:            None
401:                  *******************************************************************/
402:                 void USBCBStdSetDscHandler(void)
403:                 {
9D004D64  27BDFFF8   ADDIU SP, SP, -8
9D004D68  AFBE0004   SW S8, 4(SP)
9D004D6C  03A0F021   ADDU S8, SP, ZERO
404:                     // Must claim session ownership if supporting this request
405:                 }//end
9D004D70  03C0E821   ADDU SP, S8, ZERO
9D004D74  8FBE0004   LW S8, 4(SP)
9D004D78  27BD0008   ADDIU SP, SP, 8
9D004D7C  03E00008   JR RA
9D004D80  00000000   NOP
406:                 
407:                 
408:                 /*******************************************************************
409:                  * Function:        void USBCBCheckOtherReq(void)
410:                  *
411:                  * PreCondition:    None
412:                  *
413:                  * Input:           None
414:                  *
415:                  * Output:          None
416:                  *
417:                  * Side Effects:    None
418:                  *
419:                  * Overview:        When SETUP packets arrive from the host, some
420:                  * 					firmware must process the request and respond
421:                  *					appropriately to fulfill the request.  Some of
422:                  *					the SETUP packets will be for standard
423:                  *					USB "chapter 9" (as in, fulfilling chapter 9 of
424:                  *					the official USB specifications) requests, while
425:                  *					others may be specific to the USB device class
426:                  *					that is being implemented.  For example, a HID
427:                  *					class device needs to be able to respond to
428:                  *					"GET REPORT" type of requests.  This
429:                  *					is not a standard USB chapter 9 request, and 
430:                  *					therefore not handled by usb_device.c.  Instead
431:                  *					this request should be handled by class specific 
432:                  *					firmware, such as that contained in usb_function_hid.c.
433:                  *
434:                  * Note:            None
435:                  *******************************************************************/
436:                 void USBCBCheckOtherReq(void)
437:                 {
9D004D84  27BDFFE8   ADDIU SP, SP, -24
9D004D88  AFBF0014   SW RA, 20(SP)
9D004D8C  AFBE0010   SW S8, 16(SP)
9D004D90  03A0F021   ADDU S8, SP, ZERO
438:                     USBCheckHIDRequest();
9D004D94  0F4014A2   JAL USBCheckHIDRequest
9D004D98  00000000   NOP
439:                 }//end
9D004D9C  03C0E821   ADDU SP, S8, ZERO
9D004DA0  8FBF0014   LW RA, 20(SP)
9D004DA4  8FBE0010   LW S8, 16(SP)
9D004DA8  27BD0018   ADDIU SP, SP, 24
9D004DAC  03E00008   JR RA
9D004DB0  00000000   NOP
440:                 
441:                 
442:                 /*******************************************************************
443:                  * Function:        void USBCBErrorHandler(void)
444:                  *
445:                  * PreCondition:    None
446:                  *
447:                  * Input:           None
448:                  *
449:                  * Output:          None
450:                  *
451:                  * Side Effects:    None
452:                  *
453:                  * Overview:        The purpose of this callback is mainly for
454:                  *                  debugging during development. Check UEIR to see
455:                  *                  which error causes the interrupt.
456:                  *
457:                  * Note:            None
458:                  *******************************************************************/
459:                 void USBCBErrorHandler(void)
460:                 {
9D004DB4  27BDFFF8   ADDIU SP, SP, -8
9D004DB8  AFBE0004   SW S8, 4(SP)
9D004DBC  03A0F021   ADDU S8, SP, ZERO
461:                     // No need to clear UEIR to 0 here.
462:                     // Callback caller is already doing that.
463:                 
464:                 	// Typically, user firmware does not need to do anything special
465:                 	// if a USB error occurs.  For example, if the host sends an OUT
466:                 	// packet to your device, but the packet gets corrupted (ex:
467:                 	// because of a bad connection, or the user unplugs the
468:                 	// USB cable during the transmission) this will typically set
469:                 	// one or more USB error interrupt flags.  Nothing specific
470:                 	// needs to be done however, since the SIE will automatically
471:                 	// send a "NAK" packet to the host.  In response to this, the
472:                 	// host will normally retry to send the packet again, and no
473:                 	// data loss occurs.  The system will typically recover
474:                 	// automatically, without the need for application firmware
475:                 	// intervention.
476:                 	
477:                 	// Nevertheless, this callback function is provided, such as
478:                 	// for debugging purposes.
479:                 }
9D004DC0  03C0E821   ADDU SP, S8, ZERO
9D004DC4  8FBE0004   LW S8, 4(SP)
9D004DC8  27BD0008   ADDIU SP, SP, 8
9D004DCC  03E00008   JR RA
9D004DD0  00000000   NOP
480:                 
481:                 
482:                 
483:                 /*******************************************************************
484:                  * Function:        BOOL USER_USB_CALLBACK_EVENT_HANDLER(
485:                  *                        USB_EVENT event, void *pdata, WORD size)
486:                  *
487:                  * PreCondition:    None
488:                  *
489:                  * Input:           USB_EVENT event - the type of event
490:                  *                  void *pdata - pointer to the event data
491:                  *                  WORD size - size of the event data
492:                  *
493:                  * Output:          None
494:                  *
495:                  * Side Effects:    None
496:                  *
497:                  * Overview:        This function is called from the USB stack to
498:                  *                  notify a user application that a USB event
499:                  *                  occured.  This callback is in interrupt context
500:                  *                  when the USB_INTERRUPT option is selected.
501:                  *
502:                  * Note:            None
503:                  *******************************************************************/
504:                 BOOL USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, WORD size)
505:                 {
9D004DD4  27BDFFE8   ADDIU SP, SP, -24
9D004DD8  AFBF0014   SW RA, 20(SP)
9D004DDC  AFBE0010   SW S8, 16(SP)
9D004DE0  03A0F021   ADDU S8, SP, ZERO
9D004DE4  AFC40018   SW A0, 24(S8)
9D004DE8  AFC5001C   SW A1, 28(S8)
9D004DEC  00C01021   ADDU V0, A2, ZERO
9D004DF0  A7C20020   SH V0, 32(S8)
506:                     switch(event)
9D004DF4  8FC20018   LW V0, 24(S8)
9D004DF8  24030072   ADDIU V1, ZERO, 114
9D004DFC  1043003F   BEQ V0, V1, 0x9D004EFC
9D004E00  00000000   NOP
9D004E04  2C430073   SLTIU V1, V0, 115
9D004E08  10600011   BEQ V1, ZERO, 0x9D004E50
9D004E0C  00000000   NOP
9D004E10  24030002   ADDIU V1, ZERO, 2
9D004E14  1043002D   BEQ V0, V1, 0x9D004ECC
9D004E18  00000000   NOP
9D004E1C  2C430003   SLTIU V1, V0, 3
9D004E20  10600006   BEQ V1, ZERO, 0x9D004E3C
9D004E24  00000000   NOP
9D004E28  24030001   ADDIU V1, ZERO, 1
9D004E2C  10430023   BEQ V0, V1, 0x9D004EBC
9D004E30  00000000   NOP
9D004E3C  24030003   ADDIU V1, ZERO, 3
9D004E40  10430026   BEQ V0, V1, 0x9D004EDC
9D004E44  00000000   NOP
9D004E50  24030074   ADDIU V1, ZERO, 116
9D004E54  10430015   BEQ V0, V1, 0x9D004EAC
9D004E58  00000000   NOP
9D004E5C  2C430074   SLTIU V1, V0, 116
9D004E60  1460000A   BNE V1, ZERO, 0x9D004E8C
9D004E64  00000000   NOP
9D004E68  24030075   ADDIU V1, ZERO, 117
9D004E6C  1043000B   BEQ V0, V1, 0x9D004E9C
9D004E70  00000000   NOP
9D004E74  3C037FFF   LUI V1, 32767
9D004E78  3463FFFF   ORI V1, V1, -1
9D004E7C  1043001B   BEQ V0, V1, 0x9D004EEC
9D004E80  00000000   NOP
507:                     {
508:                         case EVENT_TRANSFER:
509:                             //Add application specific callback task or callback function here if desired.
510:                             break;
9D004EFC  00000000   NOP
511:                         case EVENT_SOF:
512:                             USBCB_SOF_Handler();
9D004E8C  0F401349   JAL USBCB_SOF_Handler
9D004E90  00000000   NOP
513:                             break;
9D004E94  0B4013C0   J 0x9D004F00
9D004E98  00000000   NOP
514:                         case EVENT_SUSPEND:
515:                             USBCBSuspend();
9D004E9C  0F401341   JAL USBCBSuspend
9D004EA0  00000000   NOP
516:                             break;
9D004EA4  0B4013C0   J 0x9D004F00
9D004EA8  00000000   NOP
517:                         case EVENT_RESUME:
518:                             USBCBWakeFromSuspend();
9D004EAC  0F401351   JAL USBCBWakeFromSuspend
9D004EB0  00000000   NOP
519:                             break;
9D004EB4  0B4013C0   J 0x9D004F00
9D004EB8  00000000   NOP
520:                         case EVENT_CONFIGURED: 
521:                             USBCBInitEP();
9D004EBC  0F40132B   JAL USBCBInitEP
9D004EC0  00000000   NOP
522:                             break;
9D004EC4  0B4013C0   J 0x9D004F00
9D004EC8  00000000   NOP
523:                         case EVENT_SET_DESCRIPTOR:
524:                             USBCBStdSetDscHandler();
9D004ECC  0F401359   JAL USBCBStdSetDscHandler
9D004ED0  00000000   NOP
525:                             break;
9D004ED4  0B4013C0   J 0x9D004F00
9D004ED8  00000000   NOP
526:                         case EVENT_EP0_REQUEST:
527:                             USBCBCheckOtherReq();
9D004EDC  0F401361   JAL USBCBCheckOtherReq
9D004EE0  00000000   NOP
528:                             break;
9D004EE4  0B4013C0   J 0x9D004F00
9D004EE8  00000000   NOP
529:                         case EVENT_BUS_ERROR:
530:                             USBCBErrorHandler();
9D004EEC  0F40136D   JAL USBCBErrorHandler
9D004EF0  00000000   NOP
531:                             break;
9D004EF4  0B4013C0   J 0x9D004F00
9D004EF8  00000000   NOP
532:                         case EVENT_TRANSFER_TERMINATED:
533:                             //Add application specific callback task or callback function here if desired.
534:                             //The EVENT_TRANSFER_TERMINATED event occurs when the host performs a CLEAR
535:                             //FEATURE (endpoint halt) request on an application endpoint which was 
536:                             //previously armed (UOWN was = 1).  Here would be a good place to:
537:                             //1.  Determine which endpoint the transaction that just got terminated was 
538:                             //      on, by checking the handle value in the *pdata.
539:                             //2.  Re-arm the endpoint if desired (typically would be the case for OUT 
540:                             //      endpoints).
541:                             break;
9D004E48  0B4013C0   J 0x9D004F00
9D004E4C  00000000   NOP
542:                         default:
543:                             break;
9D004E34  0B4013C0   J 0x9D004F00
9D004E38  00000000   NOP
9D004E84  0B4013C0   J 0x9D004F00
9D004E88  00000000   NOP
544:                     }      
545:                     return TRUE; 
9D004F00  24020001   ADDIU V0, ZERO, 1
546:                 }
9D004F04  03C0E821   ADDU SP, S8, ZERO
9D004F08  8FBF0014   LW RA, 20(SP)
9D004F0C  8FBE0010   LW S8, 16(SP)
9D004F10  27BD0018   ADDIU SP, SP, 24
9D004F14  03E00008   JR RA
9D004F18  00000000   NOP
547:                 
---  /home/bekeband/MPLABXProjects/AN1388_Source_Code_2014_02_14/PIC32_Bootloaders/Firmware/Bootloader/Source/NVMem.c
1:                   /*********************************************************************
2:                    *
3:                    *                  PIC32 Boot Loader
4:                    *
5:                    *********************************************************************
6:                    * FileName:        NVMem.c
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   * Compiler:        MPLAB C32
11:                   *                  MPLAB IDE
12:                   * Company:         Microchip Technology, Inc.
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * The software supplied herewith by Microchip Technology Incorporated
17:                   * (the ï¿½Companyï¿½) for its PIC32 Microcontroller is intended
18:                   * and supplied to you, the Companyï¿½s customer, for use solely and
19:                   * exclusively on Microchip PIC32 Microcontroller products.
20:                   * The software is owned by the Company and/or its supplier, and is
21:                   * protected under applicable copyright laws. All rights are reserved.
22:                   * Any use in violation of the foregoing restrictions may subject the
23:                   * user to criminal sanctions under applicable laws, as well as to
24:                   * civil liability for the breach of the terms and conditions of this
25:                   * license.
26:                   *
27:                   * THIS SOFTWARE IS PROVIDED IN AN ï¿½AS ISï¿½ CONDITION. NO WARRANTIES,
28:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
29:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
30:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
31:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
32:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
33:                   *
34:                   *
35:                   * $Id:  $
36:                   * $Name: $
37:                   *
38:                   **********************************************************************/
39:                  #include "Include/HardwareProfile/HardwareProfile.h"
40:                  #include "Include/GenericTypeDefs.h"
41:                  #include "Include/BootLoader.h"
42:                  #include "Include/Framework/Framework.h"
43:                  #include "Include/NVMem.h"
44:                  #include <plib.h>
45:                  
46:                  
47:                  const UINT countPerMicroSec = ((SYS_FREQ/1000000)/2);
48:                  #define NVMemIsError()    (NVMCON & (_NVMCON_WRERR_MASK | _NVMCON_LVDERR_MASK))
49:                  
50:                  /********************************************************************
51:                  * Function: 	delay_us()
52:                  *
53:                  * Precondition: 
54:                  *
55:                  * Input: 		Micro second
56:                  *
57:                  * Output:		None.
58:                  *
59:                  * Side Effects:	Uses Core timer. This may affect other functions using core timers.
60:                  				For example, core timer interrupt may not work, or may loose precision.				
61:                  *
62:                  * Overview:     Provides Delay in microsecond.
63:                  *
64:                  *			
65:                  * Note:		 	None.
66:                  ********************************************************************/
67:                  void delay_us(UINT us)
68:                  {
9D004F1C  27BDFFD8   ADDIU SP, SP, -40
9D004F20  AFBF0024   SW RA, 36(SP)
9D004F24  AFBE0020   SW S8, 32(SP)
9D004F28  03A0F021   ADDU S8, SP, ZERO
9D004F2C  AFC40028   SW A0, 40(S8)
69:                     
70:                      UINT targetCount;  
71:                      UINT bakupCount; 
72:                      UINT8 loop = 0;
9D004F30  A3C00010   SB ZERO, 16(S8)
73:                      // Assert "us" not zero. This must be caught during debug phase.
74:                      ASSERT(us!=0);
9D004F34  8FC20028   LW V0, 40(S8)
9D004F38  1040FFFE   BEQ V0, ZERO, 0x9D004F34
9D004F3C  00000000   NOP
75:                      // backup current count of the core timer.
76:                      bakupCount = ReadCoreTimer();
9D004F40  0F401629   JAL ReadCoreTimer
9D004F44  00000000   NOP
9D004F48  AFC20014   SW V0, 20(S8)
77:                      // Core timer increments every 2 sys clock cycles.
78:                      // Calculate the counts required to complete "us". 
79:                      targetCount = countPerMicroSec * us;      
9D004F4C  3C029D00   LUI V0, -25344
9D004F50  8C4358BC   LW V1, 22716(V0)
9D004F54  8FC20028   LW V0, 40(S8)
9D004F58  70621002   MUL V0, V1, V0
9D004F5C  AFC20018   SW V0, 24(S8)
80:                      // Restart core timer.
81:                      WriteCoreTimer(0);    
9D004F60  00002021   ADDU A0, ZERO, ZERO
9D004F64  0F40162B   JAL WriteCoreTimer
9D004F68  00000000   NOP
82:                      // Wait till core timer completes the count.    
83:                      while(ReadCoreTimer() < targetCount);
9D004F6C  00000000   NOP
9D004F70  0F401629   JAL ReadCoreTimer
9D004F74  00000000   NOP
9D004F78  00401821   ADDU V1, V0, ZERO
9D004F7C  8FC20018   LW V0, 24(S8)
9D004F80  0062102B   SLTU V0, V1, V0
9D004F84  1440FFFA   BNE V0, ZERO, 0x9D004F70
9D004F88  00000000   NOP
84:                      
85:                      // Restore count back.
86:                      WriteCoreTimer(bakupCount + targetCount);       	
9D004F8C  8FC30014   LW V1, 20(S8)
9D004F90  8FC20018   LW V0, 24(S8)
9D004F94  00621021   ADDU V0, V1, V0
9D004F98  00402021   ADDU A0, V0, ZERO
9D004F9C  0F40162B   JAL WriteCoreTimer
9D004FA0  00000000   NOP
87:                     
88:                  }  
9D004FA4  03C0E821   ADDU SP, S8, ZERO
9D004FA8  8FBF0024   LW RA, 36(SP)
9D004FAC  8FBE0020   LW S8, 32(SP)
9D004FB0  27BD0028   ADDIU SP, SP, 40
9D004FB4  03E00008   JR RA
9D004FB8  00000000   NOP
89:                  
90:                  
91:                  
92:                  /********************************************************************
93:                  * Function: 	NVMemOperation()
94:                  *
95:                  * Precondition: 
96:                  *
97:                  * Input: 		NV operation
98:                  *
99:                  * Output:		NV eror
100:                 *
101:                 * Side Effects:	This function must generate MIPS32 code only and 
102:                 				hence the attribute (nomips16)
103:                 *
104:                 * Overview:     Performs reuested operation.
105:                 *
106:                 *			
107:                 * Note:		 	None.
108:                 ********************************************************************/
109:                 UINT __attribute__((nomips16)) NVMemOperation(UINT nvmop)
110:                 {
9D004FBC  27BDFFD0   ADDIU SP, SP, -48
9D004FC0  AFBF002C   SW RA, 44(SP)
9D004FC4  AFBE0028   SW S8, 40(SP)
9D004FC8  03A0F021   ADDU S8, SP, ZERO
9D004FCC  AFC40030   SW A0, 48(S8)
111:                     int	int_status;
112:                     int	susp;
113:                 
114:                     // Disable DMA & Disable Interrupts
115:                 	#ifdef _DMAC
116:                 	int_status = INTDisableInterrupts();
9D004FD0  0F40162D   JAL INTDisableInterrupts
9D004FD4  00000000   NOP
9D004FD8  AFC20010   SW V0, 16(S8)
117:                 	susp = DmaSuspend();
9D005020  AFC20014   SW V0, 20(S8)
118:                 	#else
119:                 	int_status = INTDisableInterrupts(); 
120:                 	#endif	// _DMAC
121:                 
122:                     // Enable Flash Write/Erase Operations
123:                     NVMCON = NVMCON_WREN | nvmop;
9D005024  8FC20030   LW V0, 48(S8)
9D005028  34434000   ORI V1, V0, 16384
9D00502C  3C02BF81   LUI V0, -16511
9D005030  AC43F400   SW V1, -3072(V0)
124:                     // Data sheet prescribes 6us delay for LVD to become stable.
125:                     // To be on the safer side, we shall set 7us delay.
126:                     delay_us(7);
9D005034  24040007   ADDIU A0, ZERO, 7
9D005038  0F4013C7   JAL delay_us
9D00503C  00000000   NOP
127:                 
128:                     NVMKEY 		= 0xAA996655;
9D005040  3C02BF81   LUI V0, -16511
9D005044  3C03AA99   LUI V1, -21863
9D005048  34636655   ORI V1, V1, 26197
9D00504C  AC43F410   SW V1, -3056(V0)
129:                     NVMKEY 		= 0x556699AA;
9D005050  3C02BF81   LUI V0, -16511
9D005054  3C035566   LUI V1, 21862
9D005058  346399AA   ORI V1, V1, -26198
9D00505C  AC43F410   SW V1, -3056(V0)
130:                     NVMCONSET 	= NVMCON_WR;
9D005060  3C02BF81   LUI V0, -16511
9D005064  34038000   ORI V1, ZERO, -32768
9D005068  AC43F408   SW V1, -3064(V0)
131:                 
132:                     // Wait for WR bit to clear
133:                     while(NVMCON & NVMCON_WR);
9D00506C  00000000   NOP
9D005070  3C02BF81   LUI V0, -16511
9D005074  8C42F400   LW V0, -3072(V0)
9D005078  30428000   ANDI V0, V0, -32768
9D00507C  1440FFFC   BNE V0, ZERO, 0x9D005070
9D005080  00000000   NOP
134:                     
135:                     // Disable Flash Write/Erase operations
136:                     NVMCONCLR = NVMCON_WREN;  
9D005084  3C02BF81   LUI V0, -16511
9D005088  24034000   ADDIU V1, ZERO, 16384
9D00508C  AC43F404   SW V1, -3068(V0)
9D005090  8FC20014   LW V0, 20(S8)
9D005094  AFC2001C   SW V0, 28(S8)
137:                 
138:                 
139:                 	// Enable DMA & Enable Interrupts
140:                 	#ifdef _DMAC
141:                 	DmaResume(susp);
142:                 	INTRestoreInterrupts(int_status);
9D005104  8FC20010   LW V0, 16(S8)
9D005108  00402021   ADDU A0, V0, ZERO
9D00510C  0F4015F9   JAL INTRestoreInterrupts
9D005110  00000000   NOP
143:                 	#else
144:                 	INTRestoreInterrupts(int_status);
145:                 	#endif // _DMAC
146:                 
147:                 	// Return Error Status
148:                     return(NVMemIsError());
9D005114  3C02BF81   LUI V0, -16511
9D005118  8C42F400   LW V0, -3072(V0)
9D00511C  30423000   ANDI V0, V0, 12288
149:                 }
9D005120  03C0E821   ADDU SP, S8, ZERO
9D005124  8FBF002C   LW RA, 44(SP)
9D005128  8FBE0028   LW S8, 40(SP)
9D00512C  27BD0030   ADDIU SP, SP, 48
9D005130  03E00008   JR RA
9D005134  00000000   NOP
150:                 
151:                 
152:                 /*********************************************************************
153:                  * Function:        unsigned int NVMErasePage(void* address)
154:                  *
155:                  * Description:     A page erase will erase a single page of program flash,
156:                  *                  which equates to 1k instructions (4KBytes). The page to
157:                  *                  be erased is selected using NVMADDR. The lower bytes of
158:                  *                  the address given by NVMADDR are ignored in page selection.
159:                  *
160:                  * PreCondition:    None
161:                  *
162:                  * Inputs:          address:  Destination page address to Erase.
163:                  *
164:                  * Output:          '0' if operation completed successfully.
165:                  *
166:                  * Example:         NVMemErasePage((void*) 0xBD000000)
167:                  ********************************************************************/
168:                 UINT NVMemErasePage(void* address)
169:                 {
9D005138  27BDFFE0   ADDIU SP, SP, -32
9D00513C  AFBF001C   SW RA, 28(SP)
9D005140  AFBE0018   SW S8, 24(SP)
9D005144  03A0F021   ADDU S8, SP, ZERO
9D005148  AFC40020   SW A0, 32(S8)
170:                     UINT res;
171:                 
172:                     // Convert Address to Physical Address
173:                 	NVMADDR = KVA_TO_PA((unsigned int)address);
9D00514C  8FC20020   LW V0, 32(S8)
9D005150  7C43E000   EXT V1, V0, 0, 29
9D005154  3C02BF81   LUI V0, -16511
9D005158  AC43F420   SW V1, -3040(V0)
174:                 
175:                 	// Unlock and Erase Page
176:                 	res = NVMemOperation(NVMOP_PAGE_ERASE);
9D00515C  24044004   ADDIU A0, ZERO, 16388
9D005160  0F4013EF   JAL NVMemOperation
9D005164  00000000   NOP
9D005168  AFC20010   SW V0, 16(S8)
177:                 
178:                 	// Return WRERR state.
179:                 	return res;
9D00516C  8FC20010   LW V0, 16(S8)
180:                 
181:                 }
9D005170  03C0E821   ADDU SP, S8, ZERO
9D005174  8FBF001C   LW RA, 28(SP)
9D005178  8FBE0018   LW S8, 24(SP)
9D00517C  27BD0020   ADDIU SP, SP, 32
9D005180  03E00008   JR RA
9D005184  00000000   NOP
182:                 
183:                 
184:                 /*********************************************************************
185:                  * Function:        unsigned int NVMWriteWord(void* address, unsigned int data)
186:                  *
187:                  * Description:     The smallest block of data that can be programmed in
188:                  *                  a single operation is 1 instruction word (4 Bytes).  The word at
189:                  *                  the location pointed to by NVMADDR is programmed.
190:                  *
191:                  * PreCondition:    None
192:                  *
193:                  * Inputs:          address:   Destination address to write.
194:                  *                  data:      Word to write.
195:                  *
196:                  * Output:          '0' if operation completed successfully.
197:                  *
198:                  * Example:         NVMWriteWord((void*) 0xBD000000, 0x12345678)
199:                  ********************************************************************/
200:                 UINT NVMemWriteWord(void* address, UINT data)
201:                 {
9D005188  27BDFFE0   ADDIU SP, SP, -32
9D00518C  AFBF001C   SW RA, 28(SP)
9D005190  AFBE0018   SW S8, 24(SP)
9D005194  03A0F021   ADDU S8, SP, ZERO
9D005198  AFC40020   SW A0, 32(S8)
9D00519C  AFC50024   SW A1, 36(S8)
202:                     UINT res;
203:                 
204:                     NVMADDR = KVA_TO_PA((unsigned int)address);
9D0051A0  8FC20020   LW V0, 32(S8)
9D0051A4  7C43E000   EXT V1, V0, 0, 29
9D0051A8  3C02BF81   LUI V0, -16511
9D0051AC  AC43F420   SW V1, -3040(V0)
205:                 
206:                     // Load data into NVMDATA register
207:                     NVMDATA = data;
9D0051B0  3C02BF81   LUI V0, -16511
9D0051B4  8FC30024   LW V1, 36(S8)
9D0051B8  AC43F430   SW V1, -3024(V0)
208:                 
209:                     // Unlock and Write Word
210:                     res = NVMemOperation(NVMOP_WORD_PGM);
9D0051BC  24044001   ADDIU A0, ZERO, 16385
9D0051C0  0F4013EF   JAL NVMemOperation
9D0051C4  00000000   NOP
9D0051C8  AFC20010   SW V0, 16(S8)
211:                 
212:                 	return res;
9D0051CC  8FC20010   LW V0, 16(S8)
213:                 }
9D0051D0  03C0E821   ADDU SP, S8, ZERO
9D0051D4  8FBF001C   LW RA, 28(SP)
9D0051D8  8FBE0018   LW S8, 24(SP)
9D0051DC  27BD0020   ADDIU SP, SP, 32
9D0051E0  03E00008   JR RA
9D0051E4  00000000   NOP
214:                 
215:                 
216:                 
217:                 
218:                 /*********************************************************************
219:                  * Function:        unsigned int NVMWriteRow(void* address, void* data)
220:                  *
221:                  * Description:     The largest block of data that can be programmed in
222:                  *                  a single operation is 1 row 128 instructions (512 Bytes).  The row at
223:                  *                  the location pointed to by NVMADDR is programmed with the data buffer
224:                  *                  pointed to by NVMSRCADDR.
225:                  *
226:                  * PreCondition:    The row of data must be pre-loaded into a buffer in RAM.
227:                  *
228:                  * Inputs:          address:  Destination Row address to write.
229:                  *                  data:  Location of data to write.
230:                  *
231:                  * Output:          '0' if operation completed successfully.
232:                  *
233:                  * Example:         NVMWriteRow((void*) 0xBD000000, (void*) 0xA0000000)
234:                  ********************************************************************/
235:                 UINT NVMemWriteRow(void* address, void* data)
236:                 {
9D0051E8  27BDFFE0   ADDIU SP, SP, -32
9D0051EC  AFBF001C   SW RA, 28(SP)
9D0051F0  AFBE0018   SW S8, 24(SP)
9D0051F4  03A0F021   ADDU S8, SP, ZERO
9D0051F8  AFC40020   SW A0, 32(S8)
9D0051FC  AFC50024   SW A1, 36(S8)
237:                     unsigned int res;
238:                 
239:                     // Set NVMADDR to Address of row t program
240:                     NVMADDR = KVA_TO_PA((unsigned int)address);
9D005200  8FC20020   LW V0, 32(S8)
9D005204  7C43E000   EXT V1, V0, 0, 29
9D005208  3C02BF81   LUI V0, -16511
9D00520C  AC43F420   SW V1, -3040(V0)
241:                 
242:                     // Set NVMSRCADDR to the SRAM data buffer Address
243:                     NVMSRCADDR = KVA_TO_PA((unsigned int)data);
9D005210  8FC20024   LW V0, 36(S8)
9D005214  7C43E000   EXT V1, V0, 0, 29
9D005218  3C02BF81   LUI V0, -16511
9D00521C  AC43F440   SW V1, -3008(V0)
244:                 
245:                     // Unlock and Write Row
246:                     res = NVMemOperation(NVMOP_ROW_PGM);
9D005220  24044003   ADDIU A0, ZERO, 16387
9D005224  0F4013EF   JAL NVMemOperation
9D005228  00000000   NOP
9D00522C  AFC20010   SW V0, 16(S8)
247:                 
248:                     return res;
9D005230  8FC20010   LW V0, 16(S8)
249:                 }
9D005234  03C0E821   ADDU SP, S8, ZERO
9D005238  8FBF001C   LW RA, 28(SP)
9D00523C  8FBE0018   LW S8, 24(SP)
9D005240  27BD0020   ADDIU SP, SP, 32
9D005244  03E00008   JR RA
9D005248  00000000   NOP
250:                 
251:                 
252:                 
253:                 /*********************************************************************
254:                  * Function:        unsigned int NVMClearError(void)
255:                  *
256:                  * Description:		Clears the NVMCON error flag.
257:                  *
258:                  * PreCondition:    None
259:                  *
260:                  * Inputs:			None
261:                  *
262:                  * Output:          '0' if operation completed successfully.
263:                  *
264:                  * Example:			NMVClearError()
265:                  ********************************************************************/
266:                 UINT NVMemClearError(void)
267:                 {
9D00524C  27BDFFE0   ADDIU SP, SP, -32
9D005250  AFBF001C   SW RA, 28(SP)
9D005254  AFBE0018   SW S8, 24(SP)
9D005258  03A0F021   ADDU S8, SP, ZERO
268:                     unsigned int res;
269:                 
270:                     res = NVMemOperation(NVMOP_NOP);
9D00525C  24044000   ADDIU A0, ZERO, 16384
9D005260  0F4013EF   JAL NVMemOperation
9D005264  00000000   NOP
9D005268  AFC20010   SW V0, 16(S8)
271:                 
272:                     return res;
9D00526C  8FC20010   LW V0, 16(S8)
273:                 }
9D005270  03C0E821   ADDU SP, S8, ZERO
9D005274  8FBF001C   LW RA, 28(SP)
9D005278  8FBE0018   LW S8, 24(SP)
9D00527C  27BD0020   ADDIU SP, SP, 32
9D005280  03E00008   JR RA
9D005284  00000000   NOP
274:                 
275:                 
276:                 
277:                 
278:                 
279:                 /***********************End of File*************************************************************/
---  /home/bekeband/MPLABXProjects/AN1388_Source_Code_2014_02_14/PIC32_Bootloaders/Firmware/Bootloader/Source/FrameWork/Framework.c
1:                   /*********************************************************************
2:                    *
3:                    *                  PIC32 Boot Loader
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Framework.c
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   * Compiler:        MPLAB C32
11:                   *                  MPLAB IDE
12:                   * Company:         Microchip Technology, Inc.
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * The software supplied herewith by Microchip Technology Incorporated
17:                   * (the ï¿½Companyï¿½) for its PIC32 Microcontroller is intended
18:                   * and supplied to you, the Companyï¿½s customer, for use solely and
19:                   * exclusively on Microchip PIC32 Microcontroller products.
20:                   * The software is owned by the Company and/or its supplier, and is
21:                   * protected under applicable copyright laws. All rights are reserved.
22:                   * Any use in violation of the foregoing restrictions may subject the
23:                   * user to criminal sanctions under applicable laws, as well as to
24:                   * civil liability for the breach of the terms and conditions of this
25:                   * license.
26:                   *
27:                   * THIS SOFTWARE IS PROVIDED IN AN ï¿½AS ISï¿½ CONDITION. NO WARRANTIES,
28:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
29:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
30:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
31:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
32:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
33:                   *
34:                   *
35:                   * $Id:  $
36:                   * $Name: $
37:                   *
38:                   **********************************************************************/
39:                  
40:                  #include "GenericTypeDefs.h"
41:                  #include "HardwareProfile.h"
42:                  #include "Include/BootLoader.h"
43:                  #include "Include/Framework/Framework.h"
44:                  #include "Include/NVMem.h"
45:                  #include  <string.h>
46:                  #include <plib.h>
47:                  
48:                  
49:                  
50:                  
51:                  
52:                  #define DATA_RECORD 		0
53:                  #define END_OF_FILE_RECORD 	1
54:                  #define EXT_SEG_ADRS_RECORD 2
55:                  #define EXT_LIN_ADRS_RECORD 4
56:                  
57:                  #if defined(__PIC32MX1XX_2XX__)
58:                      // PIC32MX1xx and PIC32MX2xx devices
59:                      #define FLASH_PAGE_SIZE		 		1024
60:                      #define DEV_CONFIG_REG_BASE_ADDRESS 0x9FC00BF0
61:                      #define DEV_CONFIG_REG_END_ADDRESS   0x9FC00BFF
62:                  #elif defined(__PIC32MX3XX_7XX__)
63:                      // PIC32MX3xx to PIC32MX7xx devices
64:                      #define FLASH_PAGE_SIZE		 		4096
65:                      #define DEV_CONFIG_REG_BASE_ADDRESS 0x9FC02FF0
66:                      #define DEV_CONFIG_REG_END_ADDRESS   0x9FC02FFF
67:                  #endif
68:                  
69:                  
70:                  
71:                  
72:                  
73:                  typedef enum
74:                  {
75:                  	READ_BOOT_INFO = 1,
76:                  	ERASE_FLASH, 
77:                  	PROGRAM_FLASH,
78:                  	READ_CRC,
79:                  	JMP_TO_APP
80:                  	
81:                  }T_COMMANDS;	
82:                  
83:                  
84:                  typedef struct
85:                  {
86:                  	UINT Len;
87:                  	UINT8 Data[FRAMEWORK_BUFF_SIZE];
88:                  	
89:                  }T_FRAME;
90:                  
91:                  typedef struct 
92:                  {
93:                  	UINT8 RecDataLen;
94:                  	DWORD_VAL Address;
95:                  	UINT8 RecType;
96:                  	UINT8* Data;
97:                  	UINT8 CheckSum;	
98:                  	DWORD_VAL ExtSegAddress;
99:                  	DWORD_VAL ExtLinAddress;
100:                 }T_HEX_RECORD;	
101:                 
102:                 
103:                 static const UINT8 BootInfo[2] =
104:                 {
105:                     MAJOR_VERSION,
106:                     MINOR_VERSION
107:                 };
108:                 
109:                 
110:                 static T_FRAME RxBuff;
111:                 static T_FRAME TxBuff;
112:                 static BOOL RxFrameValid;
113:                 static BOOL TriggerBaudChange;
114:                 static DWORD_VAL NewBaud;
115:                 static BOOL RunApplication = FALSE;
116:                 
117:                 #ifdef __cplusplus
118:                 extern "C" {
119:                 #endif
120:                 void HandleCommand(void);
121:                 void BuildRxFrame(UINT8 *RxData, INT16 RxLen);
122:                 UINT GetTransmitFrame(UINT8* Buff);
123:                 void WriteHexRecord2Flash(UINT8* HexRecord, UINT totalRecLen);
124:                 BOOL BaudRateChangeRequested(void);
125:                 UINT16 CalculateCrc(UINT8 *data, UINT32 len);
126:                 #ifdef __cplusplus
127:                 }
128:                 #endif	
129:                 
130:                 
131:                 
132:                 /********************************************************************
133:                 * Function: 	FrameWorkTask()
134:                 *
135:                 * Precondition: 
136:                 *
137:                 * Input: 		None.
138:                 *
139:                 * Output:		None.
140:                 *
141:                 * Side Effects:	None.
142:                 *
143:                 * Overview: 	Process the command if there is a valid fame.
144:                 *
145:                 *			
146:                 * Note:		 	None.
147:                 ********************************************************************/
148:                 void FrameWorkTask(void)
149:                 {
9D003458  27BDFFE8   ADDIU SP, SP, -24
9D00345C  AFBF0014   SW RA, 20(SP)
9D003460  AFBE0010   SW S8, 16(SP)
9D003464  03A0F021   ADDU S8, SP, ZERO
150:                 
151:                 	if(RxFrameValid)
9D003468  8F828010   LW V0, -32752(GP)
9D00346C  10400004   BEQ V0, ZERO, 0x9D003480
9D003470  00000000   NOP
152:                 	{
153:                 		// Valid frame received, process the command.
154:                 		HandleCommand();	
9D003474  0F400D26   JAL HandleCommand
9D003478  00000000   NOP
155:                 		// Reset the flag.
156:                 		RxFrameValid = FALSE;			
9D00347C  AF808010   SW ZERO, -32752(GP)
157:                 	}        
158:                 }
9D003480  03C0E821   ADDU SP, S8, ZERO
9D003484  8FBF0014   LW RA, 20(SP)
9D003488  8FBE0010   LW S8, 16(SP)
9D00348C  27BD0018   ADDIU SP, SP, 24
9D003490  03E00008   JR RA
9D003494  00000000   NOP
159:                 
160:                 
161:                 /********************************************************************
162:                 * Function: 	HandleCommand()
163:                 *
164:                 * Precondition: 
165:                 *
166:                 * Input: 		None.
167:                 *
168:                 * Output:		None.
169:                 *
170:                 * Side Effects:	None.
171:                 *
172:                 * Overview: 	Process the received frame and take action depending on
173:                 				the command received.
174:                 *
175:                 *			
176:                 * Note:		 	None.
177:                 ********************************************************************/
178:                 void HandleCommand(void)
179:                 {
9D003498  27BDFFD0   ADDIU SP, SP, -48
9D00349C  AFBF002C   SW RA, 44(SP)
9D0034A0  AFBE0028   SW S8, 40(SP)
9D0034A4  03A0F021   ADDU S8, SP, ZERO
180:                 	UINT8 Cmd;
181:                 	DWORD_VAL Address;
182:                 	UINT8 i;
183:                 	DWORD_VAL Length;
184:                 	UINT8 *DataPtr;
185:                 	UINT Result;
186:                 	WORD_VAL crc;
187:                 	void* pFlash;
188:                 	
189:                 	// First byte of the data field is command.
190:                 	Cmd = RxBuff.Data[0];
9D0034A8  3C02A000   LUI V0, -24576
9D0034AC  2442031C   ADDIU V0, V0, 796
9D0034B0  90420004   LBU V0, 4(V0)
9D0034B4  A3C20011   SB V0, 17(S8)
191:                 	// Partially build response frame. First byte in the data field carries command.
192:                 	TxBuff.Data[0] = RxBuff.Data[0];
9D0034B8  3C02A000   LUI V0, -24576
9D0034BC  2442031C   ADDIU V0, V0, 796
9D0034C0  90430004   LBU V1, 4(V0)
9D0034C4  3C02A000   LUI V0, -24576
9D0034C8  24420708   ADDIU V0, V0, 1800
9D0034CC  A0430004   SB V1, 4(V0)
193:                 	
194:                 	// Reset the response length to 0.
195:                 	TxBuff.Len = 0;
9D0034D0  3C02A000   LUI V0, -24576
9D0034D4  AC400708   SW ZERO, 1800(V0)
196:                 				
197:                 	// Process the command.		
198:                 	switch(Cmd)
9D0034D8  93C20011   LBU V0, 17(S8)
9D0034DC  2C430006   SLTIU V1, V0, 6
9D0034E0  10600072   BEQ V1, ZERO, 0x9D0036AC
9D0034E4  00000000   NOP
9D0034E8  00021880   SLL V1, V0, 2
9D0034EC  3C029D00   LUI V0, -25344
9D0034F0  24423504   ADDIU V0, V0, 13572
9D0034F4  00621021   ADDU V0, V1, V0
9D0034F8  8C420000   LW V0, 0(V0)
9D0034FC  00400008   JR V0
9D003500  00000000   NOP
199:                 	{
200:                 		case READ_BOOT_INFO: // Read boot loader version info.
201:                 			memcpy(&TxBuff.Data[1], BootInfo, 2);
9D00351C  3C02A000   LUI V0, -24576
9D003520  2442070D   ADDIU V0, V0, 1805
9D003524  00402021   ADDU A0, V0, ZERO
9D003528  3C029D00   LUI V0, -25344
9D00352C  244557C0   ADDIU A1, V0, 22464
9D003530  24060002   ADDIU A2, ZERO, 2
9D003534  77401618   JALX memcpy
9D003538  00000000   NOP
202:                 			//Set the transmit frame length.
203:                 			TxBuff.Len = 2 + 1; // Boot Info Fields	+ command
9D00353C  3C02A000   LUI V0, -24576
9D003540  24030003   ADDIU V1, ZERO, 3
9D003544  AC430708   SW V1, 1800(V0)
204:                 			break;
9D003548  0B400DAF   J 0x9D0036BC
9D00354C  00000000   NOP
205:                 			
206:                 		case ERASE_FLASH:
207:                 			pFlash = (void*)APP_FLASH_BASE_ADDRESS;									
9D003550  3C029D00   LUI V0, -25344
9D003554  34426000   ORI V0, V0, 24576
9D003558  AFC20014   SW V0, 20(S8)
208:                 			for( i = 0; i < ((APP_FLASH_END_ADDRESS - APP_FLASH_BASE_ADDRESS + 1)/FLASH_PAGE_SIZE); i++ )
9D00355C  A3C00010   SB ZERO, 16(S8)
9D003560  0B400D68   J 0x9D0035A0
9D003564  00000000   NOP
9D003594  93C20010   LBU V0, 16(S8)
9D003598  24420001   ADDIU V0, V0, 1
9D00359C  A3C20010   SB V0, 16(S8)
9D0035A0  93C30010   LBU V1, 16(S8)
9D0035A4  3C02BF88   LUI V0, -16504
9D0035A8  8C422060   LW V0, 8288(V0)
9D0035AC  2442A000   ADDIU V0, V0, -24576
9D0035B0  00021302   SRL V0, V0, 12
9D0035B4  0062102B   SLTU V0, V1, V0
9D0035B8  1440FFEB   BNE V0, ZERO, 0x9D003568
9D0035BC  00000000   NOP
209:                 			{
210:                 				
211:                 				Result = NVMemErasePage( pFlash + (i*FLASH_PAGE_SIZE) );
9D003568  93C20010   LBU V0, 16(S8)
9D00356C  00021300   SLL V0, V0, 12
9D003570  8FC30014   LW V1, 20(S8)
9D003574  00621021   ADDU V0, V1, V0
9D003578  00402021   ADDU A0, V0, ZERO
9D00357C  0F40144E   JAL NVMemErasePage
9D003580  00000000   NOP
9D003584  AFC20018   SW V0, 24(S8)
212:                 				// Assert on NV error. This must be caught during debug phase.
213:                 				ASSERT(Result==0);
9D003588  8FC20018   LW V0, 24(S8)
9D00358C  1440FFFE   BNE V0, ZERO, 0x9D003588
9D003590  00000000   NOP
214:                 			
215:                 			}		           
216:                             //Set the transmit frame length.
217:                             TxBuff.Len = 1; // Command
9D0035C0  3C02A000   LUI V0, -24576
9D0035C4  24030001   ADDIU V1, ZERO, 1
9D0035C8  AC430708   SW V1, 1800(V0)
218:                 			break;
9D0035CC  0B400DAF   J 0x9D0036BC
9D0035D0  00000000   NOP
219:                 		
220:                 		case PROGRAM_FLASH:
221:                 		    WriteHexRecord2Flash(&RxBuff.Data[1], RxBuff.Len-3);	//Negate length of command and CRC RxBuff.Len.
9D0035D4  3C02A000   LUI V0, -24576
9D0035D8  8C42031C   LW V0, 796(V0)
9D0035DC  2442FFFD   ADDIU V0, V0, -3
9D0035E0  3C03A000   LUI V1, -24576
9D0035E4  24640321   ADDIU A0, V1, 801
9D0035E8  00402821   ADDU A1, V0, ZERO
9D0035EC  0F400ED3   JAL WriteHexRecord2Flash
9D0035F0  00000000   NOP
222:                 		    //Set the transmit frame length.
223:                             TxBuff.Len = 1; // Command	    	
9D0035F4  3C02A000   LUI V0, -24576
9D0035F8  24030001   ADDIU V1, ZERO, 1
9D0035FC  AC430708   SW V1, 1800(V0)
224:                 		   	break;
9D003600  0B400DAF   J 0x9D0036BC
9D003604  00000000   NOP
225:                 		   
226:                 		   
227:                 		case READ_CRC:
228:                 			 // Get address from the packet.
229:                     	    memcpy(&Address.v[0], &RxBuff.Data[1], sizeof(Address.Val));
9D003608  3C02A000   LUI V0, -24576
9D00360C  24420321   ADDIU V0, V0, 801
9D003610  27C3001C   ADDIU V1, S8, 28
9D003614  00602021   ADDU A0, V1, ZERO
9D003618  00402821   ADDU A1, V0, ZERO
9D00361C  24060004   ADDIU A2, ZERO, 4
9D003620  77401618   JALX memcpy
9D003624  00000000   NOP
230:                     	    memcpy(&Length.v[0], &RxBuff.Data[5], sizeof(Length.Val));
9D003628  3C02A000   LUI V0, -24576
9D00362C  24420325   ADDIU V0, V0, 805
9D003630  27C30020   ADDIU V1, S8, 32
9D003634  00602021   ADDU A0, V1, ZERO
9D003638  00402821   ADDU A1, V0, ZERO
9D00363C  24060004   ADDIU A2, ZERO, 4
9D003640  77401618   JALX memcpy
9D003644  00000000   NOP
231:                 			crc.Val = CalculateCrc((UINT8 *)Address.Val, Length.Val);
9D003648  8FC2001C   LW V0, 28(S8)
9D00364C  00401821   ADDU V1, V0, ZERO
9D003650  8FC20020   LW V0, 32(S8)
9D003654  00602021   ADDU A0, V1, ZERO
9D003658  00402821   ADDU A1, V0, ZERO
9D00365C  0F400FED   JAL CalculateCrc
9D003660  00000000   NOP
9D003664  A7C20024   SH V0, 36(S8)
232:                 			memcpy(&TxBuff.Data[1], &crc.v[0], 2);	
9D003668  3C02A000   LUI V0, -24576
9D00366C  2443070D   ADDIU V1, V0, 1805
9D003670  27C20024   ADDIU V0, S8, 36
9D003674  00602021   ADDU A0, V1, ZERO
9D003678  00402821   ADDU A1, V0, ZERO
9D00367C  24060002   ADDIU A2, ZERO, 2
9D003680  77401618   JALX memcpy
9D003684  00000000   NOP
233:                 			
234:                 			//Set the transmit frame length.
235:                             TxBuff.Len = 1 + 2;	// Command + 2 bytes of CRC.
9D003688  3C02A000   LUI V0, -24576
9D00368C  24030003   ADDIU V1, ZERO, 3
9D003690  AC430708   SW V1, 1800(V0)
236:                 			
237:                 			break;
9D003694  0B400DAF   J 0x9D0036BC
9D003698  00000000   NOP
238:                 	    
239:                 	    case JMP_TO_APP:
240:                 	    	// Exit firmware upgrade mode.
241:                 	    	RunApplication = TRUE;
9D00369C  24020001   ADDIU V0, ZERO, 1
9D0036A0  AF82801C   SW V0, -32740(GP)
242:                 	    	break;
9D0036A4  0B400DAF   J 0x9D0036BC
9D0036A8  00000000   NOP
243:                 	    	
244:                 	    default:
245:                 	    	// Nothing to do.
246:                 	    	break;
9D0036AC  00000000   NOP
9D0036B0  0B400DAF   J 0x9D0036BC
9D0036B4  00000000   NOP
9D0036B8  00000000   NOP
247:                 	}   
248:                 	
249:                 
250:                 		
251:                 }
9D0036BC  03C0E821   ADDU SP, S8, ZERO
9D0036C0  8FBF002C   LW RA, 44(SP)
9D0036C4  8FBE0028   LW S8, 40(SP)
9D0036C8  27BD0030   ADDIU SP, SP, 48
9D0036CC  03E00008   JR RA
9D0036D0  00000000   NOP
252:                 
253:                 
254:                 /********************************************************************
255:                 * Function: 	BuildRxFrame()
256:                 *
257:                 * Precondition: 
258:                 *
259:                 * Input: 		Pointer to Rx Data and Rx byte length.
260:                 *
261:                 * Output:		None.
262:                 *
263:                 * Side Effects:	None.
264:                 *
265:                 * Overview: 	Builds rx frame and checks CRC.
266:                 *
267:                 *			
268:                 * Note:		 	None.
269:                 ********************************************************************/
270:                 void BuildRxFrame(UINT8 *RxData, INT16 RxLen)
271:                 {
9D0036D4  27BDFFE0   ADDIU SP, SP, -32
9D0036D8  AFBF001C   SW RA, 28(SP)
9D0036DC  AFBE0018   SW S8, 24(SP)
9D0036E0  03A0F021   ADDU S8, SP, ZERO
9D0036E4  AFC40020   SW A0, 32(S8)
9D0036E8  00A01021   ADDU V0, A1, ZERO
9D0036EC  A7C20024   SH V0, 36(S8)
272:                 	static BOOL Escape = FALSE;
273:                 	WORD_VAL crc;
274:                 	
275:                 	
276:                 	while((RxLen > 0) && (!RxFrameValid)) // Loop till len = 0 or till frame is valid
9D0036F0  0B400E50   J 0x9D003940
9D0036F4  00000000   NOP
9D003940  87C20024   LH V0, 36(S8)
9D003944  18400004   BLEZ V0, 0x9D003958
9D003948  00000000   NOP
9D00394C  8F828010   LW V0, -32752(GP)
9D003950  1040FF69   BEQ V0, ZERO, 0x9D0036F8
9D003954  00000000   NOP
277:                 	{
278:                 		RxLen--;
9D0036F8  97C20024   LHU V0, 36(S8)
9D0036FC  2442FFFF   ADDIU V0, V0, -1
9D003700  A7C20024   SH V0, 36(S8)
279:                 		
280:                 		if(RxBuff.Len >= sizeof(RxBuff.Data))
9D003704  3C02A000   LUI V0, -24576
9D003708  8C42031C   LW V0, 796(V0)
9D00370C  2C4203E8   SLTIU V0, V0, 1000
9D003710  14400003   BNE V0, ZERO, 0x9D003720
9D003714  00000000   NOP
281:                 		{
282:                 			RxBuff.Len = 0;
9D003718  3C02A000   LUI V0, -24576
9D00371C  AC40031C   SW ZERO, 796(V0)
283:                 		}	
284:                 		
285:                 		switch(*RxData)
9D003720  8FC20020   LW V0, 32(S8)
9D003724  90420000   LBU V0, 0(V0)
9D003728  24030004   ADDIU V1, ZERO, 4
9D00372C  1043001C   BEQ V0, V1, 0x9D0037A0
9D003730  00000000   NOP
9D003734  24030010   ADDIU V1, ZERO, 16
9D003738  10430054   BEQ V0, V1, 0x9D00388C
9D00373C  00000000   NOP
9D003740  24030001   ADDIU V1, ZERO, 1
9D003744  14430066   BNE V0, V1, 0x9D0038E0
9D003748  00000000   NOP
286:                 		{
287:                 			
288:                 			case SOH: //Start of header
289:                 				if(Escape)
9D00374C  8F828020   LW V0, -32736(GP)
9D003750  1040000F   BEQ V0, ZERO, 0x9D003790
9D003754  00000000   NOP
290:                 				{
291:                 					// Received byte is not SOH, but data.
292:                 					RxBuff.Data[RxBuff.Len++] = *RxData;
9D003758  3C02A000   LUI V0, -24576
9D00375C  8C42031C   LW V0, 796(V0)
9D003760  8FC30020   LW V1, 32(S8)
9D003764  90640000   LBU A0, 0(V1)
9D003768  3C03A000   LUI V1, -24576
9D00376C  2463031C   ADDIU V1, V1, 796
9D003770  00431821   ADDU V1, V0, V1
9D003774  A0640004   SB A0, 4(V1)
9D003778  24430001   ADDIU V1, V0, 1
9D00377C  3C02A000   LUI V0, -24576
9D003780  AC43031C   SW V1, 796(V0)
293:                 					// Reset Escape Flag.
294:                 					Escape = FALSE;
9D003784  AF808020   SW ZERO, -32736(GP)
295:                 				}
296:                 				else
297:                 				{
298:                 					// Received byte is indeed a SOH which indicates start of new frame.
299:                 					RxBuff.Len = 0;				
9D003790  3C02A000   LUI V0, -24576
9D003794  AC40031C   SW ZERO, 796(V0)
300:                 				}		
301:                 				break;
9D003788  0B400E4D   J 0x9D003934
9D00378C  00000000   NOP
9D003798  0B400E4D   J 0x9D003934
9D00379C  00000000   NOP
302:                 				
303:                 			case EOT: // End of transmission
304:                 				if(Escape)
9D0037A0  8F828020   LW V0, -32736(GP)
9D0037A4  1040000F   BEQ V0, ZERO, 0x9D0037E4
9D0037A8  00000000   NOP
305:                 				{
306:                 					// Received byte is not EOT, but data.
307:                 					RxBuff.Data[RxBuff.Len++] = *RxData;
9D0037AC  3C02A000   LUI V0, -24576
9D0037B0  8C42031C   LW V0, 796(V0)
9D0037B4  8FC30020   LW V1, 32(S8)
9D0037B8  90640000   LBU A0, 0(V1)
9D0037BC  3C03A000   LUI V1, -24576
9D0037C0  2463031C   ADDIU V1, V1, 796
9D0037C4  00431821   ADDU V1, V0, V1
9D0037C8  A0640004   SB A0, 4(V1)
9D0037CC  24430001   ADDIU V1, V0, 1
9D0037D0  3C02A000   LUI V0, -24576
9D0037D4  AC43031C   SW V1, 796(V0)
308:                 					// Reset Escape Flag.
309:                 					Escape = FALSE;
9D0037D8  AF808020   SW ZERO, -32736(GP)
310:                 				}
311:                 				else
312:                 				{
313:                 					// Received byte is indeed a EOT which indicates end of frame.
314:                 					// Calculate CRC to check the validity of the frame.
315:                 					if(RxBuff.Len > 1)
9D0037E4  3C02A000   LUI V0, -24576
9D0037E8  8C42031C   LW V0, 796(V0)
9D0037EC  2C420002   SLTIU V0, V0, 2
9D0037F0  14400049   BNE V0, ZERO, 0x9D003918
9D0037F4  00000000   NOP
316:                 					{
317:                 						crc.byte.LB = RxBuff.Data[RxBuff.Len-2];
9D0037F8  3C02A000   LUI V0, -24576
9D0037FC  8C42031C   LW V0, 796(V0)
9D003800  2443FFFE   ADDIU V1, V0, -2
9D003804  3C02A000   LUI V0, -24576
9D003808  2442031C   ADDIU V0, V0, 796
9D00380C  00621021   ADDU V0, V1, V0
9D003810  90420004   LBU V0, 4(V0)
9D003814  A3C20010   SB V0, 16(S8)
318:                 						crc.byte.HB = RxBuff.Data[RxBuff.Len-1];
9D003818  3C02A000   LUI V0, -24576
9D00381C  8C42031C   LW V0, 796(V0)
9D003820  2443FFFF   ADDIU V1, V0, -1
9D003824  3C02A000   LUI V0, -24576
9D003828  2442031C   ADDIU V0, V0, 796
9D00382C  00621021   ADDU V0, V1, V0
9D003830  90420004   LBU V0, 4(V0)
9D003834  A3C20011   SB V0, 17(S8)
319:                 						if((CalculateCrc(RxBuff.Data, (UINT32)(RxBuff.Len-2)) == crc.Val) && (RxBuff.Len > 2))
9D003838  3C02A000   LUI V0, -24576
9D00383C  8C42031C   LW V0, 796(V0)
9D003840  2442FFFE   ADDIU V0, V0, -2
9D003844  3C03A000   LUI V1, -24576
9D003848  24640320   ADDIU A0, V1, 800
9D00384C  00402821   ADDU A1, V0, ZERO
9D003850  0F400FED   JAL CalculateCrc
9D003854  00000000   NOP
9D003858  00401821   ADDU V1, V0, ZERO
9D00385C  97C20010   LHU V0, 16(S8)
9D003860  14620030   BNE V1, V0, 0x9D003924
9D003864  00000000   NOP
9D003868  3C02A000   LUI V0, -24576
9D00386C  8C42031C   LW V0, 796(V0)
9D003870  2C420003   SLTIU V0, V0, 3
9D003874  1440002E   BNE V0, ZERO, 0x9D003930
9D003878  00000000   NOP
320:                 						{
321:                 							// CRC matches and frame received is valid.
322:                 							RxFrameValid = TRUE;
9D00387C  24020001   ADDIU V0, ZERO, 1
9D003880  AF828010   SW V0, -32752(GP)
323:                 												
324:                 						}
325:                 					}		
326:                 					
327:                 				}							
328:                 				break;
9D0037DC  0B400E4D   J 0x9D003934
9D0037E0  00000000   NOP
9D003884  0B400E4D   J 0x9D003934
9D003888  00000000   NOP
9D003918  00000000   NOP
9D00391C  0B400E4D   J 0x9D003934
9D003920  00000000   NOP
9D003924  00000000   NOP
9D003928  0B400E4D   J 0x9D003934
9D00392C  00000000   NOP
9D003930  00000000   NOP
329:                 				
330:                 				
331:                 		    case DLE: // Escape character received.
332:                 				if(Escape)
9D00388C  8F828020   LW V0, -32736(GP)
9D003890  1040000F   BEQ V0, ZERO, 0x9D0038D0
9D003894  00000000   NOP
333:                 				{
334:                 					// Received byte is not ESC but data.
335:                 					RxBuff.Data[RxBuff.Len++] = *RxData;
9D003898  3C02A000   LUI V0, -24576
9D00389C  8C42031C   LW V0, 796(V0)
9D0038A0  8FC30020   LW V1, 32(S8)
9D0038A4  90640000   LBU A0, 0(V1)
9D0038A8  3C03A000   LUI V1, -24576
9D0038AC  2463031C   ADDIU V1, V1, 796
9D0038B0  00431821   ADDU V1, V0, V1
9D0038B4  A0640004   SB A0, 4(V1)
9D0038B8  24430001   ADDIU V1, V0, 1
9D0038BC  3C02A000   LUI V0, -24576
9D0038C0  AC43031C   SW V1, 796(V0)
336:                 					// Reset Escape Flag.
337:                 					Escape = FALSE;					
9D0038C4  AF808020   SW ZERO, -32736(GP)
338:                 				}
339:                 				else
340:                 				{
341:                 					// Received byte is an escape character. Set Escape flag to escape next byte.
342:                 					Escape = TRUE;					
9D0038D0  24020001   ADDIU V0, ZERO, 1
9D0038D4  AF828020   SW V0, -32736(GP)
343:                 				}	
344:                 				break;
9D0038C8  0B400E4D   J 0x9D003934
9D0038CC  00000000   NOP
9D0038D8  0B400E4D   J 0x9D003934
9D0038DC  00000000   NOP
345:                 			
346:                 			default: // Data field.
347:                 			    RxBuff.Data[RxBuff.Len++] = *RxData;
9D0038E0  3C02A000   LUI V0, -24576
9D0038E4  8C42031C   LW V0, 796(V0)
9D0038E8  8FC30020   LW V1, 32(S8)
9D0038EC  90640000   LBU A0, 0(V1)
9D0038F0  3C03A000   LUI V1, -24576
9D0038F4  2463031C   ADDIU V1, V1, 796
9D0038F8  00431821   ADDU V1, V0, V1
9D0038FC  A0640004   SB A0, 4(V1)
9D003900  24430001   ADDIU V1, V0, 1
9D003904  3C02A000   LUI V0, -24576
9D003908  AC43031C   SW V1, 796(V0)
348:                 			    // Reset Escape Flag.
349:                 			    Escape = FALSE;
9D00390C  AF808020   SW ZERO, -32736(GP)
350:                 				break;	
9D003910  0B400E4D   J 0x9D003934
9D003914  00000000   NOP
351:                 			
352:                 		}
353:                 
354:                 		//Increment the pointer.
355:                 		RxData++;	
9D003934  8FC20020   LW V0, 32(S8)
9D003938  24420001   ADDIU V0, V0, 1
9D00393C  AFC20020   SW V0, 32(S8)
356:                 	
357:                 	}	
358:                 	
359:                 }	
9D003958  03C0E821   ADDU SP, S8, ZERO
9D00395C  8FBF001C   LW RA, 28(SP)
9D003960  8FBE0018   LW S8, 24(SP)
9D003964  27BD0020   ADDIU SP, SP, 32
9D003968  03E00008   JR RA
9D00396C  00000000   NOP
360:                 
361:                 
362:                 /********************************************************************
363:                 * Function: 	GetTransmitFrame()
364:                 *
365:                 * Precondition: 
366:                 *
367:                 * Input: 		Buffer pointer.
368:                 *
369:                 * Output:		Length of the buffer.
370:                 *
371:                 * Side Effects:	None.
372:                 *
373:                 * Overview: 	Gets the complete transmit frame into the "Buff".
374:                 *
375:                 *			
376:                 * Note:		 	None.
377:                 ********************************************************************/
378:                 UINT GetTransmitFrame(UINT8* Buff)
379:                 {
9D003970  27BDFFD8   ADDIU SP, SP, -40
9D003974  AFBF0024   SW RA, 36(SP)
9D003978  AFBE0020   SW S8, 32(SP)
9D00397C  03A0F021   ADDU S8, SP, ZERO
9D003980  AFC40028   SW A0, 40(S8)
380:                 	INT BuffLen = 0;
9D003984  AFC00010   SW ZERO, 16(S8)
381:                 	WORD_VAL crc;
382:                 	UINT8 i;
383:                 	
384:                 	if(TxBuff.Len) 
9D003988  3C02A000   LUI V0, -24576
9D00398C  8C420708   LW V0, 1800(V0)
9D003990  10400067   BEQ V0, ZERO, 0x9D003B30
9D003994  00000000   NOP
385:                 	{
386:                 		//There is something to transmit.
387:                 		// Calculate CRC of the frame.
388:                 		crc.Val = CalculateCrc(TxBuff.Data, (UINT32)TxBuff.Len);
9D003998  3C02A000   LUI V0, -24576
9D00399C  8C420708   LW V0, 1800(V0)
9D0039A0  3C03A000   LUI V1, -24576
9D0039A4  2464070C   ADDIU A0, V1, 1804
9D0039A8  00402821   ADDU A1, V0, ZERO
9D0039AC  0F400FED   JAL CalculateCrc
9D0039B0  00000000   NOP
9D0039B4  A7C20018   SH V0, 24(S8)
389:                 		TxBuff.Data[TxBuff.Len++] = crc.byte.LB;
9D0039B8  3C02A000   LUI V0, -24576
9D0039BC  8C420708   LW V0, 1800(V0)
9D0039C0  93C40018   LBU A0, 24(S8)
9D0039C4  3C03A000   LUI V1, -24576
9D0039C8  24630708   ADDIU V1, V1, 1800
9D0039CC  00431821   ADDU V1, V0, V1
9D0039D0  A0640004   SB A0, 4(V1)
9D0039D4  24430001   ADDIU V1, V0, 1
9D0039D8  3C02A000   LUI V0, -24576
9D0039DC  AC430708   SW V1, 1800(V0)
390:                 		TxBuff.Data[TxBuff.Len++] = crc.byte.HB; 	
9D0039E0  3C02A000   LUI V0, -24576
9D0039E4  8C420708   LW V0, 1800(V0)
9D0039E8  93C40019   LBU A0, 25(S8)
9D0039EC  3C03A000   LUI V1, -24576
9D0039F0  24630708   ADDIU V1, V1, 1800
9D0039F4  00431821   ADDU V1, V0, V1
9D0039F8  A0640004   SB A0, 4(V1)
9D0039FC  24430001   ADDIU V1, V0, 1
9D003A00  3C02A000   LUI V0, -24576
9D003A04  AC430708   SW V1, 1800(V0)
391:                 		
392:                 		// Insert SOH (Indicates beginning of the frame)	
393:                 		Buff[BuffLen++] = SOH;
9D003A08  8FC20010   LW V0, 16(S8)
9D003A0C  8FC30028   LW V1, 40(S8)
9D003A10  00621021   ADDU V0, V1, V0
9D003A14  24030001   ADDIU V1, ZERO, 1
9D003A18  A0430000   SB V1, 0(V0)
9D003A1C  8FC20010   LW V0, 16(S8)
9D003A20  24420001   ADDIU V0, V0, 1
9D003A24  AFC20010   SW V0, 16(S8)
394:                 		
395:                 		// Insert Data Link Escape Character.
396:                 		for(i = 0; i < TxBuff.Len; i++)
9D003A28  A3C00014   SB ZERO, 20(S8)
9D003A2C  0B400EBC   J 0x9D003AF0
9D003A30  00000000   NOP
9D003AE4  93C20014   LBU V0, 20(S8)
9D003AE8  24420001   ADDIU V0, V0, 1
9D003AEC  A3C20014   SB V0, 20(S8)
9D003AF0  93C30014   LBU V1, 20(S8)
9D003AF4  3C02A000   LUI V0, -24576
9D003AF8  8C420708   LW V0, 1800(V0)
9D003AFC  0062102B   SLTU V0, V1, V0
9D003B00  1440FFCC   BNE V0, ZERO, 0x9D003A34
9D003B04  00000000   NOP
397:                 		{
398:                 			if((TxBuff.Data[i] == EOT) || (TxBuff.Data[i] == SOH)
9D003A34  93C30014   LBU V1, 20(S8)
9D003A38  3C02A000   LUI V0, -24576
9D003A3C  24420708   ADDIU V0, V0, 1800
9D003A40  00621021   ADDU V0, V1, V0
9D003A44  90430004   LBU V1, 4(V0)
9D003A48  24020004   ADDIU V0, ZERO, 4
9D003A4C  10620011   BEQ V1, V0, 0x9D003A94
9D003A50  00000000   NOP
9D003A54  93C30014   LBU V1, 20(S8)
9D003A58  3C02A000   LUI V0, -24576
9D003A5C  24420708   ADDIU V0, V0, 1800
9D003A60  00621021   ADDU V0, V1, V0
9D003A64  90430004   LBU V1, 4(V0)
9D003A68  24020001   ADDIU V0, ZERO, 1
9D003A6C  10620009   BEQ V1, V0, 0x9D003A94
9D003A70  00000000   NOP
399:                 				|| (TxBuff.Data[i] == DLE))
9D003A74  93C30014   LBU V1, 20(S8)
9D003A78  3C02A000   LUI V0, -24576
9D003A7C  24420708   ADDIU V0, V0, 1800
9D003A80  00621021   ADDU V0, V1, V0
9D003A84  90430004   LBU V1, 4(V0)
9D003A88  24020010   ADDIU V0, ZERO, 16
9D003A8C  14620009   BNE V1, V0, 0x9D003AB4
9D003A90  00000000   NOP
400:                 			{
401:                 				// EOT/SOH/DLE repeated in the data field, insert DLE.
402:                 				Buff[BuffLen++] = DLE;			
9D003A94  8FC20010   LW V0, 16(S8)
9D003A98  8FC30028   LW V1, 40(S8)
9D003A9C  00621021   ADDU V0, V1, V0
9D003AA0  24030010   ADDIU V1, ZERO, 16
9D003AA4  A0430000   SB V1, 0(V0)
9D003AA8  8FC20010   LW V0, 16(S8)
9D003AAC  24420001   ADDIU V0, V0, 1
9D003AB0  AFC20010   SW V0, 16(S8)
403:                 			}
404:                 			Buff[BuffLen++] = TxBuff.Data[i];
9D003AB4  8FC20010   LW V0, 16(S8)
9D003AB8  8FC30028   LW V1, 40(S8)
9D003ABC  00621021   ADDU V0, V1, V0
9D003AC0  93C40014   LBU A0, 20(S8)
9D003AC4  3C03A000   LUI V1, -24576
9D003AC8  24630708   ADDIU V1, V1, 1800
9D003ACC  00831821   ADDU V1, A0, V1
9D003AD0  90630004   LBU V1, 4(V1)
9D003AD4  A0430000   SB V1, 0(V0)
9D003AD8  8FC20010   LW V0, 16(S8)
9D003ADC  24420001   ADDIU V0, V0, 1
9D003AE0  AFC20010   SW V0, 16(S8)
405:                 		} 
406:                 		
407:                 		// Mark end of frame with EOT.
408:                 		Buff[BuffLen++] = EOT;
9D003B08  8FC20010   LW V0, 16(S8)
9D003B0C  8FC30028   LW V1, 40(S8)
9D003B10  00621021   ADDU V0, V1, V0
9D003B14  24030004   ADDIU V1, ZERO, 4
9D003B18  A0430000   SB V1, 0(V0)
9D003B1C  8FC20010   LW V0, 16(S8)
9D003B20  24420001   ADDIU V0, V0, 1
9D003B24  AFC20010   SW V0, 16(S8)
409:                 		
410:                 		TxBuff.Len = 0; // Purge this buffer, no more required.
9D003B28  3C02A000   LUI V0, -24576
9D003B2C  AC400708   SW ZERO, 1800(V0)
411:                 	}	
412:                 	
413:                 	return(BuffLen); // Return buffer length.
9D003B30  8FC20010   LW V0, 16(S8)
414:                 	
415:                 }	
9D003B34  03C0E821   ADDU SP, S8, ZERO
9D003B38  8FBF0024   LW RA, 36(SP)
9D003B3C  8FBE0020   LW S8, 32(SP)
9D003B40  27BD0028   ADDIU SP, SP, 40
9D003B44  03E00008   JR RA
9D003B48  00000000   NOP
416:                 
417:                 
418:                 /********************************************************************
419:                 * Function: 	WriteHexRecord2Flash()
420:                 *
421:                 * Precondition: 
422:                 *
423:                 * Input: 		HexRecord buffer.
424:                 *
425:                 * Output:		None.
426:                 *
427:                 * Side Effects:	None.
428:                 *
429:                 * Overview:     Writes hex record to flash.
430:                 *
431:                 *			
432:                 * Note:		 	None.
433:                 ********************************************************************/	
434:                 void WriteHexRecord2Flash(UINT8* HexRecord, UINT totalHexRecLen)
435:                 {
9D003B4C  27BDFFC8   ADDIU SP, SP, -56
9D003B50  AFBF0034   SW RA, 52(SP)
9D003B54  AFBE0030   SW S8, 48(SP)
9D003B58  03A0F021   ADDU S8, SP, ZERO
9D003B5C  AFC40038   SW A0, 56(S8)
9D003B60  AFC5003C   SW A1, 60(S8)
436:                 	static T_HEX_RECORD HexRecordSt;
437:                 	UINT8 Checksum = 0;
9D003B64  A3C00010   SB ZERO, 16(S8)
438:                 	UINT i;
439:                 	UINT WrData;
440:                 	UINT RdData;
441:                 	void* ProgAddress;
442:                 	UINT Result;
443:                 	UINT nextRecStartPt = 0;
9D003B68  AFC00018   SW ZERO, 24(S8)
444:                 	UINT8 temp[4];
445:                 
446:                 	while(totalHexRecLen>=5) // A hex record must be atleast 5 bytes. (1 Data Len byte + 1 rec type byte+ 2 address bytes + 1 crc)
9D003B6C  0B400FE3   J 0x9D003F8C
9D003B70  00000000   NOP
9D003F8C  8FC2003C   LW V0, 60(S8)
9D003F90  2C420005   SLTIU V0, V0, 5
9D003F94  1040FEF7   BEQ V0, ZERO, 0x9D003B74
9D003F98  00000000   NOP
447:                 	{
448:                 		HexRecord = &HexRecord[nextRecStartPt];
9D003B74  8FC30038   LW V1, 56(S8)
9D003B78  8FC20018   LW V0, 24(S8)
9D003B7C  00621021   ADDU V0, V1, V0
9D003B80  AFC20038   SW V0, 56(S8)
449:                 		HexRecordSt.RecDataLen = HexRecord[0];
9D003B84  8FC20038   LW V0, 56(S8)
9D003B88  90430000   LBU V1, 0(V0)
9D003B8C  3C02A000   LUI V0, -24576
9D003B90  A0430AF4   SB V1, 2804(V0)
450:                 		HexRecordSt.RecType = HexRecord[3];	
9D003B94  8FC20038   LW V0, 56(S8)
9D003B98  24420003   ADDIU V0, V0, 3
9D003B9C  90430000   LBU V1, 0(V0)
9D003BA0  3C02A000   LUI V0, -24576
9D003BA4  24420AF4   ADDIU V0, V0, 2804
9D003BA8  A0430008   SB V1, 8(V0)
451:                 		HexRecordSt.Data = &HexRecord[4];
9D003BAC  8FC20038   LW V0, 56(S8)
9D003BB0  24430004   ADDIU V1, V0, 4
9D003BB4  3C02A000   LUI V0, -24576
9D003BB8  24420AF4   ADDIU V0, V0, 2804
9D003BBC  AC43000C   SW V1, 12(V0)
452:                 		
453:                 		//Determine next record starting point.
454:                 		nextRecStartPt = HexRecordSt.RecDataLen + 5;	
9D003BC0  3C02A000   LUI V0, -24576
9D003BC4  90420AF4   LBU V0, 2804(V0)
9D003BC8  24420005   ADDIU V0, V0, 5
9D003BCC  AFC20018   SW V0, 24(S8)
455:                 		
456:                 		// Decrement total hex record length by length of current record.
457:                 		totalHexRecLen = totalHexRecLen - nextRecStartPt;
9D003BD0  8FC3003C   LW V1, 60(S8)
9D003BD4  8FC20018   LW V0, 24(S8)
9D003BD8  00621023   SUBU V0, V1, V0
9D003BDC  AFC2003C   SW V0, 60(S8)
458:                 		
459:                 		// Hex Record checksum check.
460:                 		Checksum = 0;
9D003BE0  A3C00010   SB ZERO, 16(S8)
461:                 		for(i = 0; i < HexRecordSt.RecDataLen + 5; i++)
9D003BE4  AFC00014   SW ZERO, 20(S8)
9D003BE8  0B400F06   J 0x9D003C18
9D003BEC  00000000   NOP
9D003C0C  8FC20014   LW V0, 20(S8)
9D003C10  24420001   ADDIU V0, V0, 1
9D003C14  AFC20014   SW V0, 20(S8)
9D003C18  3C02A000   LUI V0, -24576
9D003C1C  90420AF4   LBU V0, 2804(V0)
9D003C20  24420005   ADDIU V0, V0, 5
9D003C24  00401821   ADDU V1, V0, ZERO
9D003C28  8FC20014   LW V0, 20(S8)
9D003C2C  0043102B   SLTU V0, V0, V1
9D003C30  1440FFEF   BNE V0, ZERO, 0x9D003BF0
9D003C34  00000000   NOP
462:                 		{
463:                 			Checksum += HexRecord[i];
9D003BF0  8FC30038   LW V1, 56(S8)
9D003BF4  8FC20014   LW V0, 20(S8)
9D003BF8  00621021   ADDU V0, V1, V0
9D003BFC  90430000   LBU V1, 0(V0)
9D003C00  93C20010   LBU V0, 16(S8)
9D003C04  00621021   ADDU V0, V1, V0
9D003C08  A3C20010   SB V0, 16(S8)
464:                 		}	
465:                 		
466:                 	    if(Checksum != 0)
9D003C38  93C20010   LBU V0, 16(S8)
9D003C3C  144000D3   BNE V0, ZERO, 0x9D003F8C
9D003C40  00000000   NOP
467:                 	    {
468:                 		    //Error. Hex record Checksum mismatch.
469:                 		} 
470:                 		else
471:                 		{
472:                 			// Hex record checksum OK.
473:                 			switch(HexRecordSt.RecType)
9D003C44  3C02A000   LUI V0, -24576
9D003C48  24420AF4   ADDIU V0, V0, 2804
9D003C4C  90420008   LBU V0, 8(V0)
9D003C50  24030002   ADDIU V1, ZERO, 2
9D003C54  10430092   BEQ V0, V1, 0x9D003EA0
9D003C58  00000000   NOP
9D003C5C  24030004   ADDIU V1, ZERO, 4
9D003C60  104300A9   BEQ V0, V1, 0x9D003F08
9D003C64  00000000   NOP
9D003C68  144000C1   BNE V0, ZERO, 0x9D003F70
9D003C6C  00000000   NOP
474:                 			{
475:                 				case DATA_RECORD:  //Record Type 00, data record.
476:                 					HexRecordSt.Address.byte.MB = 0;
9D003C70  3C02A000   LUI V0, -24576
9D003C74  24420AF4   ADDIU V0, V0, 2804
9D003C78  A0400007   SB ZERO, 7(V0)
477:                 					HexRecordSt.Address.byte.UB = 0;
9D003C7C  3C02A000   LUI V0, -24576
9D003C80  24420AF4   ADDIU V0, V0, 2804
9D003C84  A0400006   SB ZERO, 6(V0)
478:                 					HexRecordSt.Address.byte.HB = HexRecord[1];
9D003C88  8FC20038   LW V0, 56(S8)
9D003C8C  24420001   ADDIU V0, V0, 1
9D003C90  90430000   LBU V1, 0(V0)
9D003C94  3C02A000   LUI V0, -24576
9D003C98  24420AF4   ADDIU V0, V0, 2804
9D003C9C  A0430005   SB V1, 5(V0)
479:                 					HexRecordSt.Address.byte.LB = HexRecord[2];
9D003CA0  8FC20038   LW V0, 56(S8)
9D003CA4  24420002   ADDIU V0, V0, 2
9D003CA8  90430000   LBU V1, 0(V0)
9D003CAC  3C02A000   LUI V0, -24576
9D003CB0  24420AF4   ADDIU V0, V0, 2804
9D003CB4  A0430004   SB V1, 4(V0)
480:                 					
481:                 					// Derive the address.
482:                 					HexRecordSt.Address.Val = HexRecordSt.Address.Val + HexRecordSt.ExtLinAddress.Val + HexRecordSt.ExtSegAddress.Val;
9D003CB8  3C02A000   LUI V0, -24576
9D003CBC  24420AF4   ADDIU V0, V0, 2804
9D003CC0  8C430004   LW V1, 4(V0)
9D003CC4  3C02A000   LUI V0, -24576
9D003CC8  24420AF4   ADDIU V0, V0, 2804
9D003CCC  8C420018   LW V0, 24(V0)
9D003CD0  00621821   ADDU V1, V1, V0
9D003CD4  3C02A000   LUI V0, -24576
9D003CD8  24420AF4   ADDIU V0, V0, 2804
9D003CDC  8C420014   LW V0, 20(V0)
9D003CE0  00621821   ADDU V1, V1, V0
9D003CE4  3C02A000   LUI V0, -24576
9D003CE8  24420AF4   ADDIU V0, V0, 2804
9D003CEC  AC430004   SW V1, 4(V0)
483:                 							
484:                 					while(HexRecordSt.RecDataLen) // Loop till all bytes are done.
9D003CF0  0B400FA2   J 0x9D003E88
9D003CF4  00000000   NOP
9D003E88  3C02A000   LUI V0, -24576
9D003E8C  90420AF4   LBU V0, 2804(V0)
9D003E90  1440FF99   BNE V0, ZERO, 0x9D003CF8
9D003E94  00000000   NOP
485:                 					{
486:                 											
487:                 						// Convert the Physical address to Virtual address. 
488:                 						ProgAddress = PA_TO_KVA0(HexRecordSt.Address.Val);
9D003CF8  3C02A000   LUI V0, -24576
9D003CFC  24420AF4   ADDIU V0, V0, 2804
9D003D00  8C430004   LW V1, 4(V0)
9D003D04  3C028000   LUI V0, -32768
9D003D08  00621025   OR V0, V1, V0
9D003D0C  AFC2001C   SW V0, 28(S8)
489:                 						
490:                 						// Make sure we are not writing boot area and device configuration bits.
491:                 						if(((ProgAddress >= (void *)APP_FLASH_BASE_ADDRESS) && (ProgAddress <= (void *)APP_FLASH_END_ADDRESS))
9D003D10  8FC3001C   LW V1, 28(S8)
9D003D14  3C029D00   LUI V0, -25344
9D003D18  34426000   ORI V0, V0, 24576
9D003D1C  0062102B   SLTU V0, V1, V0
9D003D20  1440003C   BNE V0, ZERO, 0x9D003E14
9D003D24  00000000   NOP
9D003D28  3C02BF88   LUI V0, -16504
9D003D2C  8C432060   LW V1, 8288(V0)
9D003D30  3C029CFF   LUI V0, -25345
9D003D34  3442FFFF   ORI V0, V0, -1
9D003D38  00621021   ADDU V0, V1, V0
9D003D3C  00401821   ADDU V1, V0, ZERO
9D003D40  8FC2001C   LW V0, 28(S8)
9D003D44  0062102B   SLTU V0, V1, V0
9D003D48  14400032   BNE V0, ZERO, 0x9D003E14
9D003D4C  00000000   NOP
492:                 						   && ((ProgAddress < (void*)DEV_CONFIG_REG_BASE_ADDRESS) || (ProgAddress > (void*)DEV_CONFIG_REG_END_ADDRESS)))
9D003D50  8FC3001C   LW V1, 28(S8)
9D003D54  3C029FC0   LUI V0, -24640
9D003D58  34422FF0   ORI V0, V0, 12272
9D003D5C  0062102B   SLTU V0, V1, V0
9D003D60  14400007   BNE V0, ZERO, 0x9D003D80
9D003D64  00000000   NOP
9D003D68  8FC3001C   LW V1, 28(S8)
9D003D6C  3C029FC0   LUI V0, -24640
9D003D70  34423000   ORI V0, V0, 12288
9D003D74  0062102B   SLTU V0, V1, V0
9D003D78  14400026   BNE V0, ZERO, 0x9D003E14
9D003D7C  00000000   NOP
493:                 						{
494:                 							if(HexRecordSt.RecDataLen < 4)
9D003D80  3C02A000   LUI V0, -24576
9D003D84  90420AF4   LBU V0, 2804(V0)
9D003D88  2C420004   SLTIU V0, V0, 4
9D003D8C  1040000F   BEQ V0, ZERO, 0x9D003DCC
9D003D90  00000000   NOP
495:                 							{
496:                 								
497:                 								// Sometimes record data length will not be in multiples of 4. Appending 0xFF will make sure that..
498:                 								// we don't write junk data in such cases.
499:                 								WrData = 0xFFFFFFFF;
9D003D94  2402FFFF   ADDIU V0, ZERO, -1
9D003D98  AFC20024   SW V0, 36(S8)
500:                 								memcpy(&WrData, HexRecordSt.Data, HexRecordSt.RecDataLen);	
9D003D9C  3C02A000   LUI V0, -24576
9D003DA0  24420AF4   ADDIU V0, V0, 2804
9D003DA4  8C43000C   LW V1, 12(V0)
9D003DA8  3C02A000   LUI V0, -24576
9D003DAC  90420AF4   LBU V0, 2804(V0)
9D003DB0  27C40024   ADDIU A0, S8, 36
9D003DB4  00602821   ADDU A1, V1, ZERO
9D003DB8  00403021   ADDU A2, V0, ZERO
9D003DBC  77401618   JALX memcpy
9D003DC0  00000000   NOP
9D003DC4  0B400F7C   J 0x9D003DF0
9D003DC8  00000000   NOP
501:                 							}
502:                 							else
503:                 							{	
504:                 								memcpy(&WrData, HexRecordSt.Data, 4);
9D003DCC  3C02A000   LUI V0, -24576
9D003DD0  24420AF4   ADDIU V0, V0, 2804
9D003DD4  8C42000C   LW V0, 12(V0)
9D003DD8  27C30024   ADDIU V1, S8, 36
9D003DDC  00602021   ADDU A0, V1, ZERO
9D003DE0  00402821   ADDU A1, V0, ZERO
9D003DE4  24060004   ADDIU A2, ZERO, 4
9D003DE8  77401618   JALX memcpy
9D003DEC  00000000   NOP
505:                 							}		
506:                 							// Write the data into flash.	
507:                 							Result = NVMemWriteWord(ProgAddress, WrData);	
9D003DF0  8FC20024   LW V0, 36(S8)
9D003DF4  8FC4001C   LW A0, 28(S8)
9D003DF8  00402821   ADDU A1, V0, ZERO
9D003DFC  0F401462   JAL NVMemWriteWord
9D003E00  00000000   NOP
9D003E04  AFC20020   SW V0, 32(S8)
508:                 							// Assert on error. This must be caught during debug phase.		
509:                 							ASSERT(Result==0);					
9D003E08  8FC20020   LW V0, 32(S8)
9D003E0C  1440FFFE   BNE V0, ZERO, 0x9D003E08
9D003E10  00000000   NOP
510:                 						}	
511:                 						
512:                 						// Increment the address.
513:                 						HexRecordSt.Address.Val += 4;
9D003E14  3C02A000   LUI V0, -24576
9D003E18  24420AF4   ADDIU V0, V0, 2804
9D003E1C  8C420004   LW V0, 4(V0)
9D003E20  24430004   ADDIU V1, V0, 4
9D003E24  3C02A000   LUI V0, -24576
9D003E28  24420AF4   ADDIU V0, V0, 2804
9D003E2C  AC430004   SW V1, 4(V0)
514:                 						// Increment the data pointer.
515:                 						HexRecordSt.Data += 4;
9D003E30  3C02A000   LUI V0, -24576
9D003E34  24420AF4   ADDIU V0, V0, 2804
9D003E38  8C42000C   LW V0, 12(V0)
9D003E3C  24430004   ADDIU V1, V0, 4
9D003E40  3C02A000   LUI V0, -24576
9D003E44  24420AF4   ADDIU V0, V0, 2804
9D003E48  AC43000C   SW V1, 12(V0)
516:                 						// Decrement data len.
517:                 						if(HexRecordSt.RecDataLen > 3)
9D003E4C  3C02A000   LUI V0, -24576
9D003E50  90420AF4   LBU V0, 2804(V0)
9D003E54  2C420004   SLTIU V0, V0, 4
9D003E58  14400009   BNE V0, ZERO, 0x9D003E80
9D003E5C  00000000   NOP
518:                 						{
519:                 							HexRecordSt.RecDataLen -= 4;
9D003E60  3C02A000   LUI V0, -24576
9D003E64  90420AF4   LBU V0, 2804(V0)
9D003E68  2442FFFC   ADDIU V0, V0, -4
9D003E6C  304300FF   ANDI V1, V0, 255
9D003E70  3C02A000   LUI V0, -24576
9D003E74  A0430AF4   SB V1, 2804(V0)
9D003E78  0B400FA2   J 0x9D003E88
9D003E7C  00000000   NOP
520:                 						}	
521:                 						else
522:                 						{
523:                 							HexRecordSt.RecDataLen = 0;
9D003E80  3C02A000   LUI V0, -24576
9D003E84  A0400AF4   SB ZERO, 2804(V0)
524:                 						}	
525:                 					}
526:                 					break;
9D003E98  0B400FE3   J 0x9D003F8C
9D003E9C  00000000   NOP
527:                 				
528:                 				case EXT_SEG_ADRS_RECORD:  // Record Type 02, defines 4th to 19th bits of the data address.
529:                 				    HexRecordSt.ExtSegAddress.byte.MB = 0;
9D003EA0  3C02A000   LUI V0, -24576
9D003EA4  24420AF4   ADDIU V0, V0, 2804
9D003EA8  A0400017   SB ZERO, 23(V0)
530:                 					HexRecordSt.ExtSegAddress.byte.UB = HexRecordSt.Data[0];
9D003EAC  3C02A000   LUI V0, -24576
9D003EB0  24420AF4   ADDIU V0, V0, 2804
9D003EB4  8C42000C   LW V0, 12(V0)
9D003EB8  90430000   LBU V1, 0(V0)
9D003EBC  3C02A000   LUI V0, -24576
9D003EC0  24420AF4   ADDIU V0, V0, 2804
9D003EC4  A0430016   SB V1, 22(V0)
531:                 					HexRecordSt.ExtSegAddress.byte.HB = HexRecordSt.Data[1];
9D003EC8  3C02A000   LUI V0, -24576
9D003ECC  24420AF4   ADDIU V0, V0, 2804
9D003ED0  8C42000C   LW V0, 12(V0)
9D003ED4  24420001   ADDIU V0, V0, 1
9D003ED8  90430000   LBU V1, 0(V0)
9D003EDC  3C02A000   LUI V0, -24576
9D003EE0  24420AF4   ADDIU V0, V0, 2804
9D003EE4  A0430015   SB V1, 21(V0)
532:                 					HexRecordSt.ExtSegAddress.byte.LB = 0;
9D003EE8  3C02A000   LUI V0, -24576
9D003EEC  24420AF4   ADDIU V0, V0, 2804
9D003EF0  A0400014   SB ZERO, 20(V0)
533:                 					// Reset linear address.
534:                 					HexRecordSt.ExtLinAddress.Val = 0;
9D003EF4  3C02A000   LUI V0, -24576
9D003EF8  24420AF4   ADDIU V0, V0, 2804
9D003EFC  AC400018   SW ZERO, 24(V0)
535:                 					break;
9D003F00  0B400FE3   J 0x9D003F8C
9D003F04  00000000   NOP
536:                 					
537:                 				case EXT_LIN_ADRS_RECORD:   // Record Type 04, defines 16th to 31st bits of the data address. 
538:                 					HexRecordSt.ExtLinAddress.byte.MB = HexRecordSt.Data[0];
9D003F08  3C02A000   LUI V0, -24576
9D003F0C  24420AF4   ADDIU V0, V0, 2804
9D003F10  8C42000C   LW V0, 12(V0)
9D003F14  90430000   LBU V1, 0(V0)
9D003F18  3C02A000   LUI V0, -24576
9D003F1C  24420AF4   ADDIU V0, V0, 2804
9D003F20  A043001B   SB V1, 27(V0)
539:                 					HexRecordSt.ExtLinAddress.byte.UB = HexRecordSt.Data[1];
9D003F24  3C02A000   LUI V0, -24576
9D003F28  24420AF4   ADDIU V0, V0, 2804
9D003F2C  8C42000C   LW V0, 12(V0)
9D003F30  24420001   ADDIU V0, V0, 1
9D003F34  90430000   LBU V1, 0(V0)
9D003F38  3C02A000   LUI V0, -24576
9D003F3C  24420AF4   ADDIU V0, V0, 2804
9D003F40  A043001A   SB V1, 26(V0)
540:                 					HexRecordSt.ExtLinAddress.byte.HB = 0;
9D003F44  3C02A000   LUI V0, -24576
9D003F48  24420AF4   ADDIU V0, V0, 2804
9D003F4C  A0400019   SB ZERO, 25(V0)
541:                 					HexRecordSt.ExtLinAddress.byte.LB = 0;
9D003F50  3C02A000   LUI V0, -24576
9D003F54  24420AF4   ADDIU V0, V0, 2804
9D003F58  A0400018   SB ZERO, 24(V0)
542:                 					// Reset segment address.
543:                 					HexRecordSt.ExtSegAddress.Val = 0;
9D003F5C  3C02A000   LUI V0, -24576
9D003F60  24420AF4   ADDIU V0, V0, 2804
9D003F64  AC400014   SW ZERO, 20(V0)
544:                 					break;
9D003F68  0B400FE3   J 0x9D003F8C
9D003F6C  00000000   NOP
545:                 					
546:                 				case END_OF_FILE_RECORD:  //Record Type 01, defines the end of file record.
547:                 				default: 
548:                 					HexRecordSt.ExtSegAddress.Val = 0;
9D003F70  3C02A000   LUI V0, -24576
9D003F74  24420AF4   ADDIU V0, V0, 2804
9D003F78  AC400014   SW ZERO, 20(V0)
549:                 					HexRecordSt.ExtLinAddress.Val = 0;
9D003F7C  3C02A000   LUI V0, -24576
9D003F80  24420AF4   ADDIU V0, V0, 2804
9D003F84  AC400018   SW ZERO, 24(V0)
550:                 					break;
9D003F88  00000000   NOP
551:                 			}		
552:                 		}	
553:                 	}//while(1)	
554:                 		
555:                 }	
9D003F9C  03C0E821   ADDU SP, S8, ZERO
9D003FA0  8FBF0034   LW RA, 52(SP)
9D003FA4  8FBE0030   LW S8, 48(SP)
9D003FA8  27BD0038   ADDIU SP, SP, 56
9D003FAC  03E00008   JR RA
9D003FB0  00000000   NOP
556:                 
557:                 
558:                 /**
559:                  * Static table used for the table_driven implementation.
560:                  *****************************************************************************/
561:                 static const UINT16 crc_table[16] = 
562:                 {
563:                     0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
564:                     0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef
565:                 };
566:                 
567:                 /********************************************************************
568:                 * Function: 	CalculateCrc()
569:                 *
570:                 * Precondition: 
571:                 *
572:                 * Input: 		Data pointer and data length
573:                 *
574:                 * Output:		CRC.
575:                 *
576:                 * Side Effects:	None.
577:                 *
578:                 * Overview:     Calculates CRC for the given data and len
579:                 *
580:                 *			
581:                 * Note:		 	None.
582:                 ********************************************************************/	
583:                 UINT16 CalculateCrc(UINT8 *data, UINT32 len)
584:                 {
9D003FB4  27BDFFF0   ADDIU SP, SP, -16
9D003FB8  AFBE000C   SW S8, 12(SP)
9D003FBC  03A0F021   ADDU S8, SP, ZERO
9D003FC0  AFC40010   SW A0, 16(S8)
9D003FC4  AFC50014   SW A1, 20(S8)
585:                     UINT i;
586:                     UINT16 crc = 0;
9D003FC8  A7C00000   SH ZERO, 0(S8)
587:                     
588:                     while(len--)
9D003FCC  0B401026   J 0x9D004098
9D003FD0  00000000   NOP
9D004098  8FC20014   LW V0, 20(S8)
9D00409C  0002102B   SLTU V0, ZERO, V0
9D0040A0  304200FF   ANDI V0, V0, 255
9D0040A4  8FC30014   LW V1, 20(S8)
9D0040A8  2463FFFF   ADDIU V1, V1, -1
9D0040AC  AFC30014   SW V1, 20(S8)
9D0040B0  1440FFC8   BNE V0, ZERO, 0x9D003FD4
9D0040B4  00000000   NOP
589:                     {
590:                         i = (crc >> 12) ^ (*data >> 4);
9D003FD4  97C20000   LHU V0, 0(S8)
9D003FD8  00021302   SRL V0, V0, 12
9D003FDC  3042FFFF   ANDI V0, V0, -1
9D003FE0  00401821   ADDU V1, V0, ZERO
9D003FE4  8FC20010   LW V0, 16(S8)
9D003FE8  90420000   LBU V0, 0(V0)
9D003FEC  00021102   SRL V0, V0, 4
9D003FF0  304200FF   ANDI V0, V0, 255
9D003FF4  00621026   XOR V0, V1, V0
9D003FF8  AFC20004   SW V0, 4(S8)
591:                 	    crc = crc_table[i & 0x0F] ^ (crc << 4);
9D003FFC  8FC20004   LW V0, 4(S8)
9D004000  3043000F   ANDI V1, V0, 15
9D004004  3C029D00   LUI V0, -25344
9D004008  00031840   SLL V1, V1, 1
9D00400C  244257C4   ADDIU V0, V0, 22468
9D004010  00621021   ADDU V0, V1, V0
9D004014  94420000   LHU V0, 0(V0)
9D004018  7C021E20   SEH V1, V0
9D00401C  97C20000   LHU V0, 0(S8)
9D004020  00021100   SLL V0, V0, 4
9D004024  7C021620   SEH V0, V0
9D004028  00621026   XOR V0, V1, V0
9D00402C  7C021620   SEH V0, V0
9D004030  A7C20000   SH V0, 0(S8)
592:                 	    i = (crc >> 12) ^ (*data >> 0);
9D004034  97C20000   LHU V0, 0(S8)
9D004038  00021302   SRL V0, V0, 12
9D00403C  3042FFFF   ANDI V0, V0, -1
9D004040  00401821   ADDU V1, V0, ZERO
9D004044  8FC20010   LW V0, 16(S8)
9D004048  90420000   LBU V0, 0(V0)
9D00404C  00621026   XOR V0, V1, V0
9D004050  AFC20004   SW V0, 4(S8)
593:                 	    crc = crc_table[i & 0x0F] ^ (crc << 4);
9D004054  8FC20004   LW V0, 4(S8)
9D004058  3043000F   ANDI V1, V0, 15
9D00405C  3C029D00   LUI V0, -25344
9D004060  00031840   SLL V1, V1, 1
9D004064  244257C4   ADDIU V0, V0, 22468
9D004068  00621021   ADDU V0, V1, V0
9D00406C  94420000   LHU V0, 0(V0)
9D004070  7C021E20   SEH V1, V0
9D004074  97C20000   LHU V0, 0(S8)
9D004078  00021100   SLL V0, V0, 4
9D00407C  7C021620   SEH V0, V0
9D004080  00621026   XOR V0, V1, V0
9D004084  7C021620   SEH V0, V0
9D004088  A7C20000   SH V0, 0(S8)
594:                 	    data++;
9D00408C  8FC20010   LW V0, 16(S8)
9D004090  24420001   ADDIU V0, V0, 1
9D004094  AFC20010   SW V0, 16(S8)
595:                 	} 
596:                 
597:                     return (crc & 0xFFFF);
9D0040B8  97C20000   LHU V0, 0(S8)
598:                 }
9D0040BC  03C0E821   ADDU SP, S8, ZERO
9D0040C0  8FBE000C   LW S8, 12(SP)
9D0040C4  27BD0010   ADDIU SP, SP, 16
9D0040C8  03E00008   JR RA
9D0040CC  00000000   NOP
599:                 
600:                 
601:                 /********************************************************************
602:                 * Function: 	ExitFirmwareUpgradeMode()
603:                 *
604:                 * Precondition: 
605:                 *
606:                 * Input: 		Void
607:                 *
608:                 * Output:		True if firmware upgrade mode has to be exited.
609:                 *
610:                 * Side Effects:	None.
611:                 *
612:                 * Overview:     This function returns true if firmware mode has to be exited.
613:                 *
614:                 *			
615:                 * Note:		 	None.
616:                 ********************************************************************/
617:                 BOOL ExitFirmwareUpgradeMode(void)
618:                 {
9D0040D0  27BDFFF8   ADDIU SP, SP, -8
9D0040D4  AFBE0004   SW S8, 4(SP)
9D0040D8  03A0F021   ADDU S8, SP, ZERO
619:                 	return RunApplication;
9D0040DC  8F82801C   LW V0, -32740(GP)
620:                 }	
9D0040E0  03C0E821   ADDU SP, S8, ZERO
9D0040E4  8FBE0004   LW S8, 4(SP)
9D0040E8  27BD0008   ADDIU SP, SP, 8
9D0040EC  03E00008   JR RA
9D0040F0  00000000   NOP
621:                 
622:                 /**************************End of file**************************************************/
623:                 
---  /home/bekeband/MPLABXProjects/AN1388_Source_Code_2014_02_14/PIC32_Bootloaders/Firmware/Bootloader/Source/BootLoader.c
1:                   /*********************************************************************
2:                    *
3:                    *                  PIC32 Boot Loader
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Bootloader.c
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   * Compiler:        MPLAB C32
11:                   *                  MPLAB IDE
12:                   * Company:         Microchip Technology, Inc.
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * The software supplied herewith by Microchip Technology Incorporated
17:                   * (the ï¿½Companyï¿½) for its PIC32 Microcontroller is intended
18:                   * and supplied to you, the Companyï¿½s customer, for use solely and
19:                   * exclusively on Microchip PIC32 Microcontroller products.
20:                   * The software is owned by the Company and/or its supplier, and is
21:                   * protected under applicable copyright laws. All rights are reserved.
22:                   * Any use in violation of the foregoing restrictions may subject the
23:                   * user to criminal sanctions under applicable laws, as well as to
24:                   * civil liability for the breach of the terms and conditions of this
25:                   * license.
26:                   *
27:                   * THIS SOFTWARE IS PROVIDED IN AN ï¿½AS ISï¿½ CONDITION. NO WARRANTIES,
28:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
29:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
30:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
31:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
32:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
33:                   *
34:                   *
35:                   * $Id:  $
36:                   * $Name: $
37:                   *
38:                   **********************************************************************/
39:                  #include "Include/GenericTypeDefs.h"
40:                  #include "Include/HardwareProfile/HardwareProfile.h"
41:                  #include "Include/BootLoader.h"
42:                  #include "Include/Framework/Framework.h"
43:                  #include <stdlib.h>
44:                  #include <plib.h>
45:                  
46:                  
47:                  // Configuring the Device Configuration Registers
48:                  // 80Mhz Core/Periph, Pri Osc w/PLL, Write protect Boot Flash
49:                  #if defined(TRANSPORT_LAYER_USB) || defined(TRANSPORT_LAYER_USB_HOST)
50:                      #pragma config UPLLEN   = ON        // USB PLL Enabled
51:                      #pragma config UPLLIDIV = DIV_2     // USB PLL Input Divider = Divide by 2
52:                  #endif
53:                  
54:                  #pragma config DEBUG    = OFF           // Background Debugger disabled
55:                  #pragma config FPLLMUL = MUL_20         // PLL Multiplier: Multiply by 20
56:                  #pragma config FPLLIDIV = DIV_2         // PLL Input Divider:  Divide by 2
57:                  
58:                  #if defined(__PIC32MX1XX_2XX__)
59:                      // For PIC32MX1xx, PIC32MX2xx devices the output divisor is set to 2 to produce max 40MHz clock.
60:                      #pragma config FPLLODIV = DIV_2         // PLL Output Divider: Divide by 2
61:                  #elif defined (__PIC32MX3XX_7XX__)
62:                      //For PIC32MX3xx, PIC32MX4xx, PIC32MX5xx, PIC32MX6xx and PIC32MX7xx devices, 
63:                      //the output divisor is set to 1 to produce max 80MHz clock.
64:                      #pragma config FPLLODIV = DIV_1         // PLL Output Divider: Divide by 1
65:                  #endif
66:                  
67:                  #pragma config FWDTEN = OFF             // WD timer: OFF
68:                  #pragma config POSCMOD = HS             // Primary Oscillator Mode: High Speed xtal
69:                  #pragma config FNOSC = PRIPLL           // Oscillator Selection: Primary oscillator  w/ PLL
70:                  #pragma config FPBDIV = DIV_1           // Peripheral Bus Clock: Divide by 1
71:                  #pragma config BWP = OFF                // Boot write protect: OFF
72:                  
73:                  #if defined(__PIC32MX1XX_2XX__)
74:                      // For PIC32MX1xx, PIC32MX2xx devices there are jumpers on PIM to choose from PGx1/PGx2.
75:                      #pragma config ICESEL = ICS_PGx1    // ICE pins configured on PGx1 (PGx2 is multiplexed with USB D+ and D- pins).
76:                  #elif defined(__PIC32MX3XX_7XX__)
77:                      // For PIC32MX3xx, PIC32MX4xx, PIC32MX5xx, PIC32MX6xx and PIC32MX7xx 
78:                      // devices the ICE connection is on PGx2. .
79:                      #pragma config ICESEL = ICS_PGx2    // ICE pins configured on PGx2, Boot write protect OFF.
80:                  #endif
81:                      
82:                  #if defined(TRANSPORT_LAYER_ETH)
83:                  	#pragma config FMIIEN = OFF, FETHIO = OFF	// external PHY in RMII/alternate configuration. Applicable for devices with internal MAC only.
84:                  #endif
85:                  
86:                  #define SWITCH_PRESSED 0
87:                  
88:                  
89:                  
90:                  #ifdef __cplusplus
91:                  extern "C" {
92:                  #endif
93:                  BOOL CheckTrigger(void);
94:                  void JumpToApp(void);
95:                  BOOL ValidAppPresent(void);
96:                  #ifdef __cplusplus
97:                  }
98:                  #endif
99:                  /********************************************************************
100:                 * Function: 	main()
101:                 *
102:                 * Precondition: 
103:                 *
104:                 * Input: 		None.
105:                 *
106:                 * Output:		None.
107:                 *
108:                 * Side Effects:	None.
109:                 *
110:                 * Overview: 	Main entry function. If there is a trigger or 
111:                 *				if there is no valid application, the device 
112:                 *				stays in firmware upgrade mode.
113:                 *
114:                 *			
115:                 * Note:		 	None.
116:                 ********************************************************************/
117:                 INT main(void)
118:                 {
9D00461C  27BDFF98   ADDIU SP, SP, -104
9D004620  AFBF0064   SW RA, 100(SP)
9D004624  AFBE0060   SW S8, 96(SP)
9D004628  03A0F021   ADDU S8, SP, ZERO
9D00462C  3C0204C4   LUI V0, 1220
9D004630  3442B400   ORI V0, V0, -19456
9D004634  AFC20014   SW V0, 20(S8)
9D004638  24020005   ADDIU V0, ZERO, 5
9D00463C  AFC20018   SW V0, 24(S8)
119:                 	UINT pbClk;
120:                 
121:                 	// Setup configuration
122:                 	pbClk = SYSTEMConfig(SYS_FREQ, SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
9D0048F8  AFC20010   SW V0, 16(S8)
123:                 	
124:                 	InitLED();
9D0048FC  3C02BF81   LUI V0, -16511
9D004900  AC409060   SW ZERO, -28576(V0)
9D004904  3C03BF88   LUI V1, -16504
9D004908  8C6260C0   LW V0, 24768(V1)
9D00490C  7C021084   INS V0, ZERO, 2, 1
9D004910  AC6260C0   SW V0, 24768(V1)
9D004914  3C03BF88   LUI V1, -16504
9D004918  8C6260C0   LW V0, 24768(V1)
9D00491C  7C020844   INS V0, ZERO, 1, 1
9D004920  AC6260C0   SW V0, 24768(V1)
9D004924  3C03BF88   LUI V1, -16504
9D004928  8C6260C0   LW V0, 24768(V1)
9D00492C  7C020004   INS V0, ZERO, 0, 1
9D004930  AC6260C0   SW V0, 24768(V1)
9D004934  3C03BF88   LUI V1, -16504
9D004938  8C6260E0   LW V0, 24800(V1)
9D00493C  7C020004   INS V0, ZERO, 0, 1
9D004940  AC6260E0   SW V0, 24800(V1)
9D004944  3C03BF88   LUI V1, -16504
9D004948  8C6260E0   LW V0, 24800(V1)
9D00494C  7C020844   INS V0, ZERO, 1, 1
9D004950  AC6260E0   SW V0, 24800(V1)
9D004954  3C03BF88   LUI V1, -16504
9D004958  8C6260E0   LW V0, 24800(V1)
9D00495C  7C021084   INS V0, ZERO, 2, 1
9D004960  AC6260E0   SW V0, 24800(V1)
125:                 	
126:                 	// Enter firmware upgrade mode if there is a trigger or if the application is not valid
127:                 	if(CheckTrigger() || !ValidAppPresent())
9D004964  0F401284   JAL CheckTrigger
9D004968  00000000   NOP
9D00496C  14400005   BNE V0, ZERO, 0x9D004984
9D004970  00000000   NOP
9D004974  0F4012AB   JAL ValidAppPresent
9D004978  00000000   NOP
9D00497C  1440001B   BNE V0, ZERO, 0x9D0049EC
9D004980  00000000   NOP
128:                 	{
129:                 		// Initialize the transport layer - UART/USB/Ethernet
130:                 		TRANS_LAYER_Init(pbClk);
9D004984  8FC40010   LW A0, 16(S8)
9D004988  0F4012BF   JAL UsbInit
9D00498C  00000000   NOP
131:                 		
132:                 		while(!FRAMEWORK_ExitFirmwareUpgradeMode()) // Be in loop till framework recieves "run application" command from PC
9D004990  0B401275   J 0x9D0049D4
9D004994  00000000   NOP
9D0049D4  0F401034   JAL ExitFirmwareUpgradeMode
9D0049D8  00000000   NOP
9D0049DC  1040FFEE   BEQ V0, ZERO, 0x9D004998
9D0049E0  00000000   NOP
133:                 		{
134:                 			// Enter firmware upgrade mode.
135:                 			// Be in loop, looking for commands from PC
136:                 			TRANS_LAYER_Task(); // Run Transport layer tasks
9D004998  0F4012D7   JAL UsbTasks
9D00499C  00000000   NOP
137:                 			FRAMEWORK_FrameWorkTask(); // Run frame work related tasks (Handling Rx frame, process frame and so on)
9D0049A0  0F400D16   JAL FrameWorkTask
9D0049A4  00000000   NOP
138:                 			// Blink LED (Indicates the user that bootloader is running).
139:                 			BlinkLED();	
9D0049A8  0F401629   JAL ReadCoreTimer
9D0049AC  00000000   NOP
9D0049B0  00401821   ADDU V1, V0, ZERO
9D0049B4  3C020080   LUI V0, 128
9D0049B8  00621024   AND V0, V1, V0
9D0049BC  0002102B   SLTU V0, ZERO, V0
9D0049C0  304400FF   ANDI A0, V0, 255
9D0049C4  3C03BF88   LUI V1, -16504
9D0049C8  8C6260E0   LW V0, 24800(V1)
9D0049CC  7C821084   INS V0, A0, 2, 1
9D0049D0  AC6260E0   SW V0, 24800(V1)
140:                 		}
141:                 		// Close trasnport layer.
142:                 		TRANS_LAYER_Close();
9D0049E4  0F4012CC   JAL UsbClose
9D0049E8  00000000   NOP
143:                 	}
144:                 
145:                 	
146:                 	// No trigger + valid application = run application.
147:                 	JumpToApp();
9D0049EC  0F40129B   JAL JumpToApp
9D0049F0  00000000   NOP
148:                 	
149:                 	return 0;
9D0049F4  00001021   ADDU V0, ZERO, ZERO
150:                 }			
9D0049F8  03C0E821   ADDU SP, S8, ZERO
9D0049FC  8FBF0064   LW RA, 100(SP)
9D004A00  8FBE0060   LW S8, 96(SP)
9D004A04  27BD0068   ADDIU SP, SP, 104
9D004A08  03E00008   JR RA
9D004A0C  00000000   NOP
151:                 
152:                 
153:                 /********************************************************************
154:                 * Function: 	CheckTrigger()
155:                 *
156:                 * Precondition: 
157:                 *
158:                 * Input: 		None.
159:                 *
160:                 * Output:		TRUE: If triggered
161:                 				FALSE: No trigger
162:                 *
163:                 * Side Effects:	None.
164:                 *
165:                 * Overview: 	Checks if there is a trigger to enter 
166:                 				firmware upgrade mode.
167:                 *
168:                 *			
169:                 * Note:		 	None.
170:                 ********************************************************************/
171:                 BOOL  CheckTrigger(void)
172:                 {
9D004A10  27BDFFE0   ADDIU SP, SP, -32
9D004A14  AFBF001C   SW RA, 28(SP)
9D004A18  AFBE0018   SW S8, 24(SP)
9D004A1C  03A0F021   ADDU S8, SP, ZERO
173:                 	UINT SwitchStatus;
174:                 	SwitchStatus = ReadSwitchStatus();
9D004A20  24040003   ADDIU A0, ZERO, 3
9D004A24  24052000   ADDIU A1, ZERO, 8192
9D004A28  7740160C   JALX PORTReadBits
9D004A2C  00000000   NOP
9D004A30  30422000   ANDI V0, V0, 8192
9D004A34  AFC20010   SW V0, 16(S8)
175:                 	if(SwitchStatus == SWITCH_PRESSED)
9D004A38  8FC20010   LW V0, 16(S8)
9D004A3C  14400004   BNE V0, ZERO, 0x9D004A50
9D004A40  00000000   NOP
176:                 	{
177:                 		// Switch is pressed
178:                 		return TRUE;		
9D004A44  24020001   ADDIU V0, ZERO, 1
9D004A48  0B401295   J 0x9D004A54
9D004A4C  00000000   NOP
179:                 	}	
180:                 	else
181:                 	{
182:                 		// Switch is not pressed.
183:                 		return FALSE;	
9D004A50  00001021   ADDU V0, ZERO, ZERO
184:                 	}	
185:                 }	
9D004A54  03C0E821   ADDU SP, S8, ZERO
9D004A58  8FBF001C   LW RA, 28(SP)
9D004A5C  8FBE0018   LW S8, 24(SP)
9D004A60  27BD0020   ADDIU SP, SP, 32
9D004A64  03E00008   JR RA
9D004A68  00000000   NOP
186:                 
187:                 
188:                 /********************************************************************
189:                 * Function: 	JumpToApp()
190:                 *
191:                 * Precondition: 
192:                 *
193:                 * Input: 		None.
194:                 *
195:                 * Output:		
196:                 *
197:                 * Side Effects:	No return from here.
198:                 *
199:                 * Overview: 	Jumps to application.
200:                 *
201:                 *			
202:                 * Note:		 	None.
203:                 ********************************************************************/
204:                 void JumpToApp(void)
205:                 {	
9D004A6C  27BDFFE0   ADDIU SP, SP, -32
9D004A70  AFBF001C   SW RA, 28(SP)
9D004A74  AFBE0018   SW S8, 24(SP)
9D004A78  03A0F021   ADDU S8, SP, ZERO
206:                 	void (*fptr)(void);
207:                 	fptr = (void (*)(void))USER_APP_RESET_ADDRESS;
9D004A7C  3C029D00   LUI V0, -25344
9D004A80  34427000   ORI V0, V0, 28672
9D004A84  AFC20010   SW V0, 16(S8)
208:                 	fptr();
9D004A88  8FC20010   LW V0, 16(S8)
9D004A8C  0040F809   JALR V0
9D004A90  00000000   NOP
209:                 }	
9D004A94  03C0E821   ADDU SP, S8, ZERO
9D004A98  8FBF001C   LW RA, 28(SP)
9D004A9C  8FBE0018   LW S8, 24(SP)
9D004AA0  27BD0020   ADDIU SP, SP, 32
9D004AA4  03E00008   JR RA
9D004AA8  00000000   NOP
210:                 
211:                 
212:                 /********************************************************************
213:                 * Function: 	ValidAppPresent()
214:                 *
215:                 * Precondition: 
216:                 *
217:                 * Input: 		None.
218:                 *
219:                 * Output:		TRUE: If application is valid.
220:                 *
221:                 * Side Effects:	None.
222:                 *
223:                 * Overview: 	Logic: Check application vector has 
224:                 				some value other than "0xFFFFFFFF"
225:                 *
226:                 *			
227:                 * Note:		 	None.
228:                 ********************************************************************/
229:                 BOOL ValidAppPresent(void)
230:                 {
9D004AAC  27BDFFF0   ADDIU SP, SP, -16
9D004AB0  AFBE000C   SW S8, 12(SP)
9D004AB4  03A0F021   ADDU S8, SP, ZERO
231:                 	DWORD *AppPtr;
232:                 	AppPtr = (DWORD *)USER_APP_RESET_ADDRESS;
9D004AB8  3C029D00   LUI V0, -25344
9D004ABC  34427000   ORI V0, V0, 28672
9D004AC0  AFC20000   SW V0, 0(S8)
233:                 	if(*AppPtr == 0xFFFFFFFF)
9D004AC4  8FC20000   LW V0, 0(S8)
9D004AC8  8C430000   LW V1, 0(V0)
9D004ACC  2402FFFF   ADDIU V0, ZERO, -1
9D004AD0  14620004   BNE V1, V0, 0x9D004AE4
9D004AD4  00000000   NOP
234:                 	{
235:                 		return FALSE;
9D004AD8  00001021   ADDU V0, ZERO, ZERO
9D004ADC  0B4012BA   J 0x9D004AE8
9D004AE0  00000000   NOP
236:                 	}
237:                 	else
238:                 	{
239:                 		return TRUE;
9D004AE4  24020001   ADDIU V0, ZERO, 1
240:                 	}
241:                 }			
9D004AE8  03C0E821   ADDU SP, S8, ZERO
9D004AEC  8FBE000C   LW S8, 12(SP)
9D004AF0  27BD0010   ADDIU SP, SP, 16
9D004AF4  03E00008   JR RA
9D004AF8  00000000   NOP
242:                 
243:                 
244:                 /*********************End of File************************************/
245:                 
246:                 
